## **Transcriptomics Analysis Pipeline** 

Recommended post: 【Bioinformatics】 [Bioinformatics Analysis Table of Contents](https://jb243.github.io/pages/836)

---

**1.** [**QC 1.** Experimental QC](#1-qc-1-tissue-qc-sample-level-quality-control)

**2.** [**QC 2.** Data QC](#2-qc-2-data-qc-sequence-level-quality-control)

**3.** [**QC 3.** Filtering](#3-qc-3-filtering)

**4.** [**QC 4.** Alignment](#4-qc-4-alignment)

**5.** [**QC 5.** Normalization](#5-qc-5-normalization)

**6.** [**QC 6.** Batch Effect](#6-qc-6-batch-effect)

**7.** [**Common 1.** Clustering](#7-common-1-clustering)

**8.** [**Common 2.** Differentially Expressed Gene (DEG) Analysis](#8-common-2-differentially-expressed-gene-deg-analysis)

**9.** [**Common 3.** Gene Set Enrichment](#9-common-3-gene-set-enrichment)

**10.** [**Common 4.** Gene Interaction Analysis](#10-common-4-gene-interaction-analysis)

**11.** [**Common 5.** Cell Type Mapping Analysis](#11-common-5-cell-type-mapping-analysis)

**12.** [**Advanced 1.** Alternative Splicing Analysis (AS Analysis)](#12-advanced-1-alternative-splicing-analysis-as-analysis)

**13.** [**Advanced 2.** Trajectory Analysis](#13-advanced-2-trajectory-analysis)

**14.** [**Advanced 3.** Epigenomics Analysis](#14-advanced-3-epigenomics-analysis)

**15.** [**Advanced 4.** Special Transcriptpmics Analysis](#15-advanced-4-special-transcriptomics-analysis)

**16.** [**Advanced 5.** Database Utilization](#16-advanced-5-database-utilization)

---

**a.** [Sequencing Technologies](https://jb243.github.io/pages/75)

**b.** [Bioinformatics](https://jb243.github.io/pages/1831) 

**c.** [Seurat Pipeline](https://jb243.github.io/pages/1788)

**d.** [Proteomics Pipeline](https://jb243.github.io/pages/2085) 

---

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/5d79e798-1bec-4bf2-b203-b6ba46b1e3bc)

**Figure 1.** Analysis Guides

<br>

## **1. `QC 1.`** Experimental QC (Sample Level Quality Control)

⑴ Definition: Metric for assessing tissue quality

⑵ RNA-seq methodology

> ① **Step 1.** Purify RNA: DNAse treatment to remove genomic content

> ② **Step 2.** Enrich for mRNA using polyA selection 

> ③ **Step 3.** Fragment RNA to library insert size (200-400 nt)

> ④ **Step 4.** Convert RNA to cDNA 

> ⑤ **Step 5.** Prepare cDNA for sequencing (ligate adapters, amplify, add barcodes)

> ⑥ **Step 6.** Sequence one or both ends of fragments (usually 50, 100, or 150 nt per read)

> ⑦ **Step 7.** Map to genome 

⑶ **Type 1.** RIN (RNA Integrity Number)

> ① Background Knowledge: mRNA comprises less than 3% of total RNA. rRNA makes up more than 80% (mainly 28S [2 kb] and 18S [5 kb] in eukaryotic cells).

> ② Measured by the Agilent 2100 Bioanalyzer.

> ③ RIN Algorithm: It uses features such as the ratio of 18S to total RNA, the ratio of 28S to total RNA, and the 18S normalized height.

> ④ RIN = 10: Intact RNA.

> ⑤ RIN = 1: Completely degraded RNA.

> ⑥ RIN > 7: Generally considered suitable quality level for RNA-seq.

⑷ **Type 2.** DV200: Percentage of fragments around 200 nt in FFPE tissues, indicating RNA fragmentation

⑸ **Type 3.** Nucleic Acid Purity Quantification via Absorbance Ratio

> ① 260 nm / 280 nm Ratio

>> ○ Pure DNA: ~1.8

>> ○ Pure RNA: ~2.0

>> ○ A low 260 nm / 280 nm ratio suggests the presence of proteins or phenol, which absorb at 280 nm.

> ② 260 nm / 230 nm Ratio

>> ○ Pure DNA/RNA molecules: ~2-2.2

>> ○ A low 260 nm / 230 nm ratio indicates the presence of other contaminants.

⑹ **Type 4.** Nucleic Acid Weight Quantification

> ① Extract RNA using miRNeasy Mini Kit (QIAGEN) or similar methods.

> ② RNA weight criterion: At least 250 ng.

⑺ **Type 5.** RNA Quality Score (RQS)

⑻ **Type 6.** ChIP-seq Experimental QC

> ① ChIP grade monoclonal antibody: Pre-tested with ChIP-seq. 20-30% of the commercially produced antibodies tested were unsatisfactory for ChIP-seq.

> ② qPCR: Best to test positive control region(s) using the ChIP sample. Hope to detect >10-12x fold enrichment over IgG (non-specific antibody).

> ③ Biotinylated transcription factor: Permits factor pull-down on streptavidin. Independent of antibodies.

> ④ CUT&RUN, CUT&Tag, and ChIP-exo are methods to improve the resolution and signal-to-noise ratio of peaks in ChIP-seq.

⑼ **Type 7.** ATAC-seq Experimental QC 

> ① Tn5 Concentration: Higher Tn5 concentration relative to DNA concentration increases ATAC-seq signal intensity at promoters and enhancers while reducing fragment size.

> ② Sequencing Lane Cluster Density: Shifts fragment length distribution and TSS enrichment.

<br>

<br>

## **2. `QC 2.`** Data QC (Sequence Level Quality Control)

⑴ Definition: Metric for assessing data quality

⑵ **Type 1:** QC metrics for the data itself: Used for external validity confirmation by manual inspection or comparing with other datasets

> ① QC metrics

>> ○ [dUTP method](https://jb243.github.io/pages/75#:~:text=%E2%91%A9%20%EC%9D%91%EC%9A%A9%201.-,dUTP%20method,-%3A%20strand%2Dspecific): "_1.fastq" represents first strand (anti-sense), "_2.fastq" represents second strand (sense; original RNA sequence)

>> ○ **base quality**

>> ○ **mapping rate**

>>> ○ mappability filter 

>>>> ○ **Type 1.** uniqueness: How unique each sequence is starting at a particualr base and of a particular length

>>>> ○ **Type 2.** alignability: How uniquely k-mer sequences align to a region of the genome (up to 2 mismatches allowed)

>>> ○ mappability score : S = 1 / # of matches found in genome 

>>> ○ Long reads can resolve mapping issue among highly similar regions: Some regions of the genome are troublesome regardless of read length.

>> ○ **Non-coding RNA ratio**

>>> ○ High non-coding RNA ratio and high duplication indicate poor RNA quality

>> ○ **GC content**

>>> ○ High GC content: Suggests potential rRNA contamination; requires filtering of 5S, 18S, 28S rRNA

>>> ○ Low GC content: Indicates potential issues with reverse transcription

>>> ○ Related to CpG island.

>> ○ **Read duplicate**

>>> ○ PCR duplicate: A duplicate that is merely a replication of the same nucleic acid molecule during PCR.

>>> ○ If the sequences are exactly the same, they are considered PCR duplicates. If they are similar, they are considered biological duplicates.

>>> ○ In paired-end experiments, duplicates occur at the paired-end level.

>>> ○ Generally, DNA-seq involves removing duplicates, while RNA-seq does not: In RNA-seq, the same sequence may repeatedly appear not only due to technical duplicates but also due to high expressing transcripts or short genes. Removing these biological duplicates can reduce the dynamic range of the data or decrease statistical power.

>>> ○ The likelihood of increased duplication rate may rise with the number of cycles during the PCR process: By checking the correlation between the duplicate rate and the number of PCR cycles, one can distinguish between technical and biological duplicates.

>>> ○ Tools for removing duplicates: Samtools, Picard, Trimmomatic, Trim Galore!, fastp 

>> ○ **Unique molecule**(UMI)

>>> ○ RNA quality is low if unique molecule count is below 10%

>> ○ **Sequencing depth**

>>> ○ # of reads

>>> ○ In cases of alternative splicing or allele-specific expression: >50 million reads are recommended

>>> ○ DEG analysis of a ribo-depleted library: Approximately 50-60 million total reads are recommended

>>> ○ A ribo-depleted library is recommended to have twice the sequencing depth compared to a poly-A selected library because the ribo-depleted library can capture a wider variety of RNA (e.g., tRNA, rRNA, immature RNA) that the poly-A selected library cannot capture.

>> ○ **Sequencing read length**

>>> ○ Small fragments: Adaptor binding starts, requiring adaptor trimming.

<br>

![image](https://github.com/user-attachments/assets/5e92df3a-d9fb-4af6-a0fd-226a2c96473f)

**Figure 2.** The reason why adaptors are read when fragments are short

<br>

>>> ○ Advantages of long-read sequencing compared to short-read sequencing: lower cost per nucleotide, more accurate mapping, ability to identify splice junctions, capability to detect allele-specific expression, ability to resolve repetitive sequences.

>>> ○ Disadvantages of long-read sequencing compared to short-read sequencing: higher overall cost, higher cost per read, requires more adaptor trimming. Long-read sequencing (PacBio, Oxford Nanopore) is more likely to contain adapter sequences due to its sequencing method, which involves repetitive reading and single-molecule sequencing.

>> ○ **Adaptor sequence**

>>> ○ **Issue 1:** Since adapter sequences are artificial, they can cause alignment and variant calling to fail or introduce biases.

>>> ○ **Issue 2:** Adapter sequences contain identical sequences, leading to biases in coverage analysis and differential gene expression (DEG) analysis.

>>> ○ To remove adapter sequences, tools such as AdaptorRemoval, Cutadapt, Trimmomatic, and bbduk.sh are used.

>> ○ **Exonic portion**

>>> ○ In the case of poly-A(+) RNA-seq, exonic reads account for 50 to 70%.

>>> ○ In the case of rRNA(-) RNA-seq, the proportion of exonic reads decreases.

>> ○ **Paired-end vs Single-end**

>>> ○ Single end reads: Each library fragment is sequenced only from a single end.

>>> ○ Paired end reads: Each library fragment is sequenced from both ends. 

>>> ○ Paired-end (PE) reads are more accurate than single-end (SE) reads but are approximately twice as expensive.  

>>> ○ If the goal is simply to calculate gene counts for DEG analysis, SE is sufficient.  

>>> ○ SE is recommended when RNA is significantly degraded.  

>>> ○ It's better to avoid using PE on short fragments to prevent inefficiencies caused by sequencing the same nucleotide.  

<br>

<img width="508" alt="스크린샷 2025-01-20 오후 8 31 49" src="https://github.com/user-attachments/assets/e6dc469a-fad2-4aea-9e5e-403467ecc15d" />

**Figure 3.** Inefficiencies that can occur in paired-end (PE) sequencing

<br>

>> ○ **Mate pair reads** 

>>> ○ A longer segment of DNA is circularized and reads from the joint region are sequenced (both ends).

>> ○ **Strand-specific** (ssRNA-seq)

>>> ○ Can be either forward or reverse.

>> ○ **Poly-A selection vs Ribo-depletion**

>>> ○ Advantages of a ribo-depletion library

>>>> ○ Works even with RNA degradation: cDNA fragments are uneven and short. Poly-A selection is highly biased toward the 3' end, making it less accurate.

>>>> ○ Suitable for studying non-coding RNA.

>>> ○ Disadvantages of a ribo-depletion library

>>>> ○ Expensive.

>>>> ○ Includes a large number of meaningless reads. 

> ② QC metrics for ChIP-seq

>> ○ [Mapping ratio](https://www.sciencedirect.com/science/article/pii/S1046202320300591)

>> ○ [Read depth](https://www.sciencedirect.com/science/article/pii/S1046202320300591): ENCODE recommends ≥10 million uniquely mapped reads for TFs (histone modifications).

>> ○ [Library complexity](https://www.sciencedirect.com/science/article/pii/S1046202320300591)

>> ○ [Background uniformity](https://www.sciencedirect.com/science/article/pii/S1046202320300591) (biasedness)

>> ○ [GC summit bias](https://www.sciencedirect.com/science/article/pii/S1046202320300591)

>> ○ qPCR enrichment

>> ○ [Fragment size distribution](https://pmc.ncbi.nlm.nih.gov/articles/PMC3431496/)

>> ○ Input DNA qualuty via NanoDrop

>> ○ [Cross-correlation analysis](https://pmc.ncbi.nlm.nih.gov/articles/PMC3431496/): NSC (normalized strand coefficient), RSC (relative strand correlation)

>> ○ FRiP (fraction of reads in peaks) ([ref1](https://pmc.ncbi.nlm.nih.gov/articles/PMC3431496/), [ref2](https://doi.org/10.1038/nbt.1505)), RUP(reads under peaks): Proportion of reads in a ChIP-seq dataset that falls into a peak. ENCODE recommends FRiP (RUP) ≥ 1%.

>> ○ SPOT(signal portion in tags): Indicates good signal-to-noise ratio.

>> ○ IDR (irreproducibility discovery rate) ([ref1](https://pmc.ncbi.nlm.nih.gov/articles/PMC3431496/), [ref2](https://projecteuclid.org/journals/annals-of-applied-statistics/volume-5/issue-3/Measuring-reproducibility-of-high-throughput-experiments/10.1214/11-AOAS466.full))

>> ○ denQCi, simQCi, QC-STAMP ([ref](https://pmc.ncbi.nlm.nih.gov/articles/PMC3834836/))

>> ○ Motif analysis: What % of peaks contain the TF motif, and does the motif tend to occur in the middle of the peak? Not expected for all peaks, because a TF may bind as part of a protein complex or a heterodimer.

>> ○ Fragment length distribution: This refers to the distribution of fragment lengths, such as single nucleosome, dimer, trimer, etc. It is relevant for techniques like CUT&Tag and ATAC-seq.

>> ○ IP enrichment strength: A graph representing the ratio of reads to bin proportions. Tools like deepTools or CHANCE can be used for analysis. This takes advantage of the fact that the peak ratio appears narrowly distributed across the entire window.

>> ○ Strand lag: The actual binding site signal exhibits a lag between signals on the + strand and - strand. Tools like ZINBA and PePR remove artifact signals that do not exhibit strand lag.

> ③ QC metrics for ATAC-seq

>> ○ FastQC: For example, "Per base sequence content" can be used to assess the integration bias of Tn5 transposase.

>> ○ The ataqv package provides 35 QC metrics as follows ([ref](https://pmc.ncbi.nlm.nih.gov/articles/instance/8245295/bin/NIHMS1594346-supplement-Supplementary_Figures_and_Table_S1.pdf)): **fragment length distribution**, % reads that are high-quality and autosomal, % reads properly paired end mapped, % reads that aligned to autosomes that were duplicates, short-to-mononucleosomal-ratio, **TSS enrichment**, duplicate fraction in peaks, duplicate fraction outside of peaks, peak duplicate ratio, cumulative fraction of high-quality autosomal reads in peaks, cumulative fraction of the genome that falls within peaks, distribution of mapping qualities, number of total reads, % alignments marked secondary, % alignments marked supplementary, % alignments marked as duplicates, mean mapping quality, median mapping quality, % reads unmapped, % reads with an unmapped mate, % QC-fail reads,% unpaired reads, % reads with mapping quality 0, % reads that paired and mapped but in RF orientation, % reads that paired and mapped but in FF orientation, % reads that paired and mapped but in RR orientation, % reads that paired and mapped but on separate chromosomes, % reads that paired and mapped but too far from mate, % reads that paired and mapped but not properly, % reads that aligned to autosomes, % reads that aligned to mitochondria, % reads that aligned to mitochondria that were duplicate, number of peaks called, fragment length distribution distance, max fraction of reads from a single autosome

> ④ **Method 1.** Other datasets: 10x Genomics, GEO, ZENODO, etc.

> ⑤ **Method 2.** FastQC: Requires Fastq files as input.

>> ○ **2-1.** [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/download.html#fastqc) and multiQC: Most popular 

>>> ○ Base pair quality of reads

>>> ○ Adaptor sequences in reads 

>>> ○ PCR duplicates 

>>> ○ Overrepresented sequences 

>>> ○ GC distribution for each sample 

>> ○ **2-2.** QoRTs ([ref1](https://pubmed.ncbi.nlm.nih.gov/26187896/), [ref2](https://github.com/hartleys/QoRTs)): Very good

>>> ○ RNA degradation: Distribution of reads 5' → 3'

>>> ○ Strandedness check 

>>> ○ GC bias

>> ○ **2-3.** [RNASeQC](https://pmc.ncbi.nlm.nih.gov/articles/PMC3356847/): Decent

>> ○ **2-4.** [RSeQC](https://rseqc.sourceforge.net/): Used to have major bugs 

>> ○ **2-5.** Use [conda Fastqc](https://anaconda.org/bioconda/fastqc) command (Linux)

>> ○ **2-6.** Download [SRA](https://github.com/ncbi/sra-tools/wiki/01.-Downloading-SRA-Toolkit) (Sequence Reads Archive) Toolkit and use fastqc command 

>> ○ Below is an example of generated files.

<br>

```python
sudo apt install fastqc
cd sratoolkit.3.0.5-ubuntu64/
cd bin
fastqc DRR016938.fastq
```

<br>

>> ○ [Example file](https://blog.kakaocdn.net/dn/o8SJ5/btrZg87gc3v/Gtc3ZDwWnJ5BqBcb2zW7tK/DRR016938_fastqc.html?attach=1&knm=tfile.html)

<br>

> ⑥ **Method 3.** Trimmomatic: Takes Fastq files as input.

> ⑦ **Method 4.** FASTX-Toolkit: Takes Fastq files as input.

> ⑧ **Method 5.** QC after mapping: Takes SAM or BAM files as input.

>> ○ QC metric 

>>> ○ % uniquely mapped reads

>>> ○ % reads mapping to exons

>>> ○ Complexity, i.e. x% of read counts being taken up by y% of genes

>>> ○ Consistency across samples 

>>> ○ Sample swap: Match Y chromosome, Xist, genotype (e.g., SNP) with metada. 

>> ○ **5-1.** Qplot

>> ○ **5-2.** Samtools: 

> ⑨ **Method 6.** SnakeMake: Integrated pipeline with QC functionality

>> ○ `Snakefile`**:** A Snakemake script based on Python. The filename itself is Snakefile.

<br>

```python
# Snakefile

# Define the result file
rule all:
    input:
        "results/processed_data.tsv"

# Data processing rule
rule process_data:
    input:
        "data/raw_data.tsv"
    output:
        "results/processed_data.tsv"
    shell:
        """
        cat {input} | awk -F'\t' '{{print $1, $2, $3}}' > {output}
        """
```

<br>

>> ○ `config.yaml` (optional): Configuration for the Snakemake workflow ([ref](https://jb243.github.io/pages/2069))

>> ○ `requirements.txt` (optional): Package dependencies

>> ○ Input file

>> ○ Output file

> ⑩ **Method 7.** QuASAR-QC: Applicable for Hi-C data.

> ⑪ [Trouble-shooting](https://jb243.github.io/pages/2337)

⑶ **Type 2:** Comparison or reproducibility metrics between samples: Used for internal validity assessment

> ① **Purpose 1:** Evaluate sample quality by examining ranks of two correlated variables within a single sample

>> ○ Example: Investigate alignment of expression levels of two known similar genes

>> ○ Example: Examine if two genes known to be similar appear in the same cluster

> ② **Purpose 2:** Often used to examine correspondence between pairs of samples

> ③ **Purpose 3:** Investigate correlation between two variables with different data distribution characteristics

>> ○ Concept somewhat distinct from QC analysis

>> ○ Example: Correlation coefficient between gene A expression in scRNA-seq and A expression in ST (Spatial Transcriptomics)

> ④ **Method 1.** Pearson correlation coefficient

>> ○ Definition: For standard deviations σx and σy of X and Y,

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/44ec0d45-eaff-472d-8327-91de557387c8)

<br>

>> ○ Features

>>> ○ Correlation between two variables measured on interval or ratio scales  

>>> ○ Focused on continuous variables  

>>> ○ Assumption of normality  

>>> ○ Widely used in most cases

>> ○ Calculation in [RStudio](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r#:~:text=Compute%20correlation%20in%20R-,R%20functions,-Correlation%20coefficient%20can)

>>> ○ `cor(x, y)`

>>> ○ `cor(x, y, method = "pearson")`

>>> ○ `cor.test(x, y)`

>>> ○ `cor.test(x, y, method = "pearson")`

> ⑤ **Method 2.** Spearman correlation coefficient

>> ○ Definition: Defined for x' = rank(x) and y' = rank(x)

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/9898405b-6007-41b0-bf0a-2bf458cd229a)

<br>

>> ○ Features

>>> ○ A method for measuring the correlation between two variables on an ordinal scale  

>>> ○ A non-parametric approach for ordinal variables  

>>> ○ Advantageous for data with many zeros  

>>> ○ Sensitive to deviations or errors in the data  

>>> ○ Yields higher values compared to Kendall's correlation coefficient  

>> ○ Useful formula

<br>

<img width="647" alt="스크린샷 2025-03-18 오후 3 54 55" src="https://github.com/user-attachments/assets/f733b4e2-312e-4c05-8afd-a33cb61d877e" />

<br>

>> ○ Calculation in [RStudio](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r#:~:text=Compute%20correlation%20in%20R-,R%20functions,-Correlation%20coefficient%20can)

>>> ○ `cor(x, y, method = "spearman")`

>>> ○ `cor.test(x, y, method = "spearman")`

> ⑥ **Method 3.** Kendall correlation coefficient

>> ○ Definition: Defined using concordant and discordant pairs

>> ○ Features

>>> ○ A method for measuring the correlation between two variables on an ordinal scale  

>>> ○ A non-parametric approach for ordinal variables  

>>> ○ Suitable for data with many zeros  

>>> ○ Useful for small sample sizes or when there are many tied ranks in the data  

>> ○ Procedure

>>> ○ **Step 1**: Sort the y values in ascending order based on the x values. Represent each y value as y<sub>i</sub>.  

>>> ○ **Step 2**: For each y<sub>i</sub>, count the number of concordant pairs where y<sub>j</sub> > y<sub>i</sub> (where j > i).  

>>> ○ **Step 3**: For each y<sub>i</sub>, count the number of discordant pairs where y<sub>j</sub> < y<sub>i</sub> (where j > i).  

>>> ○ **Step 4**: Define the correlation coefficient.  

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/0b479e9e-0051-42dd-b78c-df60597ec190)

<br>

>>> ○ n<sub>c</sub>: total number of concordant pairs

>>> ○ n<sub>d</sub>: total number of discordant pairs

>>> ○ n: size of x and y

>> ○ Calculation in [RStudio](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r#:~:text=Compute%20correlation%20in%20R-,R%20functions,-Correlation%20coefficient%20can)

>>> ○ `cor(x, y, method = "kendall")`

>>> ○ `cor.test(x, y, method = "kendall")`

> ⑦ **Method 4.** Q-Q plot between empirical CDFs (Cumulative Distribution Functions)

> ⑧ **Method 5.** Q-Q plot between ordered p-values

> ⑨ For Hi-C sequencing, available methods include HiCRep, GenomeDISCO, HiC-Spector, and QuASAR-Rep.

<br>

<br>

## **3. `QC 3.`** Filtering

⑴ **Type 1:** Filtering during data processing

> ① Removal of inappropriate reads from sequencing data to generate trimmed data

> ② **Example 1:** Adapter Sequence

>> ○ **Issue 1:** Since adapter sequences are artificial, they can cause alignment and variant calling failures or introduce biases.

>> ○ **Issue 2:** Adapter sequences contain identical sequences, leading to biases in coverage analysis and differential gene expression (DEG) analysis.

>> ○ If the fragment is too short, the adapter sequence starts to be read. → In this case, adapter trimming is performed.

>> ○ Long-read sequencing requires more adapter trimming. → Long-read sequencing (PacBio, Oxford Nanopore) is more likely to contain adapter sequences due to its sequencing method, which involves repetitive reading and single-molecule sequencing.

>> ○ To remove adapter sequences, tools such as AdaptorRemoval, Cutadapt, [Trimmomatic](http://www.usadellab.org/cms/?page=trimmomatic), and bbduk.sh are used.

>> ○ Adaptor trimming method: Align each paired-end read and remove the differing parts.

<br>

<img width="398" alt="스크린샷 2025-02-20 오전 12 17 22" src="https://github.com/user-attachments/assets/fa2f858b-cb7a-4a82-8bfc-27a94e9ed25a" />

**Figure 4.** Adaptor trimming method

<br>

⑵ **Type 2:** Filtering in downstream analysis

> ① **2-1.** **Gene filtering:** Excluding genes with low expression to avoid capturing non-informative or unrealistically DEG genes

> ② **2-2.** **Barcode filtering**

>> ○ **Case 1:** Low RNA expression (e.g., poor QC results)

>> ○ **Case 2:** High RNA expression (e.g., contamination due to RNA diffusion)

>> ○ **Case 3.** Doublet removal: scdDblFinder (R-based), hybrid score of scds (R-based), doubletCells of scran (R-based), DoubletFinder 

> ③ Can be implemented using the subset function in the R Seurat pipeline, matrix operations in Python scanpy, etc.

<br>

<br>

## **4. `QC 4.`** Alignment

⑴ Definition: Process of finding the location of a specific sequencing read within a genome or transcriptome

⑵ **Step 1:** Raw data preparation: File extension is `.Fastq`

> ① **Type 1:** Single-end sequencing (SES): Sequencing using one side of the adapter

> ② **Type 2:** Paired-end sequencing (PES): Sequencing using both sides of the adapter

>> ○ [dUTP method](https://jb243.github.io/pages/75#:~:text=%E2%91%A9%20%EC%9D%91%EC%9A%A9%201.-,dUTP%20method,-%3A%20strand%2Dspecific) standard: "_1.fastq" represents first strand (anti-sense), "_2.fastq" represents second strand (sense; original RNA sequence)

>> ○ First, perform sequencing through one adapter (obtain Read1), and then perform sequencing through the opposite adapter (obtain Read2).

>> ○ Read1 and Read2 from the same DNA fragment can be easily matched because they come from the same cluster.

>> ○ Advantages: Higher accuracy (due to comparison between Read1 and Read2), easy extraction of DNA mutations, easy analysis of repetitive sequences, easy mapping between different species.

>> ○ Disadvantages: Higher cost, requires more steps than SES.

> ③ Long-read sequencing

<br>

|               | Short-Read Seq  | Long-Read Seq   |
|---------------|-----------------|-----------------|
| Release Year  | Early 2000s     | Mid 2010s       |
| Average Read Length | 150-300 bp        | 5,000-10,000 bp |
| Accuracy      | 99.9%           | 95-99%          |

**Table 1.** The comparison of short-read seq and long-read seq

<br>

![image](https://github.com/user-attachments/assets/73a7b3b5-c826-49b9-b438-5c61f03815f0)

**Figure 5.** The difference between short-read seq and long-read seq 

<br>

>> ○ There are no sequencing gaps, allowing for the following analyses:

>> ○ **Advantage 1:** [Alternative Splicing Analysis](https://jb243.github.io/pages/2050#12-advanced-1-alternative-splicing-analysis-as-analysis): Identification of alternative splicing events and isoforms is possible.

>> ○ **Advantage 2:** [Copy Number Variation (CNV) Analysis](https://jb243.github.io/pages/2050#13-advanced-2-trajectory-analysis): For example, the number of repeat sequences is critical in Huntington's Disease.

>> ○ **Advantage 3:** Facilitates the integration of epigenetics and transcriptomics.

>> ○ **Type 1:** Pacific Biosciences SMRT (Single Molecule Real-Time) sequencing: The average read length is ~20 kb.

>> ○ **Type 2:** Oxford Nanopore Sequencing: The average read length is ~100 kb.

⑶ **Step 2.** **Preprocessing**: The process of preprocessing raw sequencing data to extract valuable summarized information.

> ① **Process 1.** **alignment**

<br>

![image](https://github.com/user-attachments/assets/afa0c49c-9bbe-4a55-9fce-741b29c9920f)

**Figure 6.** Alignment process

<br>

>> ○ Overview

>>> ○ Definition: The process of determining how two or more sequences align with each other. In other words, pattern matching.  

>>> ○ Motif: A specific pattern or subsequence that appears repeatedly in a given sequence. Motifs are often associated with biological functions.  

>>> ○ **Purpose 1.** To identify the similarity between two sequences for use in processes such as mapping and assembly.  

>>> ○ **Purpose 2.** Variation Identification: Detecting variations such as insertions, deletions, and substitutions.  

>> ○ **Pattern matching:** The concepts of PFM and PWM

>>> ○ **Step 1.** Construction of the PFM (Position Frequency Matrix) 

<br>

<img width="303" alt="스크린샷 2025-01-20 오후 10 27 25" src="https://github.com/user-attachments/assets/21fc1d60-0ecd-40dd-8ee6-74b8d80f7dbf" />

<br>

>>>> ○ x<sub>ij</sub>: The count of nucleotide i occurring at the j-th position.  

>>> ○ **Step 2.** Construction of the PWM (Position Weight Matrix)

<br>

<img width="318" alt="스크린샷 2025-02-04 오전 7 16 27" src="https://github.com/user-attachments/assets/1faf041e-7831-4d37-957c-1660022278c9" />

<br>

>>>> ○ PWM is the relative entropy or the Kullback-Leibler divergence of the PFM. 

>>>> ○ p<sub>i</sub>: Pseudocount or Laplace estimator (e.g., 0.25).  

>>>> ○ q<sub>i</sub>: Expected or background probability of observing nucleotide \( i \) (a priori) (e.g., 0.25).  

>>>> ○ p<sub>i</sub> and q<sub>i</sub> are determined based on [information theory](https://jb243.github.io/pages/2145).

>>> ○ **Step 3.** Assign scores to each k-mer using the PWM.

<br>

<img width="507" alt="스크린샷 2025-01-20 오후 10 29 01" src="https://github.com/user-attachments/assets/ba7e7793-a5b1-4366-a559-9135a4272fa7" />

<br>

>> ○ **Pattern matching:** Gibbs sampling

>>> ○ **Step 1:** Initialization

>>> ○ **1-1.** Randomly select k-mers, i.e., motifs, from each of the N sequences.

>>> ○ **1-2.** Calculate the frequency of A, C, G, T nucleotides at each position.

>>> ○ **1-3.** Consider all remaining sequences that are not selected as motifs to be the background.

>>> ○ **1-4.** Construct the initial PWM.

<br>

![image](https://blog.kakaocdn.net/dn/cqdNpb/btsLYrEk1Rn/AAEaxfKHdOJEcjIMjEUDYk/img.gif)

**Figure 7.** Gibbs Sampling initialization

<br>

>>> ○ **Step 2:** Iteration

>>>> ○ **2-1.** Randomly select one of the N sequences.

>>>> ○ **2-2.** Construct a PWM using all sequences except the one selected.

>>>> ○ **2-3.** Calculate the score distribution by considering all possible motifs in the selected sequence.

>>>> ○ **2-4.** Probabilistically determine a new motif based on the score distribution.

>>>> ○ **2-5.** Repeat steps 2-1 to 2-4 until reaching the maximum number of iterations or until the information content does not change significantly.

<br>

![image](https://blog.kakaocdn.net/dn/cqdNpb/btsLYrEk1Rn/AAEaxfKHdOJEcjIMjEUDYk/img.gif)

**Figure 8.** Gibbs Sampling iteration

<br>

>> ○ **Pattern matching**: Sequence Logo  

>>> ○ A graphical representation of an amino acid or nucleic acid multiple sequence alignment.  

>>> ○ Developed by Tom Schneider and Mike Stephens.  

>>> ○ The y-axis represents information content, as defined in [information theory](https://jb243.github.io/pages/2145).

>>> ○ **Example 1**: When all nucleotide sequences (A, T, G, C) have the same frequency: Maximum entropy = 2. Actual entropy = 2. Information content = 0  

>>> ○ **Example 2**: When only one nucleotide is present: Maximum entropy = 2. Actual entropy = 0. Information content = 2  

>>> ○ **Example 3**: When two nucleotides have the same frequency: Maximum entropy = 2. Actual entropy = 1. Information content = 1  

>> ○ **Pattern matching, Compression:** **BWT**(Burrows-Wheeler transform)

>>> ○ History: Centered around David Wheeler  

>>>> ○ First to earn a Ph.D. in Computer Science: 1951, University of Cambridge.

>>>> ○ First to invent a programming language.

>>>> ○ Invented the concept of functions in computer programming together with Maurice Wilkes and Stanley Gill.

>>>> ○ Discovered BWT while working as a consultant at Bell Labs in the early 1980s.

>>>> ○ Published BWT with Michael Burrows ten years later.

>>> ○ **Step 1.** When the input string is `mississippi`, append `$` at the end to generate the matrix of all cyclic rotations.  

>>> ○ **Step 2.** Consider `$` as the first character and sort the matrix in alphabetical order to obtain the BWT matrix.  

>>>> ○ In the figure below, `i` is called the SA index, and due to **Feature 3**, it must be stored together.

<br>

<img width="437" alt="스크린샷 2025-02-02 오후 4 43 26" src="https://github.com/user-attachments/assets/cb3979bc-8733-430d-8803-793c45a7a1a2" />

**Figure 9.** How to calculate BWT matrix

<br>

>>> ○ **Step 3.** Apply run-length encoding to the last column of the BWT matrix to obtain the BWT transformation. 

>>>> ○ Last column of the BWT matrix: `ipssm$pissii`  

>>>> ○ Run-length encoding: `ipssm$piissi` or `ip2sm$pi2s2i`  

>>> ○ **Feature 1.** It tends to organize a string that contains repeats into runs of consecutive characters. An efficient compression technique.

>>>> ○ When constructing the BWT matrix, sorting in alphabetical order allows repetitive sequences to be easily grouped by the same alphabet.  

>>>> ○ Using this method, even the human genome, which contains many repetitive sequences, can be compressed to approximately 750 MB.

>>> ○ **Feature 2.** The BWT is invertible i.e. given the BWT of a string you can recover the original string without any additional information.

>>>> ○ If the BWT transformation is `ippssm$piissi`, the first column of the BWT matrix becomes `$iiiimppssss`, which is the alphabetically sorted sequence of the BWT transformation. 

>>>> ○ The end of the input string is naturally `$`, and by looking at the first row of the BWT matrix, we can determine that the input string ends with `i$`.

>>>> ○ In the BWT matrix, the row starting with `i$` is easily identified as the second row, which is the first row that starts with `i`.

>>>> ○ Following this method, we can identify the **LF (last-first) property**, which allows us to reconstruct the original input string. 

>>>> ○ **LF property**: For a given character, the k-th occurrence in the first column of the BWT matrix corresponds to the k-th occurrence in the last column.

>>> ○ **Feature 3.** Fast pattern matching with BWT: Assume the pattern is `sis`.

>>>> ○ If the BWT transformation is `ippssm$piissi`, the first column of the BWT matrix becomes `$iiiimppssss`, which is the alphabetically sorted sequence of the BWT transformation. 

>>>> ○ To search for <code><u>si</u>s</code> (first two letters `si`), find rows in the BWT matrix where the last column is `s` and the first column is `i`: SA index = 8, 5.

>>>> ○ To search for <code>s<u>is</u></code> (last two letters `is`), find rows in the BWT matrix where the last column is `i` and the first column is `s`: SA index = 6, 3.

>>>> ○ **Method 1.** According to the LF property, for `i` to be common, the corresponding SA index values must be 5 and 6.

>>>> ○ **Method 2.** The SA index values must differ by exactly 1, meaning they should be 5 and 6.

>>>> ○ **Method 3.** Execute the following algorithm concerning the number of letters that appear alphabetically before it, `count`, and the frequency of that letter, `occur`. If multiple rows are output, it means multiple matches were found.

<br>

```python
def BWT(string):
    string += '\n'    
    t = [string[i:] + string[:i] for i in range(len(string))]
    t.sort()    
    bwt_string = ''.join([l[-1] for l in t])
    return bwt_string

def suffix_array(string):
    string += '\n'
    sa = [index for suffix, index in sorted((string[i:], i) for i in range(len(string)))]    
    return sa

def cal_count(string):
    mydict = {}
    for char in string:
        mydict[char] = 0
    for char in string:
        for key in mydict.keys():
            if key > char:            
                mydict[key] += 1
    return mydict

def cal_occur(bwt_string):
    mydict = {}
    flags = {}
    for char in bwt_string:
        mydict[char] = []
        flags[char] = 0
    for char in bwt_string:
        for key in mydict.keys():
            if key == char:
                flags[key] += 1
                mydict[key].append(flags[key])
            else:
                mydict[key].append(flags[key])
    return mydict

def update_range(lower, upper, count, occur, a):
    if lower == 0:
        lower_new = count[a] + 0 + 1
    else:
        lower_new = count[a] + occur[a][lower-1] + 1
    upper_new = count[a] + occur[a][upper]
    return lower_new, upper_new

def find_match(query, reference):
  def reverse(s):
    return s[::-1]

  count = cal_count(reference)
  occur = cal_occur(BWT(reference))

  lower = 0
  upper = len(BWT(reference))-1
  for char in reverse(query):
     if lower > upper: 
       break #no matching
     lower, upper = update_range(lower, upper, count, occur, char)
  sa = suffix_array(reference)
  matched_positions = sa[lower:upper+1]
  
  return sorted(matched_positions)

'''
reference = mississippi
bwt_reference = 'ipssm$pissii'
query = 'sis'
count: {'i': 0, 'm': 3 , 'p': 4, 's': 6 }
occur: {'$': [0,0,0,0,0,1,1,1,1,1,1,1],
        'i': [1,1,1,1,1,1,1,2,2,2,3,4],
        'm': [0,0,0,0,1,1,1,1,1,1,1,1],
        'p': [0,1,1,1,1,1,2,2,2,2,2,2],
        's': [0,0,1,2,2,2,2,2,3,4,4,4]}
find_match('sis', 'mississippi')
# [3]
'''
```

<br>

>>>> ○ Since `sis` corresponds to SA index 5, the matching pattern in `mississippi` is found from "(5-1) to (5-1) + (length-1)".

>> ○ **Type 1:** BLAST, BLAT: Released in 1997 and 2002, respectively. Based on k-mer hashing.

>> ○ **Type 2.** Alignment for bulk RNA-seq

>>> ○ **2-1.** [STAR](https://github.com/alexdobin/STAR) (Spliced Transcripts Alignment to a Reference): Most commonly used alignment tool. ([ref](https://hbctraining.github.io/Intro-to-rnaseq-hpc-O2/lessons/03_alignment.html)). Uses suffix arrays. Fast but can be memory intensive. 

>>>> ○ `--genomeDir`: Directory containing the genome index files. If there are no files, run `--runMode genomeGenerate` first.

>>>> ○ `--outFilterMismatchNmax`: Maximum number of mismatches per pair.

>>>> ○ `--outFilterMultimapNmax`: Number of allowed multiple alignments per read.

>>>> ○ `--runThreadN`: Number of threads.

<br>

```python
### STEP 1. Installation
# Method 1 - reference : https://github.com/alexdobin/STAR 
wget https://github.com/alexdobin/STAR/archive/2.7.10b.tar.gz
tar -xzf 2.7.10b.tar.gz
cd STAR-2.7.10b
cd source
make STAR

# Method 2 
sudo apt install rna-star


### STEP 2. STAR genomeGenerate
STAR --runMode genomeGenerate \
     --runThreadN NumberOfThreads \
     --genomeDir /path/to/your/GenomeDir \
     --genomeFastaFiles /path/to/combined_genome.fa \
     --sjdbGTFfile /path/to/combined_genome.gtf 


### STEP 3. STAR run
STAR --genomeDir /path/to/your/GenomeDir \
     --readFilesIn /path/to/your/read1.fastq /path/to/your/read2.fastq \
		 --readFilesCommand zcat \
     --runThreadN NumberOfThreads \
     --outFileNamePrefix /path/to/your/outputPrefix \
     --outSAMtype BAM SortedByCoordinate

# Example     
STAR --genomeDir ./reference --readFilesIn read1.fastq read2.fastq --runThreadN 4 --outFileNamePrefix ./SaveDir --readFilesCommand zcat --outSAMtype BAM SortedByCoordinate
```

<br>

>>> ○ **2-2.** HISAT, [HISAT2](https://ccb.jhu.edu/software/hisat2/index.shtml): Designed and implemented the first GFM (graph FM index) based on the BWT extension of a graph. It succeeds TopHat and performs genetic variation-aware alignment.

>>>> ○ HISAT-3N: Used for sequencing techniques that deal with nucleotide conversion, e.g. C to T in bisulfite-seq.

>>> ○ **2-3.** Bowtie, [Bowtie2](https://bowtie-bio.sourceforge.net/bowtie2/index.shtml): Uses Burrows Wheeler Transform (BWT) that utilizes efficient compression technique.

<br>

```python
## STEP 1. install

# Debian (e.g., Ubuntu)
sudo apt-get update
sudo apt-get install bowtie2

# Red Hat (e.g., Fedora, CentOS)
sudo yum install bowtie2

# Conda
conda install -c bioconda bowtie2

# macOS 
brew install bowtie2


## STEP 2. Genome Generation
bowtie2-build hg38.fasta human_reference
```

<br>

>>> ○ **2-4.** Tophat, Tophat2: Uses Burrows Wheeler Transform (BWT).

>>> ○ **2-5.** BWA (Burrows-Wheeler Aligner): Uses Burrows Wheeler Transform (BWT).

>>> ○ **2-6.** MUMmer 

>>>> ○ Performs rapid alignments of DNA and protein.

>>>> ○ Whole genome alignments of prokaryote, fungal, and mammalian genomes. 

>>>> ○ 30 Mb fungal genome takes 1~2 min forward and reverse.

>>>> ○ Can align based on 6-frame translation.

>>>> ○ Use suffix tree to perform the alignments. 

>>> ○ **2-7.** CLC

>>> ○ **2-8.** ContextMap2 

>>> ○ **2-9.** CRAC 

>>> ○ **2-10.** GSNAP 

>>> ○ **2-11.** MapSplice2

>>> ○ **2-12.** Novoalign 

>>> ○ **2-13.** OLego 

>>> ○ **2-14.** RUM 

>>> ○ **2-15.** SOAPsplice 

>>> ○ **2-16.** Subread 

>>> ○ **2-17.** SOAP, SOAP2: Uses Burrows Wheeler Transform (BWT).

>>> ○ **2-18.** mr/mrsFast 

>>> ○ **2-19.** Eland

>>> ○ **2-20.** Bfast 

>>> ○ **2-21.** BarraCUDA 

>>> ○ **2-22.** CASHx

>>> ○ **2-23.** Mosiak 

>>> ○ **2-24.** Stampy

>>> ○ **2-25.** SHRiMP

>>> ○ **2-26.** SeqMap 

>>> ○ **2-27.** SLIDER 

>>> ○ **2-28.** RMAP 

>>> ○ **2-29.** SSAHA 

>>> ○ **2-30.** [bamnostic](https://bamnostic.readthedocs.io/en/latest/): Operating-system-agnostic. Python-based.

>> ○ **Type 3.** Pseudo-alignment for bulk RNA-seq

>>> ○ Pseudo-alignment simplifies some steps of alignment to handle the time-consuming process more quickly.

>>> ○ Pseudo-alignment is less accurate than alignment but faster.

>>> ○ **3-1.** Kallisto: [paper](https://www.nature.com/articles/nbt.3519), [manual](http://pachterlab.github.io/kallisto/manual.html)

>>> ○ **3-2.** Sleuth: [blogpost](https://liorpachter.wordpress.com/2015/08/17/a-sleuth-for-rna-seq/), [tutorial](https://rawgit.com/pachterlab/sleuth/master/inst/doc/intro.html)

>>> ○ **3-3.** Salmon: [preprint](https://www.biorxiv.org/content/10.1101/021592v1), [manual](https://salmon.readthedocs.io/en/latest/salmon.html). Transcript level 

>> ○ **Type 4.** Alignment and counting for scRNA-seq

>>> ○ **4-1.** [CellRanger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger): Uses STAR alignment.

>> ○ **Type 5.** Alignment and counting for ST data

>>> ○ **5-1.** [SpaceRanger](https://www.10xgenomics.com/support/software/space-ranger/downloads): Limited to Visium. Uses STAR alignment but considers spatial barcoding.

>> ○ **Type 6.** **splice-aware aligner**: Aligner that considers RNA-specific events like splicing during alignment.

> ② **Process 2.** Mapping

>> ○ Definition: Storing sequences in a hash table and using this table to map similar sections between different sequences.

>> ○ Background: All-vs-all sequence comparison consumes astronomical amounts of time, thus it's necessary to find short, representative hash values for each sequence.

>> ○ General Process:

>>> ○ **Step 1:** Divide the given sequence into several sliding windows.

>>> ○ **Step 2:** Search for all contiguous sequences of k elements within each sliding window.

>>> ○ **Step 3:** Among the k contiguous sequences, the lexicographically smallest sequence is the minimizer for that window.

>>> ○ **Step 4:** Apply a quaternary number system to the minimizer (i.e., A = 0, C = 1, T = 2, G = 3) to translate the minimizer into a specific value.

>>> ○ **Step 5:** Apply a hash function to the minimizer to generate a hash value, aiming to alleviate base distribution asymmetry and increase database efficiency.

>>> ○ **Step 6:** Store each minimizer from every window in the corresponding element of the hash table based on its hash value.

>>> ○ **Step 7:** Generate a set of minimizers from the query sequence (the sequence of interest).

>>> ○ **Step 8:** Generate a set of minimizers from the target sequence (the reference sequence).

>>> ○ **Step 9:** Search for minimizer hits: compare the minimizer sets of the query and target sequences to explore similar sections between the two sequences.

>>> ○ Note on Hash Function: The hash function does not necessarily need to be reversible, but [hash collision pairs](https://jb243.github.io/pages/875) should not be easily discovered.

>>> ○ Advantages of the Mapping Process: Speeds up comparisons between different sequences and ensures the pipeline operates robustly even in the presence of noise or many [SNPs](https://jb243.github.io/pages/77).

>> ○ **Type 1:** [BLASR](http://www.ncbi.nlm.nih.gov/pubmed/22988817)

>> ○ **Type 2.** [DALIGNER](https://publications.mpi-cbg.de/Myers_2014_6106.pdf)

>> ○ **Type 3:** [MHAP](http://www.ncbi.nlm.nih.gov/pubmed/26006009)

>> ○ **Type 4:** [GraphMap](http://%20http//dx.doi.org/10.1101/020719)

>> ○ **Type 5:** [minimap](https://academic.oup.com/bioinformatics/article/32/14/2103/1742895), minimap2 (mapping algorithms designed for long-read sequencing)

> ③ **Process 3:** Error-Correction

>> ○ Definition: Correcting errors from the sequencing process. 0.2% - 0.5% for Illumina sequencing or higher in long read sequencing.

>> ○ Requirement: A specific k-mer in the given sequence has a low frequency, a substitute k-mer with a close Hamming distance exists, and replacing it with the substitute k-mer does not generate any newly defined k-mers regardless of how the segment is defined. In this case, the substitution is applied.

>> ○ Often included within the assembly process.

>> ○ **Type 1:** [pbdagcon](https://github.com/PacificBiosciences/pbdagcon)

>> ○ **Type 2:** [falcon_sense](https://github.com/PacificBiosciences/falcon)

>> ○ **Type 3:** [nanocorrect](http://www.ncbi.nlm.nih.gov/pubmed/26076426)

> ④ **Process 4.** **assembly**

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/e2648d80-0ef4-464d-945b-c511aff823c4)

**Figure 10.** Assembly process

<br>

>> ○ **Definition:** ○ Definition: The process of reconstructing short DNA/RNA fragments, which are partially obtained due to technical limitations, into a graph aligned to the reference genome.

>> ○ **Class 1.** Ab initio Assembly

>>> ○ Requires a reference genome.

>>> ○ Requires minimal computing resources.

>>> ○ The completeness of the genome and the performance of the aligner affect the accuracy of the assembly.

>>> ○ **Two-pass alignment**: A method for effectively detecting novel splice junctions in ab initio assembly.  

>>>> ○ **Step 1.** First pass: Align RNA-seq reads to the reference genome.  

>>>> ○ **Step 2.** Update splice junction information: Collect novel splice junctions detected in the first pass and update the reference.  

>>>> ○ **Step 3.** Second pass: Realign reads using the updated splice junction information.

>>> ○ STAR two-pass alignment 

>>>> ○ Single sample: Use `--twopassMode Basic`.

>>>> ○ Multiple samples: Run STAR normally → Collect `SJ.out.tab` files for each sample → Re-run STAR with `--sjdbFileChrStartEnd sj1.tab sj2.tab ...`.

>>>> ○ **Additional parameter 1.** `alignIntronMin`: Minimum intron size  

>>>> ○ **Additional parameter 2.** `alignSJoverhangMin`: Minimum number of nucleotides required to recognize novel splice junctions (i.e., the minimum number of nucleotides that must be aligned between two exons for accurate splice junction mapping)  

>>>> ○ **Additional parameter 3.** `alignSJDBoverhangMin`: Minimum number of nucleotides required to recognize known splice junctions (i.e., the minimum number of nucleotides that must be aligned between two exons for accurate splice junction mapping)

>> ○ **Class 2.** De novo Assembly

>>> ○ Does not require a reference genome, eliminating reference bias.

>>> ○ Constructs contigs by connecting overlapping reads in a graph structure; contigs are later compared with the reference for naming in the post-assembly stage.

>>> ○ Requires substantial computing resources: ~1G RAM for ~1M 76bp reads.

>>> ○ Can identify chromosomal aberrations or novel isoforms that are not present in the reference genome.

>>> ○ **Step 1.** Contig: Contiguous sequence constructed by joining reads that have overlapping sequence information.

<br>

<img width="519" alt="스크린샷 2025-01-26 오후 7 18 09" src="https://github.com/user-attachments/assets/d927bf80-d642-44f3-831a-bdbac9fee7f6" />

**Figure 11.** Contig

<br>

>>>> ○ E has identity identity at only one end, so only leads to inclusion of 3 nodes.

>>>> ○ Path ABCD includes 4 nodes and is chosen as better path. 

>>> ○ **Step 2.** Create an assembly graph

>>> ○ **2-1.** de Bruijn graph

<br>

<img width="403" alt="스크린샷 2025-01-26 오후 7 18 32" src="https://github.com/user-attachments/assets/c05d5ec4-49f2-4e37-b7d5-859d8c2b3a60" />

**Figure 12.** de Brujin graph

<br>

>>>> ○ Using k-mers: The graph is constructed such that each node overlaps with the previous node by k-1 bases.

>>>> ○ Problems arise when repetitive sequences are longer than the read length: There are multiple possible ways to connect the left and right sides of the repetitive sequences.

>>>> ○ In cases with repetitive sequences, large library insert size and mate-pair sequencing can be helpful.

>>>> ○ In a de Bruijn graph, both strands need to be considered: Therefore, reverse complements must also be taken into account.

>>>> ○ **Advantage 1:** Increased efficiency for computing overlaps between sequences 

>>>> ○ **Advantage 2:** Straightforward collapsing of assembly paths around low k-mer count repeats 

>>>> ○ **Advantage 3:** Trimming of low k-mer count sequences that terminate

>>> ○ **2-2.** [Needleman-Wunsch graph](https://pubmed.ncbi.nlm.nih.gov/5420325/): **Pairwise alignment**

>>>> ○ **Stage 1.** Construct global alignment graph

<br>

![image](https://blog.kakaocdn.net/dn/dyp1D6/btsMLsvSaOZ/0IyXpW9UrD4XKNvJrkssW0/img.gif)

**Figure 13.** Construction of Needleman-Wunsch graph

<br>

>>>> ○ **Stage 2.** Optimal Graph Path Search: Dynamic Programming. Traceback along high values at the final node (i.e., T-T).

<br>

<img width="578" alt="스크린샷 2025-03-14 오전 10 59 48" src="https://github.com/user-attachments/assets/84a145a7-8b1e-4d2f-a74f-c58d3f509e75" />

**Figure 14.** Optimal Graph Path Search in a Needleman-Wunsch Graph

<br>

>>>> ○ Pseudocode

<br>

<img width="242" alt="스크린샷 2025-03-18 오전 10 29 57" src="https://github.com/user-attachments/assets/341810e2-9107-4304-a497-4881084355f3" />

<img width="1053" alt="스크린샷 2025-04-05 오후 5 18 22" src="https://github.com/user-attachments/assets/2a8365c7-bdcc-433e-9c5d-c2e45e8058e7" />

<br>

>>> ○ **2-3.** [Smith-Waterman graph](https://pubmed.ncbi.nlm.nih.gov/7265238/): **Pairwise alignment**

>>>> ○ **Stage 1.** Construct a local alignment graph: Assign zero to negative values in the global alignment graph.  

>>>> ○ **Stage 2.** Optimal graph path search: Dynamic programming. Traceback from the node with the maximum value.

<br>

![image](https://blog.kakaocdn.net/dn/tWI2B/btsMLJjReMZ/z1yZaRbEKvpatNIMwpHiTk/img.gif)

**Figure 15.** Smith-Waterman graph

<br>

>>>> ○ Pseudocode

<br>

<img width="242" alt="스크린샷 2025-03-18 오전 10 29 57" src="https://github.com/user-attachments/assets/341810e2-9107-4304-a497-4881084355f3" />

<img width="835" alt="스크린샷 2025-03-18 오전 10 29 39" src="https://github.com/user-attachments/assets/b2604d09-b1f0-4a8e-85ef-d521c2cfabfa" />

<br>

>>>> ○ Example: If a gap occurs, it might be necessary to reconsider it. It feels like the sequence assignment order should be slightly delayed.

<br>

<img width="224" alt="스크린샷 2025-03-18 오후 3 10 05" src="https://github.com/user-attachments/assets/9d800ea8-f45d-47ce-b6de-c7cac5b403d0" />

**Figure 16.** Example of Smith-Waterman graph

<br>

>>> ○ **2-4.** Progressive alignment: **MSA**(multiple sequence alignment)

>>>> ○ Uses a tree-based strategy where similar sequences are aligned initially, and then additional sequences are aligned to those alignments.

>>>> ○ The order you align sequences in a progressive multiple sequence alignment is important.

>>> ○ **2-5.** Iterative alignment: **MSA**(multiple sequence alignment)

>>>> ○ Similar to progressive, however further realigns initial sequences to current full MSA.

>>>> ○ Reduces dependence on initial alignments.

>>> ○ **2-6.** Hidden Markov model: **MSA**(multiple sequence alignment)

>>>> ○ Can leverage profile HMMs to train and iteratively align sequences. 

>>> ○ **2-7.**  UPGMA(unweighted pair group method with arithmetic mean): **MSA**(multiple sequence alignment)

>>>> ○ 1<sup>st</sup>. Calculate pairwise edit distances between all possible pairs of sequences by aligning them together (Smith-Waterman / Needleman-Wunsch)

>>>>> ○ Edit distance: [Hamming distance](https://jb243.github.io/pages/879), [Levenshtein distance](https://jb243.github.io/pages/879)

>>>> ○ 2<sup>nd</sup>. Create a hierarchical order using one of agglomerative hierarchical clusterings, [UPGMA](https://jb243.github.io/pages/2150). 

<br>

![image](https://github.com/user-attachments/assets/575d08cd-e3fa-4d2f-b714-b7e1294bec20)

<br>

>>>> ○ 3<sup>rd</sup>. Progressive align sequences (and alignments) together by traversing up the tree.

>>> ○ **Step 3.** Graph traverse: [Search algorithm](https://jb243.github.io/pages/904) 

>>>> ○ [Eulerian path](https://www.pnas.org/doi/10.1073/pnas.171285098): A path in a graph that visits each edge exactly once. If there are repeating sequences, two nodes can be connected by more than one edge. Traversing the entire graph is not needed. Both Breadth-First Search (BFS) and Depth-First Search (DFS) are possible.

>>>> ○ [Euler-SR](https://pmc.ncbi.nlm.nih.gov/articles/PMC2652199/) 

>>>> ○ [Velvet](https://pmc.ncbi.nlm.nih.gov/articles/PMC2336801/): Fast for small to medium genomes, ~50 Mb or less. The "Tour Bus" algorithm, which utilizes [Dijkstra algorithm](https://jb243.github.io/pages/61), in Velvet removes 'bubbles' in graph using coverage, sequence identity, and length thresholds.

>>>> ○ Abyss: Fast for small to medium genomes, ~50 Mb or less.

>>>> ○ SSAKE (Warren et al. 2007): short-read assembler 

>>>> ○ VCAKE (Jeck et al. 2007): short-read assembler 

>>>> ○ miniasm: Long-read seq assembler. Uses the distances in nucleotide sequences from multiple mappings to form corresponding edges.

<br>

<img width="536" alt="스크린샷 2025-01-30 오후 10 55 38" src="https://github.com/user-attachments/assets/667a8b97-78c7-4b06-8838-24bd59a89409" />

<br>

>>>>> ○ In this case, it can be said that the ABCD of the query sequence corresponds to the ABCD of target sequence 3.

>>> ○ **Step 4.** Clean the assembly graph: If the corresponding sections are P → Q → R, it can be simplified to P → R.

>>> ○ **Step 5.** Generate unitigs.

>>> ○ During this process, information such as position and mismatch is generated.

>>> ○ The result of the assembly process generates a `.bam` file.

>> ○ **Class 3.** Combined strategy 

>>> ○ If reference genome is of poor quality or from distantly related species. 

>> ○ **Type 1.** [wgs-assembler](http://www.ncbi.nlm.nih.gov/pubmed/10731133)

>> ○ **Type 2.** [Falcon](http://bit.ly/pbfcasm)

>> ○ **Type 3.** [ra-integrate](http://bit.ly/raitgasm)

>> ○ **Type 4.** [miniasm](https://academic.oup.com/bioinformatics/article/32/14/2103/1742895) (an assembly algorithm for long-read sequencing)

>> ○ **Type 5.** Velvet: Used to know the coordinate and feature of the breakpoint junction sequence.

<br>

| Assembler       | De novo? | Parallelism | Support for paired-end reads? | Support for stranded reads? | Support for multiple insert sizes? | Outputs transcript counts? |
|----------------|---------|-------------|--------------------------------|-----------------------------|------------------------------------|----------------------------|
| G-Mo.R-Se      | No      | None        | No                             | No                          | No                                 | No                         |
| Cufflinks      | No      | MP          | Yes                            | Yes                         | Yes                                | Yes                        |
| Scripture      | No      | None        | Yes                            | Yes                         | Yes                                | Yes                        |
| ERANGE         | No      | None        | Yes                            | Yes                         | Yes                                | Yes                        |
| Multiple-k     | Yes     | None        | Yes                            | Yes                         | Yes                                | No                         |
| Rnnotator      | Yes     | MP          | Yes                            | Yes                         | Yes                                | Yes                        |
| Trans-ABySS    | Yes     | MPI         | Yes                            | Yes                         | No                                 | Yes                        |
| Oases          | Yes     | MP          | Yes                            | Yes                         | Yes                                | No                         |
| Trinity        | Yes     | MP          | Yes                            | Yes                         | No                                 | Yes                        |

**Table 2.** Types of RNA-assembly

<br>

> ⑤ **Process 5.** Consensus polish 

>> ○ **Type 1.** [Quiver](https://github.com/PacificBiosciences/GenomicConsensus)

>> ○ **Type 2.** [nanopolish](http://www.ncbi.nlm.nih.gov/pubmed/26076426)

> ⑥ **Application 1.** Reference matching

>> ○ Definition: Process of determining which reference a read comes from when using multiple references of different species.

>> ○ Special algorithms are used to correct errors due to inter-species homology.

>> ○ Typically, multiple `.bam files` mapped to different references are used to find more accurate references for each transcript.

>> ○ This discussion implies that to accurately and comprehensively map RNAs from a given tissue, one should consider one or more optimal combinations of references.

>> ○ **Type 1.** Individual alignment 

>>> ○ **1-1.** Freemuxlet: Demultiplexing cells derived from multiple individuals using SNPs.

>> ○ **Type 2.** Xenograft alignment: Matching references for each transcript using .bam files from graft and host references.

>>> ○ **2-1.** [XenofiltR](https://github.com/NKI-GCF/XenofilteR): Takes .bam files from host and graft references. Generates `.bam` and `.bam.bai files` with only graft reads remaining.

>>> ○ **2-2.** [BAMCMP](https://hpc.nih.gov/apps/bamcmp.html): Separates graft and host reads in xenograft data. Divides into graft-only, host-only, ambiguous, unmapped classes.

>>> ○ **2-3.** [disambiguate](https://github.com/AstraZeneca-NGS/disambiguate)

>>> ○ **2-4.** [Xenomake](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10508769/) : Solely for spatial transcriptomics.

>> ○ **Type 3.** Using multiple references in pseudo-alignment ([ref](https://www.biostars.org/p/389892/))

>>> ○ Simple approach of constructing integrated references like a single species' reference results in lower accuracy.

>> ○ **Type 4.** Microbiome Alignment

>>> ○ Bacterial References: SILVA, RDP (Ribosomal Database Project), Greengenes, RefSeq

>>> ○ Fungal References: UNITE, EUKARYOME

>>> ○ **4-1.** BLAST: Slow but the most accurate

>>> ○ **4-2.** VSEARCH: Rarely used nowadays

>>> ○ **4-3.** MAFFT: For MSA (multiple sequence alignment)

>>> ○ **4-4.** DECIPHER: For MSA (multiple sequence alignment)

>>> ○ **4-5.** [Pathseq](http://software.broadinstitute.org/pathseq/): Performs filtering, alignment, and abundance estimation in mixed human-microbe metagenomics data using GATK (Genome Analysis Toolkit).

>>> ○ **4-6.** [Kraken](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-3-r46)

> ⑦ **Application 2.** Workflow Build 

>> ○ **Type 1.** SnakeMake **:** A tool for creating custom workflows independently.

>> ○ **Type 2.** [SpaceMake](https://academic.oup.com/gigascience/article/doi/10.1093/gigascience/giac064/6646447) : Integrated workflow to process various spatial transcriptomics data.

⑷ **Step 3.** (_optional_) **QC**

> ① [SAMtools](https://academic.oup.com/bioinformatics/article/25/16/2078/204688?login=true): Possible to use SAMtools view. Filtering by flags is possible. ([ref](https://broadinstitute.github.io/picard/explain-flags.html))

⑸ **Step 4.** **sorting:** Sorting BAM files along the alignment axis.

> ① [Picard](http://broadinstitute.github.io/picard/) ([release](https://github.com/broadinstitute/picard/releases), [trouble-
shooting](https://jb243.github.io/pages/2292#:~:text=default%2Djre-,57,-.%20Error%3A%20LinkageError%20occurred))

<br>

```python
# How to install java on Ubuntu/Debian
sudo apt update
sudo apt install default-jdk

java -jar picard.jar SortSam \
      INPUT=input.bam \
      OUTPUT=sorted_output.bam \
      SORT_ORDER=coordinate
```

<br>

> ② [SAMtools](https://academic.oup.com/bioinformatics/article/25/16/2078/204688?login=true)

<br>

```python
# install in Linux
sudo apt update
sudo apt install samtools

# execution of samtools
samtools sort -o sorted_file.bam input_file.bam
```

<br>

> ③ name-sorted: Typically, sorting is done based on the read name.

> ④ coordinate-sorted: For example, the `possorted_genome_bam.bam file` created in SpaceRanger is position-sorted.

⑹ **Step 5.** **marking:** Marking duplicates arising from PCR amplification.

> ① Generally, DNA-seq involves removing duplicates, while RNA-seq does not: In RNA-seq, the same sequence may repeatedly appear not only due to technical duplicates but also due to high expressing transcripts or short genes. Removing these biological duplicates can reduce the dynamic range of the data or decrease statistical power.

> ② [Picard](http://broadinstitute.github.io/picard/) MarkDuplicates

<br>

```python
java -jar picard.jar MarkDuplicates INPUT=sorted_file.bam OUTPUT=marked_duplicates.bam METRICS_FILE=metrics.txt
```

<br>

> ③ [SAMtools](https://academic.oup.com/bioinformatics/article/25/16/2078/204688?login=true) rmdup

<br>

```python
samtools markdup -r -s sorted.bam marked_duplicates.bam
```

<br>

>> ○ `-s`: single-end read. If paired-end read, remove this part.

> ④ Trimmomatic

> ⑤ Trim Galore!  

> ⑥ fastp

⑺ **Step 6.** **indexing :** `.bam.bai file` is generated from `.bam file`.

> ① [SAMtools](https://academic.oup.com/bioinformatics/article/25/16/2078/204688?login=true)

<br>

```python
samtools index marked_duplicates.bam
```

<br>

⑻ **Step 7.** **Count:** Determining which feature (e.g., gene, exon) a read originated from when there is a read.

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/7defebad-e111-4f75-9789-4b129e08522c)

**Figure 17.** Counting process (from HTSeq)

<br>

> ① Algorithms determining whether a read came from gene A or gene B when there is a read.

> ② **Type 1.** HTSeq

>> ○ A tool based on gene overlap.

>> ○ **Most commonly used** counting algorithm.

>> ○ Default is union.

>> ○ Command example:

<br>

```python
# install
pip install HTSeq

htseq-count -f bam -r pos -s no -i gene_id -t exon mouse_sample.bam Mus_musculus.GRCm38.99.gtf > output.count
```

<br>

>>> `○ -f bam`: Specifies that the input file is a `.bam file`.

>>> ○ `-r pos`: Ensures that the feature order in the output file matches the order in the reference.

>>> ○ `-s no`: `-s` indicates whether the sequencing data is strand-specific. `-s no` specifies that the data is not strand-specific, meaning the reads' transcriptional direction (strand) is not considered. For strand-specific data, you should use `-s yes` (forward strand) or `-s reverse` (reverse strand).

>>> ○ `-i gene_id`: Uses the gene_id attribute from the GTF file as the reference for each feature. transcript_id is also possible.

>>> ○ `-t exon`: Specifies feature type. Default is exon.

>>> ○ `Mus_musculus.GRCm38.99.gtf`: Reference name. Can use `.gff` file instead of `.gtf`.

>>> ○ `> output.txt`: Outputs count result to output.txt file.

>> ○ Result example:

>> ○ Simple counting algorithm without assembly process.

>> ○ **Issue 1.** When there are multiple isoforms, shared reads are either consistently counted as +1 or discarded, leading to inaccurate counts.

>> ○ **Issue 2:** Decreased accuracy when counting at the transcript level compared to the gene level

>>> **○** Gene count > Sum of isoform counts that constitute each gene ( **∵** ambiguous reads)

>>> **○** Using genome-aligned data for transcript alignment without separate assembly can be inaccurate

>>> ○ Due to high similarity between transcripts, distinguishing by sequencing technology can be extremely challenging

> ③ **Type 2.** [RSEM](https://github.com/deweylab/RSEM)

>> ○ Utilizes the EM (expectation maximization) technique to accurately predict counts.

>> ○ Isoform quantification is possible.

>> ○ **Step 1:** RSEM installation

<br>

```python
# step 1.
git clone https://github.com/deweylab/RSEM.git

# step 2. 
cd RSEM

# step 3.
make 

# step 4.
make install
```

<br>

>> ○ **Step 2:** Prepare [reference files](https://jb243.github.io/pages/2070)

<br>

```python
rsem-prepare-reference --gtf annotation.gtf genome.fa reference_name
```

<br>

>> ○ **Step 3:** Expression estimation

<br>

```python
# case 1. single-end
rsem-calculate-expression --single-end --alignments -p 4 aligned_reads.sam reference_name sample_output

# case 2. paired-end
rsem-calculate-expression --paired-end --alignments -p 4 aligned_reads.bam reference_name sample_output
```

<br>

> ④ **Type 3.** [StringTie](https://ccb.jhu.edu/software/stringtie/)

<br>

```python
# install
conda install -c bioconda stringtie

# count
stringtie sorted_bam.bam -o output.gtf -G reference.gtf -A gene_abundances.tsv
```

<br>

>> ○ genome-based: (Comment) StringTie's method for transcript-level abundance is not straightforward

>> ○ Includes assembly process.

>> ○ Takes `sorted_bam.bam file` from genome-aligned reads as input, outputs separate `output.gtf file`.

>> ○ Uses novel network flow algorithm

>> ○ Example results

> ⑤ **Type 4.** featureCounts ([install](https://sourceforge.net/projects/subread/))

<br>

```python
./subread-2.0.6-Linux-x86_64/bin/featureCounts -a GRCh38.gtf -o counts.txt possorted_genome_bam.bam
```

<br>

>> ○ Example results

> ⑥ **Type 5.** [Cufflinks](http://cole-trapnell-lab.github.io/cufflinks/) / Cuffdiff 

> ⑦ **Type 6.** Tuxedo: Isoform quantification is possible.

>> ○ **Step 1.** Cufflinks: Assembles transcript per sample and explains observed reads with minimum number of isoforms.

>> ○ **Step 2.** Merge GFT files. 

>> ○ **Step 3.** Cuffquant: Conducts transcript quantification.

> ⑧ **Type 7.** [Hisat2](https://ccb.jhu.edu/software/hisat2/index.shtml): Genome-based

> ⑨ **Type 8.** QoRTs

> ⑩ **Type 9.** [eXpress](https://pachterlab.github.io/eXpress/index.html)

>> ○ Utilizes the EM (expectation maximization) technique. Transcriptome-based.

>> ○ Isoform quantification is possible.

> ⑪ **Type 10.** [bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml): Transcriptome-based

> ⑫ **Type 11.** TIGAR2

>> ○ Bayesian inference for transcript quantification.

>> ○ Isoform quantification is possible.

> ⑬ **Type 12.** SALMON

>> ○ Quasi-mapping, not base-to-base alignment + Isoform quantification 

>> ○ For gene-level analysis, **tximport** is used.  

>> ○ **Step 1.** ab initio or de novo assembly  

>> ○ **Step 2.** Construct a HASH table: Index the positions of distinct k-mers.  

>> ○ **Step 3.** Build a **suffix array**: Annotate the suffixes of k-mers.  

>> ○ **Step 4.** Quasi-mapping

>>> ○ **4-1.** Scan the read from left to right: Scan until a k-mer is found in the hash table. Identify the suffixes of the detected k-mer.  

>>> ○ **4-2.** Identify the MMP (Minimum Mapping Position): Find the longest matching read sequence with exact matches to determine the MMP.  

>>> ○ **4-3.** Identify the NIP (Next In Position) assuming mismatches: Account for sequencing errors or natural variations in the read by skipping one k-mer to identify the NIP. Instead of stopping where the current match is disrupted, search for the next matching k-mer to increase the likelihood of mapping the entire read.  

>>> ○ **4-4.** Repeat steps **4-1** and **4-2** until the end of the read is reached to complete quasi-mapping.  

>> ○ **Step 5.** Quantify transcript abundance using the EM (Expectation-Maximization) algorithm.  

> ⑭ **Type 13.** [Ballgown](https://github.com/alyssafrazee/ballgown) ([ref](https://www.nature.com/articles/nbt.3172)): Provides gene count, transcript count, DEG analysis results, etc.

>> ○ **Step 1:** Prepare `.ctab` files

>>> ○ **Method 1:** TopHat2 + StringTie

>>> ○ **Method 2:** TopHat2 + Cufflinks + Tablemaker

>>> ○ StringTie command example: Generate .ctab files using the -B argument

<br>

```python
stringtie -e -B -p 8 -G ref.gtf -l sample -o output.gtf aligned_reads.bam
```

<br>

>> ○ **Step 2:** Check directory structure

<br>

```python
ballgown/
├── sample1/
│   ├── e_data.ctab
│   ├── e2t.ctab
│   ├── i_data.ctab
│   ├── i2t.ctab
│   ├── t_data.ctab
│   └── output.gtf
├── sample2/
│   ├── e_data.ctab
│   ├── e2t.ctab
│   ├── i_data.ctab
│   ├── i2t.ctab
│   ├── t_data.ctab
│   └── output.gtf
├── sample3/
│   ├── e_data.ctab
│   ├── e2t.ctab
│   ├── i_data.ctab
│   ├── i2t.ctab
│   ├── t_data.ctab
│   └── output.gtf
...
```

<br>

>> ○ **Step 3:** Execute Ballgown: Can be run with R

<br>

```python
library(ballgown)
bg = ballgown(dataDir = "ballgown", samplePattern = "sample", meas = "all")
gene_expression = gexpr(bg)
transcript_expression = texpr(bg, 'all')
```

<br>

>> ○ Example results

> ⑮ **Type 14.** [Pathseq](http://software.broadinstitute.org/pathseq/): Performs filtering, alignment, abundance estimation on mixed metagenomics data of human and microbes  using GATK (Genome Analysis Toolkit).

> ⑯ **Type 15.** [CellRanger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger)

>> ○ scRNA-seq alignment and count 

> ⑰ **Type 16.** [SpaceRanger](https://www.10xgenomics.com/support/software/space-ranger/downloads)

>> ○ ST alignment and count 

>> ○ Limited to Visium. Uses STAR alignment and considers spatial barcoding additionally

⑼ **Step 8.** (_optional_) **Error correction**: It is possible to correct mapping errors during the assembly process.

> ① [pbdagcon](http://bit.ly/pbdagcon) 

> ② [falcon_sense](http://bit.ly/pbfcasm) 

> ③ [nanocorrect](http://www.ncbi.nlm.nih.gov/pubmed/26076426) 

⑽ **Step 9.** (_optional_) **Variant calling**: Can investigate genetic variations like SNPs or indels. Variants are saved as a [VCF file](https://jb243.github.io/pages/2070).

> ① Overview: A typical human genome differs from the reference human genome at 4.1-5 million sites

>> ○ Majority (>99.9%) are SNPs and short indels.

>> ○ Contains 2,100 to 2,500 structural variants affecting ~20 Mb of sequence and comprising (approximately):

>>> ○ 1000 large indels 

>>> ○ 160 copy number variants

>>> ○ 915 Alu insertions, 128 L1 insertions, 51 SVA insertions

>>> ○ 4 numts

>>> ○ 10 inversions 

>> ○ Majority of variants in a single genome are common.

>>> ○ Only 40,000 to 200,000 per genome (1-4%) have a frequency <0.5%.

> ② Pipeline

>> ○ Methods: Read pair mapping, read depth analysis, split read alignment, sequence assembly

<br>

![image](https://github.com/user-attachments/assets/28eb8e6b-a0a5-439d-86cb-141f76a45496)

**Figure 18.** Methods for variant calling

<br>

>> ○ A [BED file](https://jb243.github.io/pages/2070) or [VCF file](https://jb243.github.io/pages/2070) is generated from a [BAM file](https://jb243.github.io/pages/2070).

>> ○ It is followed by the creation of a [BEDgraph file](https://jb243.github.io/pages/2070) (a graph data structure file composed of BED), a [Wiggle file](https://jb243.github.io/pages/2070) (a file comparing with the control group), and a [bigWig file](https://jb243.github.io/pages/2070) (a compressed binary version of the Wiggle file).

> ③ Types

>> ○ GATK (Genome Analysis ToolKit): HaplotypeCaller in GATK is commonly used. Also, there are UnifiedGenotyper and [Mutect2](https://github.com/broadinstitute/gatk/blob/master/docs/mutect/mutect.pdf).

>> ○ Freebayes

>> ○ SAMtools mpileup

>> ○ [CaVEMan](http://cancerit.github.io/CaVEMan/) (Cancer Variants Through Expectation Maximization): Used for somatic substitution calling.

>> ○ [Pindel](http://cancerit.github.io/cgpPindel/): Used for Indel calling.

>> ○ [BRASS](https://github.com/cancerit/BRASS) (BReakpoint AnalySiS): Used for structural variant calling.

>> ○ [MACS](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2008-9-9-r137), [MACS2](https://hbctraining.github.io/Intro-to-ChIPseq/lessons/05_peak_calling_macs.html): Variant calling pipeline for ChIP-seq and ATAC-seq.

>> ○ SPP

>> ○ GWAVA (Genome-Wide Annotation of Variants)  

>> ○ DeepSea: Predicting noncoding variants  

>> ○ DanQ: Quantifying the functionality of DNA sequences using CNNs and RNNs  

>> ○ DeepFun: Predicting regulatory variants using CNNs  

>> ○ DeepC: Predicting 3D genome folding  

>> ○ Akita: Predicting 3D genome folding  

>> ○ Zinba-cat 

>> ○ Pepr 

>> ○ ANNOVAR: Variant annotation (coding / non-coding / chromatin mark)

>> ○ PLINK

>>> ○ LD (Linkage Disequilibrium) Calculation

>>> ○ Genetic Relatedness Calculation: If genetic relatedness exists, genetic independence is compromised, leading to an overestimation of effective size or exaggeration of significance.

>>> ○ Supports various input and output formats (including VCF/dosage imputed data)

>>> ○ Commonly used formats:

>>>> ○ `.bed` (a binary file storing the genotype matrix), `.fam`, `.bim`: All with the same prefix

>>>> ○ `.pgen` (a binary file), `.psam`, `.pvar`  

>>> ○ vcftools

>>>> ○ Designed to handle VCF (Variant Call Format) files generated from sequencing projects.

>>>> ○ Can output to PLINK format.

> ④ **Application 1.** Genotype clustering 

>> ○ GenCall (GenomeStudio from Illumina)

>>> ○ Between-sample model, one marker at a time

>>> ○ Assign genotypes to the nearest cluster

>>> ○ Can customize prior clusters

>> ○ GenoSNP 

>>> ○ Within-sample model, all markers in a sample

>>> ○ Using a variational Bayes EM model

>>> ○ Can work well for rare variant 

>>> ○ Can be parallelized

>> ○ optiCall 

>>> ○ Mixture of between- and within-sample models

>>> ○ EM algorithm to fit mixture of t-distributions

>> ○ zCall 

>>> ○ Post-processing tool

>>> ○ Partitioning the X/Y coordinate according to the mean/variance of homozygote clusters for common variants, then recall the rare variants

⑾ **Step 10.** (_optional_) **_Post-hoc_ ** **transcript-to-gene conversion**: When having count data for transcript IDs, it might be necessary to collapse multiple transcript IDs into one gene ID (e.g., for GO analysis)

> ① Example: GRCh38 (human) GFF file contains the following information

<br>

```python
ID=exon-NR_046018.2-1;Parent=rna-NR_046018.2;Dbxref=GeneID:100287102,GenBank:NR_046018.2,HGNC:HGNC:37102;gbkey=misc_RNA;gene=DDX11L1;product=DEAD/H-box helicase 11 like 1 (pseudogene);pseudo=true;transcript_id=NR_046018.2
```

<br>

> ② Post-conversion methods

>> ○ **Method** **1.** [RefSeq](https://www.ncbi.nlm.nih.gov/refseq/rsg/)

>> ○ **Method** **2.** [UCSC knowngene](https://genome.ucsc.edu/cgi-bin/hgTables)

>> ○ **Method** **3.** [Ensembl](http://asia.ensembl.org/info/data/ftp/index.html): [manual](https://jb243.github.io/pages/2156#:~:text=ensembl_gene_id%EC%99%80%20gene_symbol%20%EA%B0%84%EC%9D%98%20%EB%B3%80%ED%99%98%20%EB%93%B1)

>> ○ **Method** **4.** [GENCODE](https://www.gencodegenes.org/)

>> ○ **Method 5.** Useful functions available in R (for human, [ref](https://support.bioconductor.org/p/106253/#106256))

<br>

```python
library(biomaRt)
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")  
ensembl_transcript_to_gene <- function(transcript_ids){
  # reference : https://support.bioconductor.org/p/106253/#106256

  res <- getBM(attributes = c('ensembl_transcript_id_version', 
                              'ensembl_gene_id', 
                              'external_transcript_name',
                              'external_gene_name'),
               filters = 'ensembl_transcript_id_version', 
               values = transcript_ids,
               mart = mart)

  if(dim(res)[1] == 0){
    return("")
  }	

  return(res[, 'external_gene_name'])
}
```

<br>

<br>

## **5. `QC 5.`** Normalization

⑴ Overview

> ① Definition: Correction for biases where RNA reads do not accurately reflect gene expression due to technical limitations

> ② In essence, correcting systemic batch effects like library size

⑵ **Type 1. library size normalization** (Depth-based normalization)

> ① When comparing different samples, divide each sample by a normalization factor to adjust for the total RNA transcripts count

>> ○ In other words, to compare specific gene expression between samples

>> ○ Sequencing depth, a limitation specific to sequencing machines, can be referred to as library size

> ② **1-1.** **RPM (reads per million mapped reads)** or **CPM (counts per million mapped reads)**

>> ○ Divide each gene count by the total count of the sample and multiply by 10^6

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/07c3ce6b-0359-49d6-8d28-8e207ba7dfa0)

<br>

>> ○ [R code](https://bio-protocol.org/exchange/protocoldetail?id=4462&type=1#:~:text=log2\(-,CPM,-\).): Maintains equal library size, doesn't use methods like TMM

<br>

```python
library(edgeR)
raw_counts_matrix = ?
group = ?
DEGL <- DGEList(counts=raw_counts_matrix, group=group)

# Keep the raw library size
DEGL_cpm <- calcNormFactors(DEGL, method = "none")

# Calculate the cpm
cpm <- cpm(DEGL_cpm, log = FALSE, normalized.lib.sizes=TRUE)

# Calculate the log cpm
log_cpm <- cpm(DEGL_cpm, log = TRUE, normalized.lib.sizes=TRUE)

#Check out the cpm normalized matrix and log cpm normalized matrix
head(cpm)
head(log_cpm)
```

<br>

> ③ **1-2.** **TMM** (trimmed mean of M-values) ([ref](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25))

>> ○ Definition: Normalize given read counts by dividing by the total read count of the sample + Trimming

>> ○ Proposed by Robinson & Oshlack (2010) ([ref](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25))

>> ○ Since trimming is performed, the library size does not remain constant.

>> ○ **Significance** **1.** Corrects the bias where read count does not accurately represent actual gene activity and is proportional to sequencing depth([ref](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25#:~:text=Estimated%20normalization%20factors,factor%20of%202.))

>>> ○ **Condition:** Ensure genes with the same expression levels in both samples are not detected as DEGs

>>> ○ **Assumption:** Majority of genes are not differentially expressed (consistent with author's experience)

>>> ○ **Thought experiment**

>>>> ○ Sample A is a mixture of human + mouse RNA, Sample B is specifically human RNA from Sample A, both samples having equal human and mouse RNA counts

>>>> ○ When depths are equal, human RNA reads in A would be exactly half of B's human RNA reads: reads in A are distributed over genes twice as much

>>>> ○ To adjust each gene's RNA read count in A, multiply by a factor (normalization factor) twice that of B's

>>>> ○ This assumption leads to batch + sample effect ≃ batch effect, making the normalization method applicable only in this case

>> ○ **Significance 2.** Determining total RNA production Sk is difficult, but calculating the ratio Sk / Sk' for two samples is relatively easy

>> ○ Brief definition: Divide given read count by the sample's total count

>>> ○ Example

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/50920c36-43e2-4b64-ad4b-69453d422598)

<br>

>>> ○ The following depicts differential gene expression of gene g between Sample 1 and Sample 2

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/0dbc2c10-e865-4739-a6df-6606aea3f291)

<br>

>> ○ 1<sup>st</sup>. Symbol definitions

>>> ○ L<sub>g</sub>: Length of gene g

>>> ○ μ<sub>gk</sub>: Actual transcript count of gene g in sample k. Represents expression level. Related to population

>>> ○ N<sub>k</sub>: Total transcript count in sample k

>>> ○ S<sub>k</sub>: RNA count in sample k

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/c2b1a658-3f59-4606-882e-1866c681f740)

<br>

>>> ○ S<sub>k</sub> / N<sub>k</sub>: Average RNA count per transcript

>>> ○ Y<sub>gk</sub>: Observed transcript count of gene g in sample k. Related to the sample population

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/255024d4-67ad-4a27-b473-85ebc57011bd)

<br>

>>> ○ M<sub>g</sub>: Gene-wise log-fold-change

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/47c34c3a-2ccb-4a22-ba6a-3a70c9bbc4ea)

<br>

>>> ○ A<sub>g</sub>: Absolute expression level

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/0df0b922-9481-46c1-89cd-c36bdf044ef7)

<br>

>>> ○ S<sub>k</sub> / S<sub>r</sub>: Scaling factor to divide by in sample k. Proportional to S<sub>k</sub>. Refer to the thought experiment above.

>>> ○ TMM: Normalization factor

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/e5090a42-6242-4795-bc03-ee6776536029)

<br>

>> ○ 2<sup>nd</sup>. Remove genes with expression of 0

>> ○ 3<sup>rd</sup>. Trimming: The aspect that is most fundamentally different from the RPM or CPM.

>>> ○ Trimmed mean: Average of data excluding top x% and bottom x%

>>> ○ Doubly trimmed: Trim based on log-fold-change Mrgk and absolute intensity Ag

>>> ○ Initial researchers trimmed 30% each way by Mrgk and 5% each way by Ag

>> ○ 4<sup>th</sup>. Divide by TMM for sample k

>>> ○ w<sup>r</sup><sub>gk</sub>: Larger weights for genes with low expression to prevent distortion

>>> ○ When N<sub>k</sub> = N<sub>k</sub>' and Y<sub>gk</sub> = 2 × Y<sub>gr</sub>, TMM is approximately 2

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/8dec990b-ce58-4714-8320-623b69e56167)

<br>

>> ○ [R code](https://bio-protocol.org/exchange/protocoldetail?id=4462&type=1#:~:text=CPM%20based%20on-,TMM,-scaled%20library%20size): Change library size with TMM and then calculate CPM

<br>

```python
library(edgeR)
raw_counts_matrix = ?
group = ?
DEGL <- DGEList(counts=raw_counts_matrix, group=group)

# Calculate normalization factors using TMM method to align columns of a count matrix
DEGL_TMM <- calcNormFactors(DEGL, method="TMM")

# Calculate the cpm with the TMM normalized library
TMM <- cpm(DEGL_TMM, log = FALSE, normalized.lib.sizes=TRUE

# Check out the cpm of TMM normalization
head(TMM)
```

<br>

>> ○ **Application 1.** GeTMM method

> ④ **1-3.** RLE (relative log estimate)

>> ○ Proposed by Anders & Huber (2010).

>> ○ The normalization method adopted by default in the R packages DESeq and DESeq2.

>> ○ **Step 1.** Creation of a pseudo-reference (median library): The geometric mean is taken across all samples.

<br>

<img width="237" alt="스크린샷 2025-01-23 오후 5 41 53" src="https://github.com/user-attachments/assets/57f2ca52-ff8e-44bb-a12d-58e1b55b8059" />

<br>

>>> ○ X: raw count 

>>> ○ g: gene 

>>> ○ k: condition 

>>> ○ r: replicate 

>> ○ **Step 2.** The median ratio of each sample to the pseudo-reference is used as the scale factor (size factor).

<br>

<img width="229" alt="스크린샷 2025-01-23 오후 5 42 38" src="https://github.com/user-attachments/assets/945f9c89-f5ce-4dae-9943-638ef5f896d6" />

<br>

>> ○ **Step 3.** The gene count value of that sample divided by the scale factor is considered the normalized count for that gene.

<br>

<img width="145" alt="스크린샷 2025-01-23 오후 5 43 20" src="https://github.com/user-attachments/assets/065d4641-9ca0-4264-8c6b-0a936b2c9b0c" />

<br>

>> ○ [R code](https://bio-protocol.org/exchange/protocoldetail?id=4462&type=1#:~:text=based%20on%20the-,RLE,-normalized%20library%20size)

<br>

```python
library(edgeR)
raw_counts_matrix = ?
group = ?
DEGL <- DGEList(counts=raw_counts_matrix, group=group)

# Calculate normalization factors using RLE method to align columns of a count matrix
DEGL_RLE <- calcNormFactors(DEGL, method="RLE")

# Calculate the cpm with the RLE normalized library
RLE <- cpm(DEGL_RLE, log = FALSE, normalized.lib.sizes=TRUE)

# Check out the TMM normalized result
head(RLE)
```

<br>

> ⑤ **1-4.** UQ (Upper Quartile) Normalization

>> ○ A method to adjust expression levels at specific quantiles to be the same when analyzing two transcriptomes.

>> ○ Proposed by Bullard et al. (2010).

>> ○ Generally uses the upper 75% (lower 25%) quartile values as variables (cf. Q3-norm).

>> ○ Mostly used in microarray data.

>> ○ [R Code](https://bio-protocol.org/exchange/protocoldetail?id=4462&type=1#:~:text=upperquartile%E2%80%9D%20to%20perform-,UQ,-normalization%2C%20and%20then)

<br>

```python
library(edgeR)
raw_counts_matrix = ?
group = ?
DEGL <- DGEList(counts=raw_counts_matrix, group=group)

# Calculate normalization factors using UQ method to align columns of a count matrix
DEGL_UQ <- calcNormFactors(DEGL, method="upperquartile")

# Calculate the cpm with the UQ normalized library
UQ <- cpm(DEGL_UQ, log = FALSE, normalized.lib.sizes=TRUE)
# Check out the UQ normalized result
head(UQ)
```

<br>

⑶ **Type 2.** Gene Length Normalization

> ① Definition: A method of correcting for gene length when comparing the expression of different genes (or exons, isoforms) within a single sample.

>> ○ Here, gene length refers to the effective length, which is the actual gene length minus the read length.

>> ○ Gene length correction: Gene counts are proportional to gene length, so count values are divided by gene length.

>> ○ Gene length normalization is criticized for not properly reflecting data characteristics, with decreasing importance of metrics like FPKM, TPM.

> ② **2-1.** RPKM (Reads Per Kilobase of Transcript per Million Mapped Reads)

>> ○ Formula: RPKM for gene i is represented as Q reads and ℓ exon length.

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/cbc805f1-6e24-41df-9f85-def5ccd193c3)

<br>

>> ○ Used to compare gene expression among different genes within a sample.

>> ○ **Example:** 25,000 reads in gene / (0.5 kb gene × 40 million reads) = 1,250 

> ③ **2-2.** FPKM (Fragments Per Kilobase of Exon per Million Mapped Fragments)

>> ○ Formula: FPKM for gene i is represented as q reads and ℓ exon length.

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/6457560c-7b13-475f-be25-23bb6ab4de54)

<br>

>> ○ Fragment refers to a pair of reads in paired-end sequencing.

>> ○ Similar to RPKM, but used only for paired-end RNA-seq (Trapnell et al., 2010).

>> ○ **Example:** 25,000 paired end fragments in gene / (0.5 kb gene × 40 million paired end reads) = 1,250 

> ④ **2-3.** TPM (Transcripts Per Kilobase Million): Proposed by Li et al. (2010)

>> ○ Definition: Normalized based on how many molecule from this gene for each 1M RNA molecules in the sample.

>> ○ **The only difference from RPKM**: When calculating TPM, you normalize for gene length first, and then normalize for sequencing depth secondly.

>> ○ Relatively easy to use due to length-based normalization, more common than CPM.

>> ○ Summing TPM values in a single library gives 1,000,000, allowing **comparison between different samples**.

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/d60b6af8-8880-4998-b284-a4b069195a98)

<br>

>> ○ Relation between TPM and RPKM: For the number of genes n,

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/33187fb7-b59e-465d-b4a2-0ed43e98eeee)

<br>

>> ○ TPM is highly correlated with RPKM (or FPKM) results

⑷ **Type 3.** Log-Transformation

> ① **Purpose 1:** For genes with high count values, the actual activity of those genes may be exaggerated in interpretation.

> ② **Purpose 2:** When there are both very small and very large values, it is necessary to adjust the scale to be similar.

> ③ To address the above issues, the results of log-transforming the normalized counts are considered as gene expression values.

⑸ **Type 4.** scaling (e.g., z-score transformation)

> ① For each patient and each sample, the range of gene expression values varies. To compare them rationally, the range of values is adjusted.

> ② For example: In the case of the [TCGA](https://jb243.github.io/pages/1694), [Seurat](https://jb243.github.io/pages/1788) pipeline, the maximum gene expression value is set to around 10 → the minimum value generally becomes negative.

⑹ **Type 5.** Feature selection, Cell selection

⑺ **Type 6.** Lambda GC: SNP Data Normalization Method

> ① **Step 1.** Analyze the correlation between each SNP and the phenotype.  

> ② **Step 2.** Convert the p-value to a z-score. For example, in R: `z = qnorm(p / 2)`  

> ③ **Step 3.** Calculate the chi-square statistic. For example, in R: `c = z^2`  

> ④ **Step 4.** Calculate the median of the chi-square statistics for all SNPs.  

> ⑤ **Step 5.** **Lambda GC**: Divide the above median by 0.455 (which is the median of χ² with df = 1). The expected value is 1.  

> ⑥ **Step 6.** Divide the actual χ² value for each SNP by lambda GC, and then reverse to calculate the p-value.

⑻ R: Obtaining normalized expression using the [Seurat](https://jb243.github.io/pages/1788) package.

<br>

```python
library(dplyr)
library(Seurat)

pbmc.data <- Read10X(data.dir = "./Spatial_matrix/")
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 100)
pbmc[["percent.mt"]] <- PercentageFeatureSet(object = pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, subset = nFeature_RNA > 500)
pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableFeatures(object = pbmc, selection.method = "vst", nfeatures = 2000) 

### Download for Normalized Count Data
write.csv(pbmc@assays$RNA@data, "./normalized_counts.csv")


all.genes <- rownames(x = pbmc) 
pbmc <- ScaleData(object = pbmc, features = all.genes) 

### Download for Scaled Expression Data (also known as TCGA scale) 
write.csv(pbmc@assays$RNA@scale.data, "./scaled_expression.csv")
```

<br>

⑼ Python: Obtaining normalized expression using the scanpy package ([ref](https://scanpy.readthedocs.io/en/stable/usage-principles.html))

<br>

```python
import scanpy as sc
import pandas as pd

tissue_dir = './'

adata = sc.read_visium(tissue_dir) 
adata.var_names_make_unique()
sc.pp.normalize_total(adata, inplace=True)
sc.pp.log1p(adata)

pd.DataFrame(adata.X).to_csv('normalized_expression.csv')
```

<br>

⑽ Paper Representation

> ○ The count data were normalized by log2-transformation of counts per million (CPM) + 1 pseudocount, and scatter plots were generated for each pair of consecutive section using the ggplot2 package (28) in R Studio (versioin 1.1.453). The built-in stats package was used to compute Pearson correlations. ([ref](https://aacrjournals.org/cancerres/article/78/20/5970/631815/Spatially-Resolved-Transcriptomics-Enables)) 

<br>

<br>

## **6. `QC 6.`** Batch Effect

⑴ Overview

> ① Background: Apart from experimental variables, batch effects can influence results between experimental and control groups.

> ② Batch Effect: Experimental outcomes affected by factors other than biological variables. Examples include:

>> ○ Sequencing dates

>> ○ Researchers performing sequencing

>> ○ Sequencing equipment

>> ○ Protocols

> ③ Systemic batch effects like library size can be corrected through normalization.

> ④ Batch effect removal process referred to as removing non-biological batch effects, often using regression analysis.

⑵ Batch Effect Removal

> ① This is particularly important in DEG analysis through comparison between samples.

> ② Caution

<br>

```python
    batch condition
    <factor> <factor>
1          1        A 
2          1        A
3          1        B
4          1        B
5          2        C
6          2        C
```

<br>

>> ○ Batch effects cannot be theoretically removed if a specific condition applies to a specific batch.

>> ○ However, even in this case, it is possible to create an incomplete regression model by distinguishing between batch effect and covariate to remove the batch effect.

> ③ **Method 1:** limma::removeBatchEffect: Removes batch effects by inputting normalized expression matrix and batch information into a linear model. ([ref](https://rdrr.io/bioc/limma/man/removeBatchEffect.html))

> ④ **Method 2:** sva::ComBat (Johnson et al., 2007): Empirical Bayes-based method for removing batch effects when batch information is known.
([ref](https://www.bioconductor.org/packages/release/bioc/vignettes/sva/inst/doc/sva.pdf), [ref](https://scanpy.readthedocs.io/en/stable/api/scanpy.pp.combat.html), [ref](https://academic.oup.com/biostatistics/article/8/1/118/252073)). Uses linear models and empirical Bayes shrinkage.

<br>

```python
# Import the sva package
library(sva)

# Create batch vector
batch <- c(1,2,3,1,2,3)

# Apply parametric empirical Bayes frameworks adjustment to remove the batch effects
combat_edate_par = ComBat(dat=TMM, batch=batch, mod=NULL, par.prior=TRUE, prior.plots=TRUE)

# Apply non-parametric empirical Bayes frameworks adjustment to remove the batch effects
combat_edata_non_par = ComBat(dat= TMM, batch=batch, mod=NULL, par.prior=FALSE, mean.only=TRUE)

# Check out the adjusted expression profiles
head(combat_edate_par)
head(combat_edate_non_par)
```

<br>

> ⑤ **Method 3:** ComBat_seq (Zhang et al., 2020): Takes raw count matrix and outputs adjusted count matrix. Batch information should be known.

<br>

```python
library(sva)

# Create batch vector
batch <- c(1,2,3,1,2,3)

# Include group condition
combat_seq_with_group <- ComBat_seq(raw_counts_matrix, batch=batch, group=group, full_mod=TRUE)
# Without group condition
combat_seq_without_group <- ComBat_seq(raw_counts_matrix, batch=batch, group=NULL, full_mod=FALSE)

# Check out the adjusted expression profiles
head(combat_seq_with_group)
head(combat_seq_without_group)
```

<br>

> ⑥ **Method 4:** SVA seq (Leek, 2014): Functions even without known batch information.

> ⑦ **Method 5:** RUV seq (Risso et al., 2014)

⑶ Measurement of the accuracy of batch effect removal

> ① k-nearest-neighbor batch effect test (kBET)

> ② ASW across batches

> ③ k-nearest-neighbor (kNN) graph connectivity

> ④ batch removal using PCA regression

⑷ Application 1: Clustering and Batch Effect

> ① Clustering can be used for batch effect removal by dividing experimental and control groups within major clusters (e.g., cell type clusters) to obtain DEGs.

⑸ Application 2: Data Integration

> ① Merging data from different batches or modalities, with consideration of batch correction effects.

> ② Modifying two groups to have the same characteristics.

>> ○ **Example 1:** Train the model so that the clustering patterns are not affected by batch effects.

>> ○ **Example 2:** Train the model to minimize the discriminator's performance, which distinguishes data based on batch-specific effects (i.e., to make the data indistinguishable after integration).

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/ff493b91-34a8-4184-823b-4b7122ce63b8)

**Figure 19.** Types of Data Integration 

<br>

> ③ **Method 1.** [MNN](https://www.nature.com/articles/nbt.4091) (Mutual Nearest Neighbors) ([git](https://github.com/chriscainx/mnnpy)): Utilized in R scater or Python scanpy.

> ④ **Method 2.** Seurat V1 and V2: Uses CCA (Canonical Correlation Analysis)

>> ○ Has a single data slot for expression values that stores either raw counts or normalized data.

>> ○ Designed primarily for single modalities.

>> ○ If the batch effect is large or there are few common cell subsets, integration is not effective.

>> ○ [CCA](https://jb243.github.io/pages/2158#8-others)-based Data Integration: This method aggressively aligns the two groups.  

>> ○ [RPCA](https://jb243.github.io/pages/2158#8-others)-based Data Integration: This method performs a less aggressive alignment of the two groups, making it useful when the tissue characteristics of the two datasets are significantly different.

> ⑤ **Method 3.** [Seurat V3](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8)

>> ○ **Step 1.** Perform dimensional reduction on both the reference and query datasets using [diagonalized CCA](https://jb243.github.io/pages/2158#8-type-7-cca).

>> ○ **Step 2.** Apply L2-norm to the canonical correlation vector.  

>> ○ **Step 3.** Compute MNN (Mutual Nearest Neighbors) to explore the low-dimensional representation shared by both datasets: This involves identifying and linking cells that have the same context within the dataset. These linked cell pairs are referred to as anchors.

>> ○ **Step 4.** Score the anchors and remove incorrectly linked low-confidence anchors: The score is defined as shared neighbor overlap.

>> ○ **Step 5.** Define the weighted distance: Given the i-th anchor a<sub>i</sub>, query cell c, and anchor score S<sub>i</sub>,  

<br>

<img width="297" alt="스크린샷 2025-01-30 오전 12 18 43" src="https://github.com/user-attachments/assets/975b1fa0-f047-41f3-a530-2d9de4697ce1" />

<br>

>> ○ **Step 6.** Apply a Gaussian kernel to the weighted distance: The default standard deviation (sd) is 1.  

<br>

<img width="240" alt="스크린샷 2025-01-30 오전 12 19 03" src="https://github.com/user-attachments/assets/3cb1aaea-755c-421d-9f32-dade141554c8" />

<br>

>> ○ **Step 7.** Normalize all k.weighted anchors.  

<br>

<img width="201" alt="스크린샷 2025-01-30 오전 12 19 21" src="https://github.com/user-attachments/assets/7993d133-40ba-48e7-b316-4f7033608d72" />

<br>

>> ○ **Step 8.** Compute the integration matrix B = Y[:, a] - X[:, a] for all anchor cell pairs, where X is the reference expression matrix and Y is the query expression matrix.  

>> ○ **Step 9.** Compute the transformation matrix C using the weight matrix W and the integration matrix B.

<br>

<img width="101" alt="스크린샷 2025-01-30 오전 12 19 36" src="https://github.com/user-attachments/assets/7888bd69-4e56-4ac2-96d2-37a6a90e8702" />

<br>

>> ○ **Step 10.** Subtract the transformation matrix C from the original query expression matrix Y to obtain the integrated expression matrix.  

<br>

<img width="101" alt="스크린샷 2025-01-30 오전 12 19 50" src="https://github.com/user-attachments/assets/f79cc296-1746-4515-908c-1532b047f054" />

<br>

>> ○ **Step 11.** **Label transfer**: Compute the label prediction P<sub>l</sub> using the binarized anchor classification matrix L and the weight matrix W.  

<br>

<img width="101" alt="스크린샷 2025-01-30 오전 12 20 02" src="https://github.com/user-attachments/assets/d477130b-2893-4a10-8607-f3088a6d71c8" />

<br>

> ⑥ **Method 4.** Seurat V5 

>> ○ Has fast and more efficient anchoring with improved memory handling.

>> ○ Allows for integration of not just modalities measuring nucleic acids but also others like proteins.

> ⑦ **Method 5.** [BBKNN](https://github.com/Teichlab/bbknn) (Batch-Balanced k-Nearest Neighbor): Using PCA

> ⑧ **Method 6.** mnnCorrect

> ⑨ **Method 7.** [Scanorama](https://www.nature.com/articles/s41587-019-0113-3): Used in Python scanorama. Using singular value decomposition 

> ⑩ **Method 8.** [Conos](https://www.nature.com/articles/s41592-019-0466-z?error=cookies_not_supported&code=5680289b-6edb-40ad-9934-415dac4fdb2f) : Used in R conos.

> ⑪ **Method 9.** [scArches](https://docs.scarches.org/en/latest/): Utilizes transfer learning.

> ⑫ **Method 10.** [DESC](https://github.com/eleozzr/desc) 

> ⑬ **Method 11.** [fastMNN](https://bioconductor.org/packages/batchelor/) (batchelor): Using PCA

> ⑭ **Method 12.** [Harmony](https://github.com/immunogenomics/harmony): Using PCA. Harmony does not provide batch effect-corrected normalized expression, but it does provide batch effect-corrected low-dimensional embeddings that can be used for downstream analysis.

> ⑮ **Method 13.** [LIGER](https://github.com/MacoskoLab/liger): A general approach for integrating single-cell transcriptomic, epigenomic and spatial transcriptomic data. factor-based. Using integrative non-negative matrix factorization

> ⑯ **Method 14.** [SAUCIE](https://github.com/KrishnaswamyLab/SAUCIE) 

> ⑰ **Method 15.** [scANVI](https://github.com/chenlingantelope/HarmonizationSCANVI): conditional VAE ([ref](https://www.sc-best-practices.org/cellular_structure/integration.html#id227))

> ⑱ **Method 16.** [scGen](https://github.com/theislab/scgen): conditional VAE ([ref](https://www.sc-best-practices.org/cellular_structure/integration.html#id221))

> ⑲ **Method 17.** [scVI](https://github.com/YosefLab/scVI): conditional VAE ([ref](https://www.sc-best-practices.org/cellular_structure/integration.html#id226)) 

>> ○ Pros: Provides batch-effect-corrected normalized expression and includes a reference code for identifying differentially expressed genes (DEGs). ([ref](https://www.kaggle.com/code/hiramcho/scrna-seq-differential-expression-with-scvi#4.-Differential-EXpression))  

>> ○ **Cons 1.** Not applicable to epigenetics data (e.g., scATAC-seq).  

>> ○ **Cons 2.** The separately provided DEG identification code is slow and inaccurate. The DEG results can sometimes be completely reversed due to slight differences in batch-effect correction between all 10 datasets and only 2 of them.  

>> ○ Recommendation: It is recommended to use scVI normalized expression and `scanpy.tl.rank_genes_groups` for DEG identification.

> ⑳ **Method 18.** [TrVae](https://github.com/theislab/trvae): conditional VAE ([ref](https://www.sc-best-practices.org/cellular_structure/integration.html#id227))

> ㉑ **Method 19.** [TrVaep](https://github.com/theislab/trvaep)

> ㉒ **Method 20.** [scib](https://github.com/theislab/scib): In addition to merging multiple integration tools, benchmarking is also provided.

>> ○ Integration function: BBKNN, ComBat, DESC, Harmony, MNN, SAUCIE, Scanorama, scANVI, scGen, scVI, trVAE

>> ○ Benchmarking metric: ARI, ASW, F1, mutual score, etc.

> ㉓ **Method 21.** iMAP

> ㉔ **Method 22.** INSCT

> ㉕ **Method 23.** scDML

> ㉖ **Method 24.** [scDREAMER](https://www.nature.com/articles/s41467-023-43590-8), scDREAMER-Sup: It even enables inter-species integration.

> ㉗ **Method 25.** [SATURN](https://www.nature.com/articles/s41592-024-02191-z): Integration of datasets from different species

> ㉘ **Method 26.** [GLUE](https://www.nature.com/articles/s41587-022-01284-4) (Cao and Gao, 2023): A tool for integrating unpaired data from different platforms such as scRNA-seq, scATAC-seq, and snmC-seq.

>> ○ **Step 1.** Embed cell × feature data from each omics into cell × embedding, where each cell is represented in a common dimension.

>> ○ **Step 2.** To represent the relationships between omics, use a knowledge-based guidance graph to represent regulome × embedding, where each regulome is expressed as a vector in the same dimension as in **Step 1**.

>> ○ **Step 3.** Construct an [autoencoder](https://jb243.github.io/pages/956) by feeding the inputs from **Step 1** and **Step 2** into the encoder, with the decoder outputting the integrated data.

>> ○ **Step 4.** Adversarial learning: Introduce a discriminator to identify platform-specific effects, and search for autoencoder parameters that minimize the discriminator’s performance (thus facilitating better integration).

> ㉙ **Method 27.** Seurat Anchor (Stuart et al., 2019): factor-based 

> ㉚ **Method 28.** DC3 (Zeng et al., 2019): factor-based

> ㉛ **Method 29.** coupled NMF (Duren et al., 2018): factor-based

> ㉛ **Method 30.** SCOT (Demetci et al., 2022): topology-based

> ㉛ **Method 31.** UnionCom (Cao et al., 2020): topology-based

> ㉛ **Method 32.** Panoma (Cao et al., 2022): topology-based

> ㉛ **Method 33.** MrVI

> ㉛ **Method 34.** scGCN: Supports multi-omics

> ㉛ **Method 35.** scETM 

> ㉛ **Method 36.** MultiVI 

> ㉛ **Method 37.** Biolord 

⑹ **2-1.** Merge between scRNA-seq or ST

> ① Except for clustering, most methods require switching DefaultAssay from integrated to RNA/Spatial/SCT, etc

> ② FindMarkers

> ③ FindAllMarkers

> ④ FeaturePlot 

> ⑤ SpatialFeaturePlot

> ⑥ DotPlot 

> ⑦ DimPlot 

> ⑧ SpatialDimPlot 

> ⑨ genewise correlation

> ⑩ trajectory analysis 

⑺ **2-2.** Merging scRNA-seq data with other modalities

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/e915766b-c480-42bd-9385-80d64aa1635c)

**Figure 20.** Merging scRNA-seq data

<br>

<img width="885" alt="스크린샷 2024-09-05 오전 10 22 40" src="https://github.com/user-attachments/assets/65a95167-630e-4994-80a2-7cfd7185eb54">

**Table 3.** Analysis methods for matched data

<br>

<img width="885" alt="스크린샷 2024-09-05 오전 10 23 15" src="https://github.com/user-attachments/assets/1fb6858a-648e-4ce0-8bde-1b11433d59c3">

**Table 4.** Analysis methods for unmatched data

<br>

<br>

## **7. `Common 1.`** Clustering

⑴ Type 1: [K Means Clustering](https://jb243.github.io/pages/2150#footnote_link_67_51)

⑵ Type 2: [Unsupervised Hierarchical Clustering](https://jb243.github.io/pages/2150#footnote_link_67_50)

⑶ Type 3: Matrix factorization

> ① Algorithm to factorize a known matrix A into W and H matrices: A ~ W × H

>> ○ A matrix: Represents samples and features. Can be inferred from samples.

>> ○ H matrix: Represents variables and features.

>> ○ Similar to K means clustering, PCA algorithm.

>> ○ An [autoencoder](https://jb243.github.io/pages/956) is a broader concept than matrix factorization because it includes non-linear transformations.

>> ○ The following algorithms are based on the least square method, but can also utilize methods such as gradient descent.

> ② Algorithm: R = UV, where R ∈ ℝ<sup>5×4</sup>, U ∈ ℝ<sup>5×2</sup> , and V ∈ ℝ<sup>2×4</sup>, searches for U and V.

<br>

```python
import numpy as np
R = np.outer([3,1,4,2.,3],[1,1,0,1]) + np.outer([1,3,2,1,2],[1,1,4,1])
U=np.random.rand(5,2)
V=np.random.rand(2,4)
for i in range(3):
    V,_,_,_=np.linalg.lstsq(U, R, rcond=None)
    Ut,_,_,_=np.linalg.lstsq(V.T, R.T, rcond=None)
    U=Ut.T
U@V # it is similar to R!
```

<br>

> ③ NMF(non-negative matrix factorization)

<br>

```python
import numpy as np
R = np.outer([3,1,4,2.,3],[1,1,0,1]) + np.outer([1,3,2,1,2],[1,1,4,1])
U=np.random.rand(5,2)
V=np.random.rand(2,4)
for i in range(20):
    V,_,_,_=np.linalg.lstsq(U, R, rcond=None)
    V = np.where(V >= 0, V, 0) #set negative entries equal zero
    Ut,_,_,_=np.linalg.lstsq(V.T, R.T, rcond=None)
    U=Ut.T
    U = np.where(U >= 0, U, 0) #set negative entries equal zero
U@V # it is similar to R!
```

<br>

> ④ Matrix completion (Netflix algorithm): performing matrix factorization on a masked R.

<br>

```python
import numpy as np
R = np.outer([3,1,4,2.,3],[1,1,0,1]) + np.outer([1,3,2,1,2],[1,1,4,1])
mask=np.array([[1.,1,1,1],
               [1,0,0,0],
               [1,0,0,0],
               [1,0,0,0],
               [1,0,0,0]])
               
U=np.random.rand(5,2)
V=np.random.rand(2,4)
RR = U@V
RR = RR*(1-mask)+R*mask

for i in range(20):
    V,_,_,_=np.linalg.lstsq(U, R, rcond=None)
    V = np.where(V >= 0, V, 0)
    Ut,_,_,_=np.linalg.lstsq(V.T, R.T, rcond=None)
    U=Ut.T
    U = np.where(U >= 0, U, 0)
    RR = U@V
    RR = RR*(1-mask)+R*mask

RR*(1-mask)+R*mask # it is similar to R!
```

<br>

> ⑤ **Application 1.** Cell type classification

>> ○ Aims to obtain cell type proportions from scRNA-seq data from tissues.

>> ○ Important to reduce confounding effects due to cell type heterogeneity.

>> ○ **3-1.** Constrained linear regression

>> ○ **3-2.** Reference-based approach

>> ○ **3-2-1.** CIBERSORT (cell-type identification by estimating relative subsets of RNA transcript): Allows you to check the cell type proportion and p-value for each sample.

> ⑥ **Application 2.** joint NMF: Expands to multi-omics.

> ⑦ **Application 3:** Metagene extraction

> ⑧ **Application 4.** [Starfysh](https://www.nature.com/articles/s41587-024-02173-8#Methods): The following algorithm infers archetypes from spatial transcriptomic data and determines anchors representing each archetype:

>> ○ **Step 1.** Construct an autoencoder

<br>

<img width="99" alt="스크린샷 2024-10-07 오후 6 50 41" src="https://github.com/user-attachments/assets/a66dad3e-f784-423a-bf1a-1370bc97470d">

<br>

>>> ○ X ∈ ℝ<sup>S×G</sup>: Input data (spots × genes)

>>> ○ D: Number of archetypes

>>> ○ B ∈ ℝ<sup>D×S</sup>: Encoder. In the context of inferring archetypes, the sum of the distribution of each archetype across all spots must be 1.

>>> ○ H = BX: Latent variable

>>> ○ W ∈ ℝ<sup>S×D</sup>: Decoder. In the context of reconstructing the input data, the sum of the weights of all archetypes for each spot must be 1.

>>> ○ Y = WBX: Reconstructed input

> ○ **Step 2.** Solve the optimization algorithm to calculate W and B

<br>

<img width="375" alt="스크린샷 2024-10-07 오후 6 51 51" src="https://github.com/user-attachments/assets/744213b1-f4f1-40bc-9ec1-f89e43d7641c">

<br>

> ○ **Step 3.** Spots with the highest weights for each archetype in the W matrix are selected as anchor spots

> ○ **Step 4.** Adjust granularity: If the distance between archetypes is close, merge them or use a hierarchical structure to adjust the distance

> ○ **Step 5.** Form archetypal communities by searching for the nearest spot for each anchor and identifying marker genes

> ○ **Step 6.** If a signature gene set is given, add archetypal marker genes to the existing gene set and recalculate the anchors.

>> ○ During this, use the stable marriage matching algorithm to match each archetype with the most similar signature.

⑷ **Category 4.** [Other clustering algorithms](https://jb243.github.io/pages/2150#footnote_link_67_53)

> ① SNN (shared nearest neighbor) modularity optimization based clustering
algorithm

> ② Leiden clustering

> ③ Louvain clustering

> ④ mean-shift clustering

> ⑤ DBSCAN (density-based spatial clustering of applications with noise)

> ⑥ spectral clustering

> ⑦ gaussian mixture

> ⑧ [watershed algorithm](https://opencv-python.readthedocs.io/en/latest/doc/27.imageWaterShed/imageWaterShed.html)

> ⑨ thresholding method

> ⑩ MST (minimum spanning tree)

> ⑪ curve evolution

> ⑫ sparse neighboring graph

> ⑬ SC3

> ⑭ SIMLR

> ⑮ FICT

> ⑯ fuzzy clustering

<br>

<br>

## **8. `Common 2.`** Differentially Expressed Gene (DEG) Analysis

⑴ Definition: Process of finding genes that differ between experimental and control groups.

⑵ Criteria for DEG: Slightly varies depending on experimental design.

> ① Experimental design

<br>

<img width="507" alt="스크린샷 2025-02-16 오전 8 32 28" src="https://github.com/user-attachments/assets/c3dbd041-dd98-476b-85fa-e8376f3f90e4" />

**Figure 21.** Design matrix

<br>

> ① FC (fold change)

>> ○ Definition: Ratio of treatment's average gene expression to control's average gene expression.

>> ○ **Issue 1.** Division by zero: Genes with such issues are either removed beforehand or assigned special values through separate interpretations.

>> ○ **Issue 2.** Asymmetrical values around 1: Addressed by using log fold change.

> ② [Adjusted p-value](https://jb243.github.io/pages/1631)

>> ○ Multiple Testing Problem: The act of conducting multiple statistical tests itself can lead to inaccurate conclusions.

>> ○ **Type 1.** Control of Family-Wise Error Rate (FWER)

>>> ○ Definition: The probability of reaching at least one incorrect conclusion among all hypotheses tested. For instance, a FWER of 5% means there is a less than 5% chance of making even one incorrect conclusion across multiple hypothesis tests. This approach is very conservative, allowing almost no false positives.

>>> ○ **1-1.** Sidak Correction: Adjusts the alpha threshold rather than the p-values and is used when p-values are independent.

>>> ○ **1-2.** Bonferroni Correction: Directly adjusts each p-value and can be applied even when p-values are not independent. It is highly conservative.

>> ○ **Type 2.** Control of False Discovery Rate (FDR)

>>> ○ Definition: The method of controlling the probability that a null hypothesis is included among the actually rejected hypotheses (FDR, the rate of Type I errors) to be below a certain level.

>>> ○ **2-1.** Benjamini–Hochberg (B&H): Used when the correlations between tests are relatively simple.

>>> ○ **2-2.** Benjamini–Yekutieli (B&Y): Used when the correlations between tests are complex.

>> ○ **Type 3.** FWER and FDR control can be applied simultaneously.

> ③ **Visualization 1.** Volcano plot

>> ○ x-axis: log fold change

>> ○ y-axis: log adjusted p-value

>> ○ Useful for visualizing the distribution of genes satisfying the DEG condition.

> ④ **Visualization 2.** MA plot

>> ○ x-axis: Mean of log normalized count

>> ○ y-axis: log fold change

>> Widely used in microarray analysis and applicable to RNA-seq.

⑶ Statistical Techniques

> ① t test

>> ○ One of the commonly used statistical techniques

>> ○ Parametric statistical estimation

>> ○ Applies t-test after taking the log of expression (FPKM/TPM)

>> ○ Not recommended for small sample sizes due to difficult variance estimation: In this case, DESeq, EdgeR, limma are recommended

>> ○ Strict application of FC threshold is recommended

> ② [Mann-Whitney-Wilcoxon](https://jb243.github.io/pages/2099#2-wilcoxon-rank-sum-test) (Wilcoxon rank-sum test)

>> ○ Non-parametric statistical estimation

>> ○ Not recommended for sample sizes less than 10

>> ○ For small samples, it is recommended to use limma, edgeR, DESeq2, etc.

> ③ [ANOVA](https://jb243.github.io/pages/1635) & [Kruskal-Wallis test](https://jb243.github.io/pages/1688)

>> ○ Used for multi-level single factor DEG analysis

>> ○ For sample sizes less than 10, it's recommended to use DESeq2, edgeR, limma's multi-level single factor mode

> ④ FC cutoff 

>> ○ Fold change cutoff implicitly assumes a constant variange, e.g. from prior. 

⑷ DEG Tools

> ① DESeq, [DESeq2](https://jb243.github.io/pages/2202) ([paper](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8), [manual](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html))

>> ○ Input: raw count

>> ○ Assumes that we can obtain better variance estimates of genes without assuming that they all have the same variance.

>> ○ Does not support random effect modeling or mixed effect modeling: limma is somewhat flexible, so it can be done.

>> ○ Based on the [negative binomial model](https://jb243.github.io/pages/1626#7-negative-binomial-distribution-)

>>> ○ The transcriptome has a large variance due to many zero counts, making it more preferred over the [normal](https://jb243.github.io/pages/1627#2-normal-distribution) or [Poisson distribution](https://jb243.github.io/pages/1626#9-poisson-distribution).

>>> ○ The negative binomial model can be sensitive to outliers: Newest version of DESeq2 add extra features to be robust to outliers.

>> ○ Estimate variance using the empirical Bayes model under the following two options:

>> ○ **Option 1.** dispersion

>>> ○ **Step 1.** Perform maximum likelihood estimation (MLE) for each gene to obtain the black data points in the graph.

>>> ○ **Step 2.** Derive the red trend line from the black points, which serves as the prior mean.

>>> ○ **Step 3.** Compute the MAP (maximum a posteriori) estimate, indicated by the blue arrows.

>>> ○ **Step 4.** Data points that are not shrunk towards the prior can be considered outliers, marked with blue circles.

<br>

<img width="307" alt="스크린샷 2025-01-30 오전 11 40 51" src="https://github.com/user-attachments/assets/cb7c2bbd-3772-474c-946d-7f71ca56dcb0" />

**Figure 22.** DESeq dispersion mode

<br>

>> ○ **Option 2.** fold change (optional)

>>> ○ DESeq2 provides shrinkage for log2FC estimate (older version set this as default): lfcShrink()

>>> ○ LFC for all genes are first used as prior to estimate the trend, and "shrink" the LFC likelihood estimate.

>>> ○ Example: In the following figure, you can see that the green data points, which have a high likelihood for the data, are not well shrunk towards the prior.

<br>

![image](https://github.com/user-attachments/assets/64cf446c-00fe-4786-9f4e-456738690234)

**Figure 23.** DESeq fold change mode

Black line: prior
Solid line: unshrunken estimate
Dotted line: shrunken LFC estimate

<br>

>> ○ Flags outlier for each gene using Cook's distance: The distance is a metric to measure the influence of a data point in least-square analysis.

>>> ○ Small sample size: Remove gene from analysis.

>>> ○ Large sample size: If there are samples detected as outliers for a specific gene, exclude those samples from the analysis.

>> ○ Note the different preprocessing methods for obtaining DEGs and visualization.

> ② edgeR

>> ○ edgeR (exact), edgeR (GLM)

>> ○ Uses TMM normalization and negative binomial generalized linear model (GLM).

>> ○ edgeR by default filters out genes with <5 reads total to estimate a common dispersion value.

>> ○ Several options to estimate dispersion

>>> ○ Common: Uses single, common dispersion estimate. Not recommended.

>>> ○ Trended: Estimate from the trend function.

>>> ○ Tagwise: Bayesian moderated approach, similar to DESeq2.

> ③ edgeR-QLF

>> ○ Models variance as Var(y<sub>gi</sub>) = σ<sub>g</sub><sup>2</sup>(μ<sub>gi</sub> + μ<sub>gi</sub><sup>2</sup>φ) to allow for over-dispersion.

>> ○ Dispersion φ: A function of gene abundance (φ(A)), and it fits dispersion for the trend estimate for the empirical mean-variance relationship.

>> ○ σ<sub>g</sub><sup>2</sup> is a gene-specific variance (quasi-dispersion parameter). This is fit with an empirical Bayes method. A trend funciton is fit between the gene abundance and the raw QL dispersion estimates. The raw QL estimate (likelihood) then shrink towards the mean fitted trend for that abundance using the empirical Bayes approach.

>> ○ μ<sub>gi</sub> + μ<sub>gi</sub><sup>2</sup>φ (i.e. σ<sub>g</sub><sup>2</sup> = 1) corresponds to the variance of a standard negative binomial.

> ④ limma

>> ○ limma + voom ([paper](https://www.bioconductor.org/packages/devel/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html), [manual](https://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf))

>>> ○ Input: raw count (avoid using normalized data like FPKM with voom)

>>> ○ 1<sup>st</sup>. Convert read count to log CPM.

>>> ○ 2<sup>nd</sup>. Use of empirical Bayes method (eBayes(); assumes normal distribution): Removes the correlation between mean and variance present in count data.

>>> ○ 3<sup>rd</sup>. DEG exploration based on Generalized Linear Model (GLM).

>>> ○ The matrix used for obtaining DEGs is also used for visualization

>>> ○ Assumes that we can obtain better variance estimates of genes without assuming that they all have the same variance.

>>> ○ Generally is more conservative than edgeR and DESeq2. 

>> ○ limma FPKM ([paper](https://support.bioconductor.org/p/56275/), [manual](https://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf))

>>> ○ Input: FPKM (useful when raw count data is not available)

>>> ○ 1<sup>st</sup>. Convert FPKM to log2 scale

>>> ○ 2<sup>nd</sup>. Run limma's eBayes() function with the trend = TRUE option

>>> ○ This method is similar to what's used in microarray analysis and is akin to the limma-trend method

> ⑤ Sseq

> ⑥ CuffDiff: Uses FPKM values.

> ⑦ BaySeq

> ⑧ DEGSeq

> ⑨ NOISeq

> ⑩ PoissonSeq

> ⑪ SAMSeq

> ⑫ [scVI](https://www.kaggle.com/code/hiramcho/scrna-seq-differential-expression-with-scvi#4.-Differential-EXpression)

>> ○ Provides normalized expressions that remove batch effects and provides code to calculate DEGs based on them ([ref](https://www.kaggle.com/code/hiramcho/scrna-seq-differential-expression-with-scvi#4.-Differential-EXpression)).

>> ○ The provided code for calculating DEGs (Differentially Expressed Genes) is not only slow but also inaccurate: removing batch effects from 10 datasets might slightly differ from the removal in just 2 of those datasets, which can sometimes lead to completely opposite DEG patterns.

>> ○ It is recommended to use scVI normalized expression and `scanpy.tl.rank_genes_groups` to identify DEGs.

⑸ Selection of techniques

<br>

| Sample size | Count depth           |                     |                     |
|-------------|-----------------------|---------------------|---------------------|
|             | Low counts (~20 M or less) | High counts (~30 M+) |                     |
| Small (3-9)   | Bayesian count-based test (e.g., edgeR QLF, DESeq2) | Bayesian method (count-based or continuous) |                     |
| Medium (10-30) | Bayesian count-based test (e.g., edgeR QLF, DESeq2) | Count-based or continuous; possibly non-parametric |                     |
| Large (>30) | Count-based test      | Many options: count-based, continuous, non-parametric |                     |

**Table 5.** Selection of techniques

<br>

<br>

## **9. `Common 3.`** Gene Set Enrichment

⑴ Overview

> ① Definition

>> ○ Analyzing gene sets as a whole, rather than individual genes.

>> ○ [Gene Score](https://jb243.github.io/pages/2215): Refers to the value generated by a list of genes.

>> ○ Signature: A dataframe composed of gene names, FC (fold change) values, or p-values. [Gene score](https://jb243.github.io/pages/2215) can also be considered a signature.

> ② Method

>> ○ **Method 1.** ORA (Over-Representation Analysis)

>>> ○ Tests whether a specific pathway contains more DEGs than would be expected by chance.

>>> ○ Classified as a competitive test rather than a self-contained test.

>>>> ○ Self-contained test: Evaluates differential expression or specific patterns using only the gene set of interest.

>>>> ○ Competitive test: Compares the gene set of interest against the entire background set of genes to determine whether it contains a significantly higher number of genes associated with a particular pathway.

>> ○ **1-1.** [Fisher's exact test](https://jb243.github.io/pages/1690) (hypergeometric test)

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/de38ed4f-ea2b-48e4-b168-425e04641a62)

**Table 6.** Contingency table in gene set analysis

<br>

>>> ○ **Statistic 1.** Probability: Probability of being like the sample.

>>> ○ **Statistic 2.** Odds ratio: Shows if GO and Gene Set are similar or dissimilar.

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/d9dad71b-f7cb-45a8-8427-2dcd7e836106)

<br>

>>> ○ **Statistic 3.** Gene ratio: Represents A / (A+B), i.e., the ratio of common genes to the input gene set.

>>> ○ **Statistic 4.** Count: Usually represents A, the number of intersection elements between two sets.

>>> ○ An example of overrepresentation analysis.

>> ○ **1-2:** Modified Fisher's exact test (e.g., DAVID)  

<br>

<img width="311" alt="스크린샷 2025-02-26 오전 12 08 19" src="https://github.com/user-attachments/assets/cb723c2f-db8e-4ad1-a858-b355e5ce8cb7" />

**Figure 24.** Modified Fisher's exact test

<br>

>>> ○ When the number of DEGs is small, the impact is significantly reduced, whereas when the number is large, the impact is minimal.  

>>> ○ An example of overrepresentation analysis.

>> ○ **Method 2.** Gene set ranking (scoring) method

>>> ○ Tests each pathway using ranks or significance values across genes.

>>> ○ Example: GSEA, singscore 

>> ○ **Method 3.** [Network-based method](#10-common-4-gene-interaction-analysis)

> ③ Interpretation

>> ○ Rank genes based on expression between experimental and control groups, then calculate enrichment scores.

>> ○ If genes from the query gene set are highly concentrated at both extremes (e.g., top 10 or bottom 10) of the ranked gene list, the enrichment score increases.

⑵ **Type 1. [GSEA](https://www.gsea-msigdb.org/gsea/index.jsp)** (gene set enrichment analysis) ([manual](https://www.gsea-msigdb.org/gsea/doc/GSEAUserGuideFrame.html))

> ① Overview

>> ○ Non-parametric permutation-based.

>> ○ Widely used, especially with human and cancer-related data.

> ② Input

>> ○ **Type 1.** expression file (.gct or .txt): Expression values

>> ○ **Type 2.** phenotype label (.cls): Group names (e.g., control, normal)

>> ○ **Type 3.** gene annotation (.chip): Gene names

>> ○ **Type 4.** gene set data: Gene sets

>>> ○ **Category 1.** M1H: Mouse-ortholog hallmark gene sets, etc.

>>> ○ **Category 2.** M1: Positional gene sets, etc.

>>> ○ **Category 3.** M2: Curated gene sets, etc.

>>> ○ **Category 4.** M3: Regulatory target sets, etc.

>>> ○ **Category 5.** M5: Ontology gene sets, etc.

>>> ○ **Category 6.** M8: Cell type signature gene sets, etc.

> ③ Implementation

>> ○ GSEA_R: R package. Increase # of iterations to 10,000. Better for large sample sized experiments.

>> ○ Some "gsea" implementations in R (e.g., fgsea) are different.

> ④ Output

>> ○ FDR (false discovery rate)

>> ○ NES (normalized enrichment score)

>> ○ leading edge subset

> ⑤ Python code

<br>

```python
def GSEA(gene_set, expression):
    """Perform GSEA testing on a gene set and expression data set

    Args:
        gene_set (list): list of gene names in a gene set
        expression (dict): dictionary with keys of gene names and values of expression

    Returns:
        enrichment (float): enrichment score for a given gene set
        scores (list): list of running enrichment scores as genes are processed
    """
    
    # Order genes in a descending orer according to expression 
    ranked_genes = sorted(expression.items(), key=lambda x: x[1], reverse=True)
    ranked_gene_names = [gene for gene, _ in ranked_genes]
    
    N = len(ranked_gene_names)
    Nh = len(gene_set)
    Nm = N - Nh
    
    if Nh == 0 or Nm == 0:
        raise ValueError("Gene set is empty or covers the entire gene universe.")
    
    hit_score = 1.0 / Nh
    miss_score = 1.0 / Nm
    
    running_score = 0.0
    scores = []

    for gene in ranked_gene_names:
        if gene in gene_set:
            running_score += hit_score
        else:
            running_score -= miss_score
        scores.append(running_score)
    
    # Enrichment score: maximum deviation from zero
    enrichment = max(scores)
    
    return enrichment, scores


def permute_GSEA(enrichment, gene_set, expression, permutations=1000, seed=42):
    """Compute p-value for GSEA results using random permutation testing.
    
    Args:
        enrichment (float): enrichment of the gene set
        gene_set (list): list of gene names in a gene set
        expression (dict): dictionary with keys of gene set names and values of expression
        permutations (int): number of permutations
        seed (int): seed for random.sample
        
    Returns:
        p_val (float): empirical p-pvalue for enrichment
        

    """
    import numpy as np 
    import random

    observed_enrichment = GSEA(gene_set, expression)[0]
    enrichments = []
    
    random.seed(seed)
    gene_list = list(expression.keys())
    
    for _ in range(permutations):
        permuted_gene_set = random.sample(gene_list, len(gene_set))
        permuted_enrichment = GSEA(permuted_gene_set, expression)[0]
        enrichments.append(permuted_enrichment)
    
    enrichments = np.array(enrichments)
    p_val = np.sum(enrichments >= enrichment) / (permutations + 1)

    return p_val
```

<br>

⑶ **Type 2.** **GO** (gene ontology)

> ① Major bioinformatics initiative to integrate the expression of genes and gene products across all species

> ② Grouped according to CC (cellular component), MF (molecular function), BP (biological process), etc.

> ③ Evidence code: Genes are assigned to gene ontology terms using various sources of information. The source of information is stored in the evidence codes.

>> ○ **Type 1.** Experimental evidence code: Experiment (EXP), Direct assay (IDA), Physical interaction (IPI), Mutant phenotype (IMP), Genetic interaction (IGI), Expression pattern (IEP)

>> ○ **Type 2.** Computational evidence code: Sequence or structural similarity (ISS), Sequence orthology (ISO), Sequence (ISA), Sequence model (ISM), Genome context (IGC), Reviewed computational analysis (RCA)

>> ○ **Type 3.** Author statement: Traceable author statement (TAS), Non-traceable author statement (NAS)

>> ○ All but one type of evidence code is assigned by a curator; the one exception is inferred from Electronic Annotation (IEA).

> ③ Implementation: Functions implemented through [R](https://jb243.github.io/pages/2156)

<br>

```python
library(EnhancedVolcano)
library(clusterProfiler)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(enrichplot)

GO.plot <- function(gene){
    # ont = "ALL", "BP", "CC", "MF"
    # showCategory is not mandatory

    gene <- gsub("GRCh38", "", gene) # human 데이터 가공시의 reference 이름 제거
    gene <- gsub("mm10", "", gene) # mouse 데이터 가공시의 reference 이름 제거
    for(i in 1:10){
  	  gene <- gsub("-", "", gene) # 불필요한 앞부분의 - 제거
    }
    gene <- gsub('\\ .*$', '', gene) # 'KLK2 ENSG00000167751' 같은 것을 해결 
    
    if (gene[1] == toupper(gene[1])){ ## Human gene
        gene.df <- bitr(gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
        gene.df <- as.vector(gene.df[[2]])
        GO <- enrichGO(gene.df, OrgDb = 'org.Hs.eg.db',keyType = "ENTREZID", ont = "ALL", pvalueCutoff = 0.05, pAdjustMethod = "BH")
        dotplot(GO,split="ONTOLOGY", showCategory = 5)+facet_grid(ONTOLOGY~., scale="free")
	} else{ ## Mouse gene?
        gene.df <- bitr(gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
        gene.df <- as.vector(gene.df[[2]])
        GO <- enrichGO(gene.df, OrgDb = 'org.Mm.eg.db',keyType = "ENTREZID", ont = "ALL", pvalueCutoff = 0.05, pAdjustMethod = "BH")
        dotplot(GO,split="ONTOLOGY", showCategory = 5)+facet_grid(ONTOLOGY~., scale="free")
    }
}

### Example
GO.plot(c("COL1A1", "COL1A2", "COL3A1", "COL6A3"))
```

<br>

> ④ Example results

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/7e5e5ff8-c09a-4c6c-84c7-e75e6ef3f86c)

**Figure 25.** Example results of GO analysis

<br>

>> ○ **Count:** Size of the intersection between input gene set and each GO term, i.e., the number of common genes

>> ○ **p.adjust:** p value adjusted using Fisher's exact test and Benjamini-Hochberg (B&H) adjustment between input gene set and each GO term

>> ○ **GeneRatio:** Gene ratio, i.e., proportion of common genes in the input gene set ([ref](https://www.biostars.org/p/220465/))

>> ○ <span style="background-color: #ef5369; color: #ffffff; font-family: Times New Roman">▶</span> [How to interpret a GO plot](https://www.youtube.com/watch?v=hS3tBs2T3Zk) 

> ⑤ [Website](https://geneontology.org/ ) 

⑷ **Type 3.** [DAVID](https://david.ncifcrf.gov/) (functional annotation bioinformatics microarray analysis)

> ① Provides biological interpretation of submitted genes: Still works relatively well, even though developed for microarray data

> ② Use with gene expression data or genomic regions restricted to < 1-5 kb from TSS.

> ③ [How to use DAVID](https://blog.kakaocdn.net/dn/Fylqp/btsMx4vLFp3/yU6YjUIkVtMMohzo7obi51/How%20to%20Use%20DAVID.docx?attach=1&knm=tfile.docx) 

⑸ **Type 4.** [MSigDB](https://www.gsea-msigdb.org/gsea/msigdb/) (molecular signature database)

> ① Classification

>> ○ H: Hallmark gene sets (50 terms)

>> ○ C1: Positional gene sets (299 terms)

>> ○ C2: Curated gene sets (6226 terms)

>> ○ C3: Regulatory target gene sets (3556 terms)

>> ○ C4: Computational gene sets (858 terms)

>> ○ C5: Ontology gene sets (14765 terms)

>> ○ C6: Oncogenic signature gene sets (189 terms)

>> ○ C7: Immunologic signature gene sets (4872 terms)

>> ○ C8: Cell type signature gene sets (302 terms)

> ② Difference between GO and MSigDB

>> ○ GO: Many species

>> ○ MSigDB: Human-centric. Some mouse (can convert to rat)

⑹ **Type 5.** [EnrichR](https://maayanlab.cloud/Enrichr/)

> ① Performs gene set analysis using various gene set information.

> ② enrichr (R package; an online-based API) or web tool

> ③ Statistical significance calculation using Fisher's exact test and Benjamini-Hochberg (B&H) adjustment.

> ④ Shows concordance between submitted genes and other annotated gene sets

⑺ **Type 6.** [ToppGene](https://toppgene.cchmc.org/#:~:text=and%20other%20features.-,ToppGene), [ToppFun](https://toppgene.cchmc.org/#:~:text=Supported%20by%3A-,ToppFun,-%3A%20Transcriptome%2C%20ontology%2C%20phenotype), etc: Web-tool

> ① Transcriptome

> ② Proteome

> ③ Regulome (e.g., TFBS, miRNA)

> ④ Ontologies (e.g., GO, Pathway)

> ⑤ Phenotype (e.g., human disease, mouse phenotype)

> ⑥ Pharmacome (e.g., Drug-Gene associations)

> ⑦ Literature co-citation

⑻ **Type 7.** [iLINCS](http://www.ilincs.org/ilincs/): Drug database

⑼ **Type 8.** [g:Profiler](https://biit.cs.ut.ee/gprofiler/gost)

⑽ **Type 9.** [KEGG](https://www.genome.jp/kegg/mapper/color.html) (kyoto encyclopedia of genes and genomes)

> ① Biochemical pathway database created in Japan (1995)

> ② One of the most cited databases in the field of biology

> ③ Includes various information related to systems, genes, health, chemistry, etc., centered around biochemical pathways. 577 pathways.

> ④ Method: pathview Bioconductor package, [https://pathview.uncc.edu/](https://pathview.uncc.edu/), [g:Profiler](https://biit.cs.ut.ee/gprofiler/gost) (Web-based tool)

> ⑤ KEGG website allows you to color genes to show differential expression.

⑾ **Type 10.** TRRUST

⑿ **Type 11.** Metabolic Pathways

⒀ **Type 12.** REAC (reactome), WP, TF, etc.

> ① Shows pathways related to submitted genes

> ② Web-based tools: [g:Profiler](https://biit.cs.ut.ee/gprofiler/gost), [iLINCS](http://www.ilincs.org/ilincs/)

⒁ **Type 13.** IPA (ingenuity pathway analysis)

> ① Commercial software

> ② Visualizes pathways and networks through omics data

> ③ Allows identification of causal mechanisms and key factors using data

> ④ Includes information like canonical pathways, upstream regulator analysis, and updated information

⒂ **Type 14.** SPIA (signaling pathway impact analysis)

> ① Shows signaling pathway topology related to submitted genes

⒃ **Type 15.** MGI

⒄ **Type 16.** WP: Can be checked using web-based tools like [g:Profiler](https://biit.cs.ut.ee/gprofiler/gost)

⒅ **Type 17.** TF: Can be checked using web-based tools like [g:Profiler](https://biit.cs.ut.ee/gprofiler/gost)

⒆ **Type 18.** GSVA

⒇ **Type 19.** AUCell package

⒇ **Type 20.** HOMER motif analysis

⒇ **Type 21.** Gold standard method

⒇ **Type 22.** Ensembl gene

⒇ **Type 23.** UCSC knownGenes

⒇ **Type 24.** ssGSEA (single sample GSEA): ssGSEA generates enrichment scores for each sample. The ssGSEA results can then be used to look for outliers in your dataset or to compare enriched pathways among samples.

⒇ **Type 25.** singscore R package: Similar to ssGSEA. It generates enrichment scores for each sample. The results can then be used to look for outliers in your dataset or to compare enriched pathways among samples.

⒇ **Type 26.** LRpath: Web tool. Logistic regression

⒇ **Type 27.** Panther: Related to pathway.

⒇ **Type 28.** Biocarta: Related to pathway.

⒇ **Type 29.** MeSH term: Related to disease.

⒇ **Type 30.** DisGeNET: Related to disease.

⒇ **Type 31.** Cytoband 

⒇ **Type 32.** Babelomics: Web-tool

⒇ **Type 33.** clusterProfiler: R package

⒇ **Type 34.** goseq: R package. Also used for GSE analysis for spatial transcriptomics.

⒇ **Type 35.** GOrilla: Non-parametric rank-based.

⒇ **Type 36.** RNA-Enrich: Logistic regression. LRpath website

⒇ **Type 37.** [chip-enrich](http://chip-enrich.med.umich.edu/) ([example data](https://github.com/JB243/nate9389/blob/main/bin/250228_JunB-64781_peaks_hg38.bed), [R code](https://github.com/JB243/nate9389/blob/main/bin/250228_GSE_lab_code.R)): GSE analysis for ChIP-seq. For datasets with sharp peaks.

⒇ **Type 38.** [Broad-Enrich](http://broad-enrich.med.umich.edu/): Designed for histone data analysis. Also included in the chipenrich package. For broad genomic regions.

⒇ **Type 39.** GREAT (Genomic Regions Enrichment of Annotations Tool): Utilizes both binomial distribution and Fisher's exact test, reducing false positives.  

⒇ **Type 40.** iDEA: GSE analysis for scRNA-seq.  

⒇ **Type 41.** Giotto: GSE analysis for spatial transcriptomics. Uses hypergeometric test, PAGE, or rank-based test for each spot.  

⒇ **Type 42.** SPATA2: Executes the hypeR package, which uses the hypergeometric test. Can also be applied to spatial transcriptomics.

⒇ **Type 43.** [GIGSEA](https://academic.oup.com/bioinformatics/article/35/1/160/5053312): GSE analysis for GWAS  

⒇ **Type 44.** [MAGMA](http://httos/ctg.cncr.nl/software/magma): GSE analysis for GWAS  

⒇ **Type 45.** i-GSE4GWAS: GSE analysis for GWAS  

⒇ **Type 46.** **gometh** function in the missmethyl package: GSE analysis for CpG sites

⒇ **Type 47.** Camera (Correlation Adjusted Mean Rank Analysis)

⒇ **Type 48.** Seq2pathway: R/Bioconductor package

⒇ **Type 49.** GREAT(genomic regions enrichment of annotations tool): Has very inflated type 1 error.

<br>

<br>

## **10. `Common 4.`** Gene Interaction Analysis

⑴ **Type 1.** [Cell-cell interaction](https://jb243.github.io/pages/841)(CCI, ligand-receptor interaction)

> ① Principle: Interaction between ligand and receptor in two cells when one cell has high ligand expression and the other has high receptor expression

> ② bulk-RNA-seq-based

>> ○ [BulkSignalR](https://github.com/jcolinge/BulkSignalR) 

>> ○ squidy

>> ○ IPA (upstream regulator analysis of ingenuity pathway analysis)

>> ○ Omnipath: Refer [here](https://jb243.github.io/pages/1892#10-bioinformatics) for the code that outputs all ligand-receptor pairs containing a specific gene.

> ③ scRNA-seq-based

>> ○ [CellTalkDB](https://github.com/ZJUFanLab/CellTalkDB) ([human DB file](https://blog.kakaocdn.net/dn/czeZZx/btsjBsLASyx/No0QweqLHKVRlu0CgKKe2K/CellTalkDB_human.csv?attach=1&knm=tfile.csv), [mouse DB file](https://blog.kakaocdn.net/dn/chmMJS/btsjD8lDfej/yeVXUQmw72FiJktVjRZgK1/CellTalkDB_mouse.csv?attach=1&knm=tfile.csv))

>> ○ [CellPhoneDB](https://www.nature.com/articles/s41596-020-0292-x) ([tutorial](https://nate9389.tistory.com/2088))

>> ○ [CellChat](https://nate9389.tistory.com/841#footnote_link_67_52) ([DB file](https://blog.kakaocdn.net/dn/rWlGz/btsNcXaZMTZ/a244WkSdoNJKK5kXAwZDL0/all_interacting_LR.csv?attach=1&knm=tfile.csv); 359 unique interaction, 13284 possible combination)

>> ○ ICELLNET

>> ○ [NicheNet](https://nate9389.tistory.com/168)

>> ○ SoptSC

>> ○ CytoTalk

>> ○ scTensor

>> ○ CCCExplorer

>> ○ Connectome

>> ○ Ramilowski

>> ○ [FlowSig](https://pubmed.ncbi.nlm.nih.gov/39187683/): Graphical causal modeling (completed partial directed acyclic graph; CPDAG), Conditional independence test 

>> ○ scSeqComm: LR pairs from Reactome + TTRUST + RegNetwork

> ④ ST-based

>> ○ Giotto

>> ○ spata2

>> ○ CellPhoneDB v3

>> ○ stLearn

>> ○ SVCA

>> ○ MISTy

>> ○ NCEM

>> ○ [COMMOT](https://www.nature.com/articles/s41592-022-01728-4): Uses [optimal transport](https://jb243.github.io/pages/2386).

>> ○ [SCOTIA](https://pubmed.ncbi.nlm.nih.gov/37425692/): In addition to the [optimal transport theorem](https://jb243.github.io/pages/2386), it also considers physical distance for greater accuracy

>> ○ [STopover](https://github.com/bsungwoo/STopover): Employs diffusion and Jaccard index

>> ○ [cytosignal](https://github.com/welch-lab/cytosignal) 

>> ○ [SpatialDM](https://github.com/StatBiomed/SpatialDM) 

>> ○ SpaTalk

>> ○ stMLnet

>> ○ HoloNet

>> ○ DeepLinc

> ⑤ [Protein-protein interaction](https://jb243.github.io/pages/2085#2-protein-protein-interaction-ppi-molecular-docking)(PPI, molecular docking)

>> ○ AlphaFold2 multimer, [AFM-LIS](https://github.com/flyark/AFM-LIS), [AlphaFold3](https://alphafoldserver.com/)

>> ○ DeepDTA

>> ○ DeepDTAF

>> ○ DeepFusionDTA

>> ○ GraphDTA

>> ○ [CAPLA](https://academic.oup.com/bioinformatics/article/39/2/btad049/6998204)

>> ○ GNINA

>> ○ SMINA

>> ○ GLIDE

>> ○ EquiBind

>> ○ TANKBind

>> ○ DIFFDOCK

⑵ **Type 2.** Network analysis: Gene-wide association study (GWAS), protein-protein interaction (PPI), etc.

> ① **2-1.** Biological Network Construction

>> ○ **Type 1.** Gene Regulatory Network  

>> ○ **Type 2.** Protein-Protein Interaction Network  

>> ○ **Type 3.** Co-expression Network  

>> ○ It is possible to construct networks based on biological interaction or gene expression data.  

>> ○ After constructing the network, it is possible to identify biologically important genes using various network measures/metrics.  

> ② **2-2.** Regulatory Network Analysis

>> ○ Uses lasso-like equations such as `min |y - βX| + λ|β|`.

>> ○ An algorithm that calculates edge agreement in protein-protein networks, gene expression networks, and TF-target gene networks.  

>> ○ Builds a network by updating regulatory network edges between TF and target genes.  

>> ○ Identifies group differences based on gene-gene interactions.  

>> ○ Gene expression regulation mechanism 

>>> ○ Regulation of transcription initiation frequency

>>> ○ Regulation of transcription elongation

>>> ○ Alternative transcriptional initiation (ATI)

>>> ○ Alternative splicing (AS)

>>> ○ Alternative polyadenylation (APA)

>>> ○ RNA degradation by RNA Interference (RNAi)

>>> ○ Interference of RNAi by long noncoding RNA (lncRNA)

>>> ○ Translation initiation regulation

>>> ○ Chromosome remodeling and epigenetic regulation

> ③ **2-3.** Sample-Specific Network

>> ○ Proposes methods to construct biological networks for individual samples rather than using data from all samples or constructing group-based networks.  

>> ○ Through this, it is possible to discover differences in genes affected by specific genes in individual patients.  

> ④ **2-4.** Module / Community Detection

>> ○ Assumes that networks consisting of biological components are not random but are composed of modules performing specific functions.  

>> ○ Assumes that nodes (e.g., genes) within a biological network form communities (e.g., pathways).  

>> ○ Can perform community/module detection, a network analysis technique.  

>> ○ Detected modules/communities can be biologically interpreted through GSEA analysis.  

> ⑤ **2-5.** Hub gene detection 

>> ○ Types of Networks: Degree Centrality, Betweenness Centrality, Closeness Centrality, Eigenvector Centrality, Participation Coefficient, Pagerank

>> ○ Extracting Core Genes within Modules/Communities through Various Metrics for Finding Hubs in Network Analysis Techniques

> ⑥ **Example 1.** [ToppNet](https://toppgene.cchmc.org/#:~:text=training%20gene%20list.-,ToppNet,-%3A%20Relative%20importance%20of): Identifies relative importance of candidate genes within a network.  

> ⑦ **Example 2.** [ToppGenet](https://toppgene.cchmc.org/#:~:text=protein%20interaction%20network.-,ToppGenet,-%3A%20Prioritization%20of%20neighboring): Ranks neighboring genes within a protein-protein interaction network.  

> ⑧ **Example 3.** [GeneMANIA](http://genemania.org/search/homo-sapiens/): Shows functionally similar genes using genomics and proteomics data.  

> ⑨ **Example 4.** SCINET: Uses scRNA-seq algorithms.  

> ⑩ **Example 5.** MEAGA(minimum distance-based enrichment analysis for genetic association): Employs the fact that genes from susceptibility loci in the disease-associated function/pathway are closer with each other in biological interactome.

> ⑪ **Example 6.** [X2K](https://maayanlab.cloud/X2K/): Displays upstream regulatory networks.  

> ⑫ **Example 7.** WGCNA: TOM-based clustering.  

> ⑬ **Example 8.** Louvain / Leiden algorithm: Modularity-based clustering

> ⑭ **Example 9.** IPA (Ingenuity Pathway Analysis): upstream regulator analysis of ingenuity pathway analysis

> ⑮ **Example 10.** CCCExplorer

> ⑯ **Example 11.** Connectome

> ⑰ **Example 12.** squidy

> ⑱ **Example 13.** spata2

> ⑲ **Example 14.** ALIGATOR: Analyzes whether genes associated with GWAS are excessively represented in specific pathways. Targets gene sets (GO, KEGG). Ensures uniqueness and applies multiple testing correction.

> ⑳ **Example 15.** INRICH: Analyzes whether gene sets are excessively clustered at specific locations. Uses permutation-based testing.

> ㉑ **Example 16.** DAPPLE: Analyzes whether genes are excessively connected within the PPI network. Evaluates connectivity in actual networks versus random networks.

> ㉒ **Example 17.** PiNET: Evaluates whether disease-associated genes are excessively connected within the protein-protein interaction (PPI) network. It annotates, maps, and analyzes the peptide moiety.

⑶ **Type 3.** TF (Transcription Factor) Analysis

> ① Overview  

>> ○ RNA polymerase in eukaryotic organisms cannot bind to the promoter alone.  

>> ○ When general transcription factors and specific transcription factors bind to various regulatory sequences upstream of the gene (e.g., TATA, CAAT), RNA polymerase can initiate transcription.  

>> ○ The number of transcription factors is approximately 1,600.  

>> ○ **Pioneer factor**: A special transcription factor that can bind even when chromatin is in a closed state. It is the first transcription factor to bind and is much less common.  

>> ○ **CTCF transcription factor**: Binds to DNA for a longer duration (~several minutes) compared to other TFs.  

> ② Algorithm  

>> ○ FigR

>> ○ scGRNom

>> ○ scREMOTE

>> ○ Triangulate

>> ○ SCENIC

>> ○ DeepSEM

>> ○ Inferelator

>> ○ Sc-compReg

>> ○ BITFAM

>> ○ Dorothea

<br>

<br>

## **11. `Common 5.`** Cell Type Mapping Analysis

⑴ [General cell type annotation](https://jb243.github.io/pages/1782)

> ① Purpose

>> ○ **Significance 1.** Cell type analysis in scRNA-seq and in-depth analysis of ROI in ST can effectively mitigate batch effects caused by sample selection bias.

>> ○ **Significance 2.** Analyzing based on cell types rather than gene expression analysis makes the results easier to understand.

> ② **Method 1.** Clustering-based

>> ○ Definition: Clustering scRNA-seq data and then labeling cell types based on the differential expression of genes within each cluster.

>> ○ **Drawback 1.** Divided by resolution parameter: Not all cells in the same cluster necessarily belong to the same cell type.

>> ○ **Drawback 2.** Cells of the same type might be split into different clusters depending on their states.

>> ○ **Drawback 3.** Comparing cell type labels across different platforms is challenging (e.g., immune cell vs DC vs cDC)

> ③ **Method 2.** Meta-tagging

>> ○ Definition: Attaching multiple cell types to a cell based on scores or multiple rounds of clustering.

>> ○ Example: Labeling a single cell as immune cell, DC, and cDC simultaneously.

> ④ **Method 3.** Foundation Model Approach - Using [language models](https://jb243.github.io/pages/2404) to create a single labeler for specifying cell types.

>> ○ [GeneFormer](https://huggingface.co/ctheodoris/Geneformer): Based on BERT. Uses a transformer encoder-based architecture. Utilized with a pretraining → finetuning approach. Zero-shot capabilities are practically useless.

>> ○ [scGPT](https://www.nature.com/articles/s41592-024-02201-0): Based on GPT. Uses a transformer decoder-based architecture. Utilized with a pretraining → finetuning approach. The zero-shot performance of the pretraining model is also quite excellent.

>> ○ [GenePT](https://www.biorxiv.org/content/10.1101/2023.10.16.562533v2.full) and [Simple use of GPT-4](https://www.nature.com/articles/s41592-024-02235-4?fbclid=IwAR1v-I9ax-44NtsrNrlf7UxRaVCZrSe1LOzykOStZY4-RBlnFbfD-2jqXlw_aem_AUbIEUfFx21RQN4K1IAKF3qlboOatFmNvov6it3MUsqdQeDFd1ncuiL2pXDwff665_U)

>> ○ [UCE](https://github.com/snap-stanford/UCE/tree/main) (Universal Cell Embeddings)

>> ○ [scfoundation](https://github.com/microsoft/zero-shot-scfoundation)

>> ○ [CELLama](https://www.biorxiv.org/content/10.1101/2024.05.08.593094v1) 

⑵ Bulk RNA-seq

> ① [xCell](https://github.com/dviraran/xCell): Based on R. Defines weights for each human gene.

> ② [immunedeconv](https://github.com/omnideconv/immunedeconv): A benchmarking algorithm based on R.

>> ○ For human data: Modes available include `quantiseq`, `timer`, `cibersort`, `cibersort_abs`, `mcp_counter`, `xcell`, `epic`, `abis`, `consensus_tme`, and `estimate`.

>> ○ For mouse data: Modes available include `mmcp_counter`, `seqimmucc`, `dcq`, and `base`.

> ③ BayesPrism: Bayesian algorithm. Requires a scRNA-seq reference.

⑶ scRNA-seq (Single-cell RNA sequencing)

> ① [Seurat](https://jb243.github.io/pages/1788): Based on R. Employs a method called 'Label Transfer.'

> ② scanpy: Python-based, especially related to cell type analysis through ingest.

> ③ [Scanorama](https://www.nature.com/articles/s41587-019-0113-3): Python-based.

> ④ [sc-type](https://github.com/IanevskiAleksandr/sc-type): Based on R. Utilizes [pre-defined gene sets](https://jb243.github.io/pages/1846#:~:text=%E2%91%BC-,Data%203,-.%20Refer%20to) for each cell type. Semi-automation 

> ⑤ [celltypist](https://github.com/Teichlab/celltypist) and [celltypist2](https://github.com/Teichlab/celltypist): Python-based. Saving pre-defined references in a .pkl file.

> ⑥ [scTab](https://www.nature.com/articles/s41467-024-51059-5) 

> ⑦ SELINA

> ⑧ Spoint 

> ⑨ Tangram

> ⑩ TACCO

> ⑪ InsituType 

> ⑫ Symphony

> ⑬ SingleR: Automated cell-type annotation tool 

> ⑭ scPred: Automated cell-type annotation tool 

⑷ ST (Spatial Transcriptomics)

> ① [CellDART](https://github.com/mexchy1000/CellDART) and [spSeudoMap](https://github.com/bsungwoo/spSeudoMap)

> ② [RCTD](https://jb243.github.io/pages/2109): Based on R.

> ③ MIA analysis: Includes both [enrichment](https://jb243.github.io/pages/2156#:~:text=MIA%20assay%20(enrichment)) and [depletion](https://jb243.github.io/pages/2156#:~:text=MIA%20assay%20(depletion)) analyses.

> ④ [Cell2location](https://github.com/BayraktarLab/cell2location)

> ⑤ SPOTlight

> ⑥ DSTG

> ⑦ [CellTrek](https://www.nature.com/articles/s41587-022-01233-1): After co-embedding scRNA-seq and ST, it performs cell type labeling using a distance-based graph and random forest.

> ⑧ CytoSpace

> ⑨ Tangram

> ⑩ BayesPrism 

> ⑪ DestVI 

> ⑫ Stereoscope

<br>

<br>

## **12. `Advanced 1.`** Alternative Splicing Analysis (AS Analysis)

⑴ Overview

> ① AS analysis can be conducted using existing data with splice-aware aligners.

> ② However, with the emergence of [long-read sequencing](https://jb243.github.io/pages/75#:~:text=%E2%91%A0-,long%2Dread%20sequencing,-%3A%202022%EB%85%84), chosen as the technology of the year in 2022, more accurate analysis becomes possible.

⑵ **Long-Read Sequencing**

> ① Fewer sequencing gaps compared to short-read sequencing.

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/19536c31-cd8f-4fbb-bde9-fa617c746ba9)

**Figure 26.** Long-Read Sequencing vs. Short-Read Sequencing

<br>

> ② **Advantage 1.** AS Analysis: Enables identification of alternative splicing events and isoforms.

> ③ **Advantage 2.** Facilitates the integration of epigenetics and transcriptomics.

> ④ **Example 1.** Pacific Biosciences SMRT (Single Molecule Real-Time) Sequencing: Average read length is ~20 kb.

> ⑤ **Example 2.** Oxford Nanopore Sequencing: Average read length is ~100 kb.

⑶ (Reference) Alternative Splicing Event

> ① **SE (Skipped Exon)**: Entire specific exon is either included or excluded.

> ② **A5SS (Alternative 5' or 3' Splice Site)**: Different usage of 5' or 3' splice junctions of an exon, not the whole exon.

> ③ **MXE (Mutually Exclusive Exon)**: Exclusively spliced exon when another exon is spliced and vice versa.

> ④ **RI (Retained Intron)**: Intron not coding for amino acids is retained or spliced.

⑷ (Reference) Exon Sequencing: Often contrasted with gene sequencing.

> ① Exon symbols examples:

>> ○ chr15:63553600-63553679:-

>> ○ chr15:56967876-56968046:-

>> ○ chr7:7601136-7601288:+

>> ○ chr11:220452-220552:-

> ② Gene symbol examples:

>> ○ Human Genes: SIRPA, HBB-BS, etc.

>> ○ Mouse Genes: Sirpa, Hbb-bs, etc.

⑸ **Type 1.** Event-Based AS Quantification: Quantification by dividing into exons using a count-based model.

> ① PSI Value: Quantifies PSI for each exon event.

>> ○ Quantifies AS events using Percent-Splice-In (PSI) value.

>> ○ PSI value = inclusion reads / (inclusion reads + exclusion reads)

>> ○ Representative Tool: rMATs

> ② Exon Usage: Analyzed based on exon counts.

>> ○ Reads can be classified into exon reads and junction reads based on mapped regions.

>> ○ Exon reads: Mapped reads within exon regions.

>> ○ Junction reads: Mapped reads at splice junctions.

>> ○ Exon reads are counted per exon for exon usage (exon-level expression) calculation.

>> ○ Representative Tool: DEXseq

⑹ **Type 2.** Isoform-Based AS Quantification

> ① Definition: Estimate expression of each isoform transcript at the transcript level using statistical models.

> ② Purpose: Improved efficacy in constraints, diagnostics, etc., if target isoforms can be defined.

> ③ Representative Tool: RSEM

> ④ Databases Used for Isoform Exploration

>> ○ [UniProt](https://www.uniprot.org/): Most well-known protein-related database.

>> ○ [Ensembl](https://asia.ensembl.org/Homo_sapiens/Transcript/)

>> ○ [Reactome](https://reactome.org/)

>> ○ [GPP Web Portal](https://portals.broadinstitute.org/gpp/public/)

>> ○ [NCBI Genome Data Viewer](https://www.ncbi.nlm.nih.gov/genome/gdv/?org=homo-sapiens)

>> ○ NCBI assembly ([example](https://www.ncbi.nlm.nih.gov/assembly/GCF_000006945.2/?shouldredirect=false)): Execute code targeting [FASTA and GTF files](https://jb243.github.io/pages/2070) (_e.g._, pyfaidx)

<br>

<br>

## **13. `Advanced 2.`** Trajectory Analysis

⑴ Overview 

> ① CNV (copy number variation): Abnormal number of chromosomes caused by cell division abnormalities. Refers to chromosome deletion or aneuploidy.

> ② SNP (single-nucleotide polymorphism): A difference in specific nucleotide sequences.

> ③ This is only possible with direct sequencing methods (e.g., Visium FF, scRNA-seq), not with probe-based methods (e.g., Visium FFPE).

> ④ In CNV analysis, p refers to the short arm, and q refers to the long arm.

⑵ CNV Analysis Algorithms 

> ① CopywriteR: WGS-based. Analyzes off-target read depth.

> ② CNVkit: WGS-based. Analyzes deviations in read depth.

> ③ ASCAT: WGS-based

> ④ Ginkgo: scDNA-seq-based. Analyzes deviations in read depth.

> ⑤ InferCNV: scRNA-seq-based.

> ⑥ CopyKat: scRNA-seq-based.

> ⑦ Clonalscope: scRNA-seq-based.
 
> ⑧ CONICSmat: scRNA-seq-based.

> ⑨ HoneyBADGER: scRNA-seq-based.

> ⑩ CaSpER: scRNA-seq-based.

> ⑪ Numbat: scRNA-seq-based.

> ⑫ SpatialInferCNV: ST-based.

> ⑬ SPATA: ST-based.

> ⑭ STmut: ST-based.

> ⑮ STARCH: ST-based.

> ⑯ [CalicoST](https://www-nature-com.proxy.lib.umich.edu/articles/s41592-024-02438-9): ST-based.

<br>

![image](https://github.com/user-attachments/assets/68ff6323-61ca-4fba-91f4-b8f7cc1285b0)

**Table 7.** Summary of CNV Analysis Algorithms

<br>

> ⑮ Problems with InferCNV and CopyKat in contrast to Numbat ([ref](https://kharchenkolab.github.io/numbat/articles/numbat.html))

>> ○ Q: There seems to be a global baseline shift in the CNV profile produced by Numbat as compared to my other CNV callers; specifically, Numbat calls gains for the segments that appear to be neutral in other analyses, and neutral for segments that appear to be losses.

>> ○ A: Many existing methods (e.g. InferCNV/CopyKAT) infer copy number variations relative to the median ploidy, which can dilute signals of aberrant regions or mistake neutral regions for aberrant due to baseline shifts caused by hyperdiploidy or hypodiploidy. Instead, Numbat first tries to identify diploid regions based on allele evidence (balanced allelic frequencies), and uses these regions as baseline for CNV calling.

⑶ SNP Analysis Algorithms 

> ① Sniffle, Sniffle2: long-read DNA-seq-base 

> ② SCmut: scRNA-seq-based.

> ③ scSNV: scRNA-seq-based.

> ④ SComatic: scRNA-seq-based.

> ⑤ STmut: ST-based.

⑷ Repetitive Sequence Analysis Algorithm

> ① Overview: In the genome reference, repetitive sequences are either N-masked or converted to lowercase.

> ② Experimental Methods  

>> ○ Southern Blotting  

>> ○ Sanger Sequencing  

> ③ Tandem Repeat Identification Algorithms  

>> ○ RepeatMasker  

>> ○ Tandem Repeats Finder  

>> ○ HipSTR: Based on Illumina sequencing data  

>> ○ ExpansionHunter: Based on Illumina sequencing data  

>> ○ RepeatHMM: Long-read sequence-based STR detection  

>> ○ STRique: Long-read signal-based STR detection  

>> ○ DeepRepeat: Converts raw electrical signals from long-read sequencing data into images and applies CNN  

⑸ Trajectory analysis pipeline 

> ① gene expression along pseudotime: Monocle ([ref1](https://doi.org/10.1038%2Fnbt.2859), [ref2](https://doi.org/10.1038%2Fnmeth.4402), [ref3](https://doi.org/10.1038%2Fs41586-019-0969-x)), TSCAN ([ref](https://doi.org/10.1093%2Fnar%2Fgkw430)), Slingshot ([ref](https://doi.org/10.1186%2Fs12864-018-4772-0)), PAGA, scEpath, stLearn, [SpaceFlow](https://github.com/hongleir/SpaceFlow), [SIRV](https://github.com/tabdelaal/SIRV), PHATE (Potential of Heat-diffusion for Affinity-based Trajectory Embedding)

> ② cell abundance along pseudotime: milo ([ref](https://pubmed.ncbi.nlm.nih.gov/34594043/)), DAseq ([ref](https://pubmed.ncbi.nlm.nih.gov/34001664/))

> ③ trajectory lineage: tradeSeq ([ref](https://doi.org/10.1038%2Fs41467-020-14766-3)), LinRace ([ref](https://www.nature.com/articles/s41467-023-44173-3)), SCORPIUS (for scRNA-seq) ([ref](https://github.com/rcannood/SCORPIUS))

> ④ Trajectory analysis in samples from different batches: Phenopath ([ref](https://doi.org/10.1038%2Fs41467-018-04696-6)), Condiments ([ref](https://doi.org/10.1101/2021.03.09.433671)), Lamian ([ref](https://www.nature.com/articles/s41467-023-42841-y))

> ⑤ RNA velocity (spliced vs unspliced): Velocyte, scVelo, STARsolo, dynamo, MultiVelo ([ref](https://www.nature.com/articles/s41587-022-01476-y.epdf?sharing_token=M2W6sq3MAWKunZfbSAytONRgN0jAjWel9jnR3ZoTv0OdGj1T8B8MFii0PR-J_XYmuYFJPW-ydKHESAJwtpQYdR1tFvy_dcsDI4ppX8nSdJL5UwvaNk5U--STVGpJ48A8gQyjyqY1EJgOJykui6AJ55Qoo3IPqLjsw6Dbez0nJ3Q%3D)), SPATA (ST-based)

> ⑥ HMRF(hidden Markov random field): Startle (ST-based)

⑹ Phasing

> ① Definition: The process of mapping each RNA transcript to either the paternal or maternal chromosome, or at least to distinguishable haplotypes.

<br>

![image](https://github.com/user-attachments/assets/f55c38a7-3e15-4868-9553-3e26cbd0fa9d)

**Table 8.** The principle of phasing

<br>

> ② Primarily studied in F1 hybrid mouse models: RNA transcripts are mapped to each haplotype individually or to a combined reference based on SNPs.

> ③ Types of RNA-seq phasing: [Lapels and Suspender pipeline](https://github.com/holtjma/suspenders/wiki/Lapels-and-Suspenders-Pipeline), Eagle2, SHAPEIT, WhatsHap.

> ④ Types of Hi-C phasing: HARP, HaploHiC, ASHIC, HiCHap (Ohm).

⑺ [ecDNA](https://jb243.github.io/pages/74)

> ① Detection via FISH: Corresponds to experimental methods.

> ② Detection via long-read sequencing: Decoil, CoRAL, AmpliconArchitect, AmpliconClassifier.

> ③ Detection via Hi-C: EagleC, NeoLoopFinder.

⑻ HMM (Hidden Markov Model)

> ① χ = {X<sub>i</sub>} is a Markov process and Y<sub>i</sub> = ϕ(X<sub>i</sub>) (where ϕ is a deterministic function), then y = {Y<sub>i</sub>} is a Hidden Markov Model.

> ② **Baum-Welch Algorithm**

>> ○ Purpose: Learning HMM parameters

>> ○ Input: Observed data (e.g., list of DNA sequences)

>> ○ Output: Initial probabilities, state transition probabilities, and emission probabilities of HMM

>> ○ Principle: A type of EM (Expectation Maximization) algorithm

>> ○ Formula 

>>> ○ B<sub>k</sub>: Initial probability for state k

<br>

<img width="246" alt="스크린샷 2025-03-14 오전 8 50 24" src="https://github.com/user-attachments/assets/bb99bb11-f2d6-4289-9a16-1ff33069bbb1" />

<br>

>>> ○ A<sub>kl</sub>: Number of transition from state k to l

<br>

<img width="393" alt="스크린샷 2025-03-14 오전 8 49 40" src="https://github.com/user-attachments/assets/2e925cf9-9c40-444a-91b6-11c220c53dc4" />

<br>

>>> ○ E<sub>k</sub>(b): Number of emissions of observation b from state k 

<br>

<img width="322" alt="스크린샷 2025-03-14 오전 8 50 03" src="https://github.com/user-attachments/assets/d9b1ff2c-8f77-494b-a877-d310d61f8b80" />

<br>

> ③ **Viterbi Algorithm** ([ref](http://www.mcb111.org/w06/durbin_book.pdf))

>> ○ Purpose: Find the most likely hidden state sequence given an HMM

>> ○ Input: HMM parameters and observed data

>>> ○ N: Number of possible hidden states

>>> ○ T: Length of observed data

>>> ○ A: State transition probability, a<sub>kl</sub> = probability of transitioning from state k to state l

>>> ○ E: Emission probability, e<sub>k</sub>(x) = probability of observing x in state k

>>> ○ B: Initial state probability

>> ○ Output: Most probable state sequence

>> ○ Principle: Uses dynamic programming to compute the optimal path

<br>

![image](https://github.com/user-attachments/assets/df178273-719f-4b32-b358-d519220704e4)

<br>

>> ○ **Step 1.** Initialization

<br>

<img width="229" alt="스크린샷 2025-02-25 오후 10 32 04" src="https://github.com/user-attachments/assets/7052ecde-8df0-400a-a125-7f4b29469018" />

<br>

>>> ○ b<sub>k</sub>: Initial probability of state k, P(s0 = k)

>>> ○ e<sub>k</sub>(σ): Probability of observing the first observation σ in state k, P(x<sub>0</sub> | s<sub>0</sub> = k)

>> ○ **Step 2.** Recursion

>>> ○ Compute maximum probability from the previous state at each time step i = 1, ..., T

<br>

<img width="291" alt="스크린샷 2025-02-25 오후 10 32 46" src="https://github.com/user-attachments/assets/9ef4d062-dddc-4496-ad1d-8dae4c2f05de" />

<br>

>>> ○ Compute backpointer (ptr) storing the most probable previous state

<br>

<img width="291" alt="스크린샷 2025-02-25 오후 10 33 01" src="https://github.com/user-attachments/assets/351dfb0c-7f3d-4949-883f-d16a7f34af21" />

<br>

>>> ○ ptr<sub>i</sub>(l) serves to store the previous state k that has the highest probability of transitioning to the current state l.

>> ○ **Step 3.** Termination

>>> ○ Select the highest probability at the final time step

<br>

<img width="243" alt="스크린샷 2025-02-25 오후 10 34 15" src="https://github.com/user-attachments/assets/d7211923-2c9d-499a-9917-7b9fee1b34b9" />

<br>

>>> ○ Determine the last state of the optimal sequence

<br>

<img width="223" alt="스크린샷 2025-02-25 오후 10 34 32" src="https://github.com/user-attachments/assets/82218707-8776-4d83-b228-b55b1419a3b6" />

<br>

>>> ○ v<sub>k</sub>(i - 1): Optimal probability at previous time step i - 1 in state k

>>> ○ a<sub>kl</sub>: Probability of transitioning from state k to l

>> ○ **Step 4.** Traceback

>>> ○ Trace back through ptr array from i = T, ..., 1 to recover the optimal path

<br>

<img width="154" alt="스크린샷 2025-02-25 오후 10 34 55" src="https://github.com/user-attachments/assets/516197ed-77f4-461e-98ce-f13fbbaf587f" />

<br>

>> ○ Example

<br>

![image](https://blog.kakaocdn.net/dn/nKnMO/btsMvUfkPcP/7YrFhrnIeBARENfxO3x1t1/img.gif)

 **Figure 27.** Example of Viterbi Algorithm

<br>

>> ○ Python Code

<br>

```python
class HMM(object):
    def __init__(self, alphabet, hidden_states, A=None, E=None, B=None):
        self._alphabet = set(alphabet)
        self._hidden_states = set(hidden_states)
        self._transitions = A
        self._emissions = E
        self._initial = B
        
    def _emit(self, cur_state, symbol):
        return self._emissions[cur_state][symbol]
    
    def _transition(self, cur_state, next_state):
        return self._transitions[cur_state][next_state]
    
    def _init(self, cur_state):
        return self._initial[cur_state]

    def _states(self):
        for k in self._hidden_states:
            yield k

    def draw(self, filename='hmm'):
        nodes = list(self._hidden_states) + ['β']

        def get_children(node):
            return self._initial.keys() if node == 'β' else self._transitions[node].keys()

        def get_edge_label(pred, succ):
            return (self._initial if pred == 'β' else self._transitions[pred])[succ]
        
        def get_node_shape(node):
            return 'circle' if node == 'β' else 'box'
            
        def get_node_label(node):
            if node == 'β':
                return 'β'
            else:
                return r'\n'.join([node, ''] + [
                    f"{e}: {p}" for e, p in self._emissions[node].items()
                ])

        graphviz(nodes, get_children, filename=filename,
                 get_edge_label=get_edge_label,
                 get_node_label=get_node_label,
                 get_node_shape=get_node_shape,
                 rankdir='LR')
        
    def viterbi(self, sequence):
        trellis = {} 
        traceback = [] 
        for state in self._states():
            trellis[state] = np.log10(self._init(state)) + np.log10(self._emit(state, sequence[0])) 
            
        for t in range(1, len(sequence)):
            trellis_next = {}
            traceback_next = {}

            for next_state in self._states():  
                k={}
                for cur_state in self._states():
                    k[cur_state] = trellis[cur_state] + np.log10(self._transition(cur_state, next_state)) 
                argmaxk = max(k, key=k.get)
                trellis_next[next_state] =  np.log10(self._emit(next_state, sequence[t])) + k[argmaxk] 
                traceback_next[next_state] = argmaxk
                
            trellis = trellis_next
            traceback.append(traceback_next)
            
        max_final_state = max(trellis, key=trellis.get)
        max_final_prob = trellis[max_final_state]
                
        result = [max_final_state]
        for t in reversed(range(len(sequence)-1)):
            result.append(traceback[t][max_final_state])
            max_final_state = traceback[t][max_final_state]
            
        return result[::-1]
```

<br>

> ④ **Type 1.** PSSM: Simpler HMM structure

> ⑤ **Type 2.** Profile HMM: It is advantageous over PSSMs regarding the following: 

>> ○ Diagram of profile HMM

<br>

![image](https://github.com/user-attachments/assets/0085c0b3-ed15-4c48-9ab9-23105cf29d30)

**Figure 28.** Diagram of profile HMM 

<br>

>>> ○ M, I, and D represent match, insertion, and deletion, respectively.

>>> ○ M<sub>i</sub> can be transitioned to M<sub>i+1</sub>, I<sub>i</sub>, and D<sub>i+1</sub>.

>>> ○ I<sub>i</sub> can be transitioned to M<sub>i+1</sub>, I<sub>i</sub>, and D<sub>i+1</sub>.

>>> ○ D<sub>i</sub> can be transitioned to M<sub>i+1</sub>, I<sub>i</sub>, and D<sub>i+1</sub>.

>> ○ **Advantage 1.** The ability to model insertions and deletion

>> ○ **Advantage 2.** Transitions are restricted only between valid state traversal.

>> ○ **Advantage 3.** Boundaries between states are better defined.

>> ○ **Example 1.** [HMMER](http://hmmer.org/) 

>>> ○ `hmmbuild`: Creates a profile HMM from a set of aligned sequences.

>>> ○ `hmmalign`: Aligns a sequence to a profile HMM.

>>> ○ `hmmsearch`: Aligns a profile HMM against a sequence database.

>>> ○ `hmmsca`: Aligns sequences against a database of profile HMMs.

>> ○ **Example 2.** HMMSTR

>> ○ **Example 3.** SAM(sequence alignment and modeling)

>> ○ **Example 4.** [Pfam](https://pfam.sanger.ac.uk/)

>>> ○ A large collection of protein families, each represented by multiple sequence alignments and profile HMMs.

>>> ○ Pfam-A: A high quality, manually curated set of family profiles.

>>> ○ Pfam-B: A lower quality set of families identified through automated means (ADDA).

<br>

<br>

## **14. `Advanced 3.`** Epigenomics Analysis

⑴ **Type 1.** [Gene Function Identification](https://jb243.github.io/pages/1431#footnote_link_67_50)

> ① Types of sequencing

>> ○ Perturb-seq: Treating Cas9 expressing cells with different gRNA libraries, followed by simultaneous sequencing of gRNA and mRNA.

>> ○ in vivo Perturb-seq

> ② DEG analysis algorithm for perturb-seq

>> ○ CEDA 

>> ○ MAGeCK RRA 

>> ○ MAGeCK MLE 

>> ○ Gscreen 

>> ○ BAGEL2 

>> ○ Common 

> ③ Single-cell perturbation prediction

>> ○ scGen: Based on VAE

>> ○ scPreGAN: Based on GAN

>> ○ scVAEDer: Combination of VAE and DDN (a state-of-the-art diffusion model)

>> ○ GeneFormer: Foundation model based on LLM

⑵ **Type 2.** [Transcription Regulation Identification](https://jb243.github.io/pages/1431#footnote_link_67_51)

> ① Types of sequencing

>> ○ BS-seq (Bisulfite Sequencing): Identifying methylation patterns.

>> ○ ChIP-seq (Chromatin Immunoprecipitation Sequencing): Identifying binding sites of transcription factors.

>> ○ Hi-C (High Throughput Chromatin Conformation Capture Sequencing): 3D folding structure information of nuclear chromatin.

>> ○ DNA Ticker Tape (Prime Editing)

>> ○ ENGRAM (Enhancer-Driven Genomic Recording of Transcriptional Activity in Multiplex)

>> ○ ATAC-seq

>> ○ NOMe-seq (Nucleosome Occupancy and Methylome Sequencing)

>> ○ MBD-seq

>> ○ Ribo-seq

>> ○ Bru-seq & BruChase-seq 

> ② Peak caller (Peak finder)

>> ○ Can be used for ChIP-seq, CUT&RUN, CUT&Tag, MeDIP-seq, MethylCap-seq, hmeDIP-seq, DNase-Seq, ATAC-seq.

>> ○ **Step 1.** Read alignment and QC: ChIP-seq is usually single-end sequencing, so it's simple. CUT&Tag analysis uses paired-end sequencing.

>> ○ **Step 2.** Shift size estimation (read extension): Line up + and - strand reads for single-end data (for ChIP-seq). For example, when there are two peaks at a certain distance on the + and - strands, shifting by 1/2 fragment size merges them into a single peak.

>> ○ **Step 3.** Determines window size: Most peak-finders use a sliding window.

>> ○ **Step 4.** Peak detection: Identify peaks in the ChIP sample that are not in the control sample. Involves a statistical test.

>> ○ **Step 5.** Deals with artifacts: Duplicates, strand difference, strand shift, etc.

>> ○ **Step 6.** FDR estimation

>> ○ **Step 7.** Deals with replicate samples, e.g. IDR.

>> ○ **Step 8.** Downstream analysis, e.g. motif enrichment. 

⑶ **Type 3.** [Post-Translational Regulation Identification](https://jb243.github.io/pages/1431#footnote_link_67_52)

> ① scRibo-seq

> ② STAMP-RBP

⑷ **Type 4.** [Programmable Cell Function](https://jb243.github.io/pages/1431#footnote_link_67_53)

> ① RADARS

> ② [LADL (light-activated dynamic looping)](https://www.nature.com/articles/s41592-019-0436-5): photo-activatable gene expression

<br>

<br>

## **15. `Advanced 4.`** Special Transcriptomics Analysis

⑴ scRNA-seq Analysis

> ① Normalization: SAMstrt (Katayama et al.), BASiCS (Vallejos et al.), GRM (Ding et al.), Simple Norm (Satija et al.), scran (Lun et al.), SCnorm (Bacher et al.), Linnorm (Yip et al.)

> ② Data imputation: Reads imputation, scIGAN, MAGIC, VIPER, DeepImpute, SAUCIE 

> ③ Batch effect removal: See above.

> ④ Cell cycle estimation: Cyclum, Cyclops, Oscape 

> ⑤ Cell type prediction: SINCERA, SC3, ACTINN, scVI, CSCORE (cell-type-specific correlation)

> ⑥ CNV/subclone: See above. 

> ⑦ Phylogeny tree: SCARLET, Monovar 

> ⑧ Cell trajectory: See above.

> ⑨ Gene-gene interaction: PINNACLE, scNET, scLINE 

>> ○ PINNACLE: Combines scRNA-seq and protein-protein interaction (PPI) information  

>> ○ scNET: Combines scRNA-seq and protein-protein interaction (PPI) information  

>>> ○ Goal: Learn more accurate expression patterns and gene interaction structures 

>>> ○ Cell-cell similarity → Uses a KNN graph  

>>> ○ Gene-gene relationship → Uses a PPI network  

>>> ○ Inner product decoder → Restores gene-gene relationships  

>>> ○ Fully connected decoder → Restores gene expression values  

>> ○ scLINE: Graph embedding method

> ⑩ Cell-cell communication: See above.

> ⑪ Gene network: SCINET, SCENIC 

> ⑫ Gene imputation: scTransform, SAVER, MAGIC, DeepImpute 

> ⑬ Single-cell perturbation prediction

>> ○ scGen: Based on VAE

>> ○ scPreGAN: Based on GAN

>> ○ scVAEDer: Combination of VAE and DDN (a state-of-the-art diffusion model)

>> ○ GeneFormer: Foundation model based on LLM

> ⑭ scRNA-seq/ST: DTSG

⑵ Spatial Transcriptomics Analysis ([ref1](https://www.nature.com/articles/s41592-022-01409-2), [ref2](https://www.nature.com/articles/s41576-022-00515-3?fbclid=IwAR0T71CxITX9xDJk0n41irqduCpyCTc25yd28ISdWSt3nlGpSNMS5Mr10xU&mibextid=7GMMY6&fs=e&s=cl))

> ① Barcode-based (spot-based) transcription factors: 10x Visium, etc.

> ② Image-based (FISH-based) transcription factors: 10x Xenium, Vizgen MERSCOPE, Nanostring CosMx, etc.

>> ○ Patent dispute between Nanostring and 10x Genomics ('23) ([ref1](https://www.businesswire.com/news/home/20230711643008/en/Delaware-District-Court-Permits-NanoString%E2%80%99s-Counterclaims-that-10x-Genomics-and-Harvard-Violated-the-Antitrust-Laws), [ref2](https://www.businesswire.com/news/home/20231119485930/en/NanoString-Comments-on-Delaware-District-Court-Verdict)) → Nanostring bankruptcy ([ref](https://www.genengnews.com/news/nanostring-files-for-chapter-11-bankruptcy-launches-strategic-review/)) and acquisition ([ref](https://www.businesswire.com/news/home/20240310548568/en/Patient-Square-Capital-a-Leading-Health-Care-Focused-Investment-Firm-Agrees-to-Acquire-NanoString-Technologies))

> ③ ST analysis downstream pipeline

>> ○ `Comprehensive Pipeline`: [Seurat](https://satijalab.org/seurat/articles/spatial_vignette), [Squidpy](https://squidpy.readthedocs.io/en/stable/), [Scanpy](https://scanpy-tutorials.readthedocs.io/en/multiomics/analysis-visualization-spatial.html), [Giotto](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02286-2), [SpatialData](https://www.nature.com/articles/s41592-024-02212-x), [ezSingleCell](https://www.nature.com/articles/s41467-024-48188-2), [SPACEc](https://www.biorxiv.org/content/10.1101/2024.06.29.601349v1.full) ([Google Colab](https://drive.google.com/drive/u/5/folders/1Yx1XHDXdWdrtl3aBQM69O90gG5O76bht)), [Sopa](https://www.nature.com/articles/s41467-024-48981-z) ([Google Colab](https://colab.research.google.com/drive/12QtaJcLUf9hgiKcwMYSSDrwnflJ3QD5D?authuser=5))

>> ○ Dimensionality reduction and clustering: Seurat, Scanpy, Giotto, SPATA, STUtility 

>> ○ Identifying spatial domains: [SPACEL](https://www.nature.com/articles/s41467-023-43220-3), [STAGATE](https://stagate.readthedocs.io/en/latest/index.html), [GraphST](https://www.nature.com/articles/s41467-023-36796-3), [stLearn](https://stlearn.readthedocs.io/), [RESEPT](https://www.nature.com/articles/s41467-022-29439-6), [Spatial-MGCN](https://academic.oup.com/bib/article/24/5/bbad262/7225995), [SpaGCN](https://www.nature.com/articles/s41592-021-01255-8), ECNN, [SEDR](https://www.nature.com/articles/s41467-022-29439-6), [JSTA](https://www.embopress.org/doi/10.15252/msb.202010108), [STGNNks](https://pubmed.ncbi.nlm.nih.gov/37738898/), [conST](https://www.biorxiv.org/content/10.1101/2022.01.14.476408.full), [CCST](https://www.nature.com/articles/s41467-023-36796-3), [BayesSpace](https://www.biorxiv.org/content/10.1101/2020.09.04.283812v1.full.pdf), [SpatialPCA](https://www.nature.com/articles/s41467-022-34879-1), DRSC, Giotto-H, Giotto-HM, Giotto-KM, Giotto-LD, Seurat-LV, Seurat-LVM, Seurat-SLM, [IRIS](https://www.nature.com/articles/s41592-024-02284-9), [NeST](https://pubmed.ncbi.nlm.nih.gov/37848426/), [SC-MEB](https://pubmed.ncbi.nlm.nih.gov/34849574/), [NovoSpaRc](https://pubmed.ncbi.nlm.nih.gov/34349282/), [UTAG](https://www.nature.com/articles/s41592-022-01657-2), [BANKSY](https://www.nature.com/articles/s41588-024-01664-3), NSF, [BASS](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-022-02734-7), SpaTopic, SpatialLDA, [CeLEry](https://www.nature.com/articles/s41467-023-39895-3), [SpaGene](https://pmc.ncbi.nlm.nih.gov/articles/PMC9528978/), [DeepST](https://academic.oup.com/nar/article/50/22/e131/6761985), CellTrek, MULTILAYER, RESEPT, Space-GM, SOTIP, [SpaTM-S](https://www.biorxiv.org/content/10.1101/2025.01.24.634726v1.full.pdf), [scNiche](https://www.nature.com/articles/s41467-025-57029-9), [Novae](https://www.biorxiv.org/content/10.1101/2024.09.09.612009v1.full) 

<br>

| Algorithm      | Spatial Information Required | Histology Information Required | Cluster Number Required | Program Language |
|----------------|------------------------------|-------------------------------|-------------------------|------------------|
| BayesSpace     | Yes                          | No                            | Yes                     | R                |
| DRSC           | optional                     | No                            | optional                | R                |
| Giotto-H       | No                           | No                            | Yes                     | R                |
| Giotto-HM      | Yes                          | No                            | Yes                     | R                |
| Giotto-KM      | No                           | No                            | Yes                     | R                |
| Giotto-LD      | No                           | No                            | No                      | R                |
| Seurat-LV      | No                           | No                            | No                      | R                |
| Seurat-LVM     | No                           | No                            | No                      | R                |
| Seurat-SLM     | No                           | No                            | No                      | R                |
| SpaCell        | No                           | Yes                           | Yes                     | Python           |
| SpaCell-G      | No                           | No                            | Yes                     | Python           |
| SpaCell-I      | No                           | Yes                           | Yes                     | Python           |
| SpaGCN         | Yes                          | No                            | optional                | Python           |
| SpaGCN+        | Yes                          | Yes                           | optional                | Python           |
| stLearn        | Yes                          | Yes                           | No                      | Python           |

**Table 9.** Spatial Clustering Methods

<br>

>>> ○ BayesSpace 

>>>> ○ Employs a Bayesian approach.

>>>> ○ Higher weights to spatial locations that are physically closer.

>>>> ○ Its performance might be limited by its fixed smoothing parameter of the Markov random fields.

>>>> ○ Not computationally scalable for high-throughput spatial transcriptomics data.

>>>> ○ Includes a batch effect correction. 

>>> ○ SC-MEB 

>>>> ○ Performs spatial clustering through an "empirical Bayes approach" capable of optimizing the smoothness parameter.

>>>> ○ Estimates its parameters using an iterative-conditional-mode-based expectation-maximization method to boost its computational efficiency and scalability to high throughput data.

>>> ○ novoSpaRc

>>>> ○ Aim is to minimize discrepancy between shortest paths in expression and spatial data.

>>>> ○ If 2 cells are close expression-wise, they are likely close spatially.

>>>> ○ It calculates shortest path lengths from a KNN graph based on correlation-based distance from scRNA-seq data.

>>> ○ NeST 

>>>> ○ **Step 1.** Compute single-gene expression hotspots across full transcriptome

>>>> ○ **Step 2.** Construct hotspot similarity network 

>>>> ○ **Step 3.** Communities in network are averaged into coexpression hotspots representing a shared expression pattern 

>>> ○ SEDR

>>>> ○ Uses GNN.

>>> ○ STAGATE 

>>>> ○ Uses GNN.

>>> ○ Space-GM

>>>> ○ Uses a GNN to perform supervised learning.

>>> ○ UTAG

>>>> ○ Cell annotation without GNN 

>>>> ○ Includes a batch effect correction. 

>>> ○ SpatialPCA 

>>>> ○ Uses a kernel matrix in [probabilistic PCA](https://jb243.github.io/pages/2158#7-type-6-ppca) to model spatial correlations.

>>> ○ SOTIP

>>>> ○ Clusters cells based on a **network** of cell neighborhoods.

>>> ○ CeLEry

>>>> ○ Histology- and cytoarchitecture-based manual annotation.

>> ○ Identifying spatially variable genes (SVGs): [SPARK](https://www.nature.com/articles/s41592-019-0701-7#Abs1) ([code](https://github.com/xzhoulab/SPARK)), [SPARK-X](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02404-0) (R-based), [SpatialDE](https://www.nature.com/articles/nmeth.4636) (Python-based) ([code](https://github.com/Teichlab/SpatialDE)), [SpaGCN](https://www.nature.com/articles/s41592-021-01255-8), [ST-Net](https://ai.stanford.edu/~bryanhe/publications/stnet.pdf), [STAGATE](https://stagate.readthedocs.io/en/latest/index.html), [HisToGene](https://www.biorxiv.org/content/10.1101/2021.11.28.470212v1.full), [CoSTA](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-021-04314-1), CNNTL, [SPADE](https://academic.oup.com/nar/article/49/10/e55/6146632), [DeepSpaCE](https://www.nature.com/articles/s41598-022-07685-4), [conST](https://www.biorxiv.org/content/10.1101/2022.01.14.476408.full), [Spatial-MGCN](https://academic.oup.com/bib/article/24/5/bbad262/7225995), [STGNNks](https://pubmed.ncbi.nlm.nih.gov/37738898/), [SpatialScope](https://www.nature.com/articles/s41467-023-43629-w), [nnSVG](https://www.nature.com/articles/s41467-023-39748-z) (R-based), [Hotspot](https://pubmed.ncbi.nlm.nih.gov/33951459/), [MERINGUE](https://jef.works/MERINGUE/) (R-based), [Trendsceek](https://www.nature.com/articles/nmeth.4634) ([code](https://github.com/edsgard/trendsceek)), [HMRF](https://www.nature.com/articles/nbt.4260) ([code](https://bitbucket.org/qzhudfci/smfishhmrf-py)), [Celina](https://www.nature.com/articles/s41467-025-56280-4), [Crescendo](https://www.biorxiv.org/content/10.1101/2024.03.07.583997v1.full), Giotto k-means (R-based), Giotto rank (R-based), Moran's I (R-based), SOMDE (Python-based), Seurat, Scanpy, GPcounts, [SpaTM-S](https://www.biorxiv.org/content/10.1101/2025.01.24.634726v1.full.pdf) 

>>> ○ SpatialDE

>>>> ○ Gaussian process regression 

>>>> ○ To decompose the expression variation into a spatial component and a non-spatial component.

>>>> ○ Spatial component modeled by spatial covariance based on the pairwise spatial distances among locations.

>>>> ○ Non-spatial component formulated as noise.

>>>> ○ Lower computational complexity than Trendsceek. Computational complexity still scales cubically with respect to the number of spatial locations.

>>> ○ SPARK

>>>> ○ Generalized Poisson regression 

>>>> ○ Generative model with a variety of kernels: Computes p-values using each of the kernels and utilizes the Cauchy combination rule to combine the p-values.

>>>> ○ To detect genes with spatial variation.

>>>> ○ Lower computational complexity than Trendsceek. Computational complexity still scales cubically with respect to the number of spatial locations.

>>> ○ SPARK-X

>>>> ○ Non-parametric method 

>>>> ○ A covariance matrix for the gene expression and a covariance matrix for the spatial coordinates are utilized.

>>>> ○ If the gene expressions are independent of the spatial coordinates, the product of the two covariance matrices will be small.

>>>> ○ Lower computational complexity than Trendsceek, SpatialDE, and SPARK.

>>> ○ MERINGUE: spatial autocorrelation measure 

>>> ○ nnSVG: nearest-neighbor Gaussian process 

>>> ○ Trendsceek

>>>> ○ Marked point process theory 

>>>> ○ Gene expression (mark)

>>>> ○ Spatial location (point)

>>>> ○ Tests the dependency of distributions of marks and points.

>>>> ○ High computational complexity 

>>> ○ SpaGCN 

>>>> ○ GCN approach 

>>>> ○ Integrates gene expression data, spatial location information, and histology images. 

>>>> ○ Aggregating feature information from each node's neighbors improves the identification of localized gene expression patterns and, consequently, spatially variable genes.

>>>> ○ SpaGCN is also computationally fast and memory efficient compared to SPARK and SpatialDE.

>>> ○ SVCA 

>>>> ○ SVCA uses Gaussian processes with additive covariance to model variation in gene expression.

>>>> ○ Decomposes into intrinsic + environmental + interaction effects: interactions are modeled by integrating gene expression and spatial differences.

>>> ○ Celina

>>>> ○ Multiple kernel strategy 

>> ○ [Enhancing gene expression resolution](https://jb243.github.io/pages/314) (GER): [BayesSpace](https://www.nature.com/articles/s41587-021-00935-2), [XFuse](https://www-nature-com.proxy.lib.umich.edu/articles/s41587-021-01075-3), [DeepSpaCE](https://www.nature.com/articles/s41598-022-07685-4), [HisToGene](https://www.biorxiv.org/content/10.1101/2021.11.28.470212v1.full), [SuperST](https://github.com/portrai-io/SuperST/tree/main), [TESLA](https://www.cell.com/cell-systems/fulltext/S2405-4712(23)00084-4), [iStar](https://www-nature-com.proxy.lib.umich.edu/articles/s41587-023-02019-9), Thor (anti-shrinking Markov graph diffusion method)

>>> ○ iSTAR

>>>> ○ Used to enhance the resolution of spatial transcriptomics. Uses a BEiT-based model trained with the DINO method.  

<br>

![image](https://github.com/user-attachments/assets/75d3e314-eaf5-4f01-b510-3dfd39be99f0)

**Figure 29.** iSTAR Data Preparation Diagram

<br>

>>>> ○ **Step 1.** Partition the given image into 256 × 256 patches.  

>>>> ○ **Step 2.** Subdivide each patch into 16 × 16 sub-patches.  

>>>> ○ **Step 3.** Apply ViT (denoted as f<sub>2</sub>) to each sub-patch to obtain a 384-dimensional vector.  

>>>> ○ **Step 4.** Collect the 384-dimensional vectors to create a 16 × 16 × 384 data structure, then apply another ViT (denoted as f<sub>1</sub>) to obtain a 192-dimensional vector. 

>>>> ○ **Step 5.** Collect the 192-dimensional vectors and apply ViT (denoted as f<sub>0</sub>).  

>>>> ○ Feature and loss function formulation  

<br>

<img width="583" alt="스크린샷 2025-03-11 오전 12 19 36" src="https://github.com/user-attachments/assets/50ec0729-4b1d-4c75-907f-8856e22cc758" />

<br>

>> ○ Gene imputation: [LIGER](https://pmc.ncbi.nlm.nih.gov/articles/PMC6716797/), [SpaGE](https://academic.oup.com/nar/article/48/18/e107/5909530), [stPlus](https://academic.oup.com/bioinformatics/article/37/Supplement_1/i299/6319679), Seurat, [Tangram](https://www.nature.com/articles/s41592-021-01264-7), [gimvI](https://arxiv.org/abs/1905.02269), [GeneDART](https://www.biorxiv.org/content/10.1101/2023.02.07.527488v1), NovoSpaRc, spARC

>> ○ Gene-gene interaction: scHOT, GCNG, MISTy, MESSI, [SEAGAL](https://academic.oup.com/bioinformatics/article/39/7/btad431/7223197) ([Google Colab](https://colab.research.google.com/drive/1vzaVO_JjVQF4i5xeEHPns5Xw1C9OUGUC?authuser=5))

>> ○ Cell-cell interaction (CCI): Giotto, [MISTy](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-022-02663-5), [stLearn](https://stlearn.readthedocs.io/), [GCNG](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02214-w), [conST](https://www.biorxiv.org/content/10.1101/2022.01.14.476408.full), [COMMOT](https://www.nature.com/articles/s41592-022-01728-4), [NCEM](https://www.nature.com/articles/s41587-022-01467-z), spatial variance component analysis, [Tangram](https://www.nature.com/articles/s41592-021-01264-7), [DIALOGUE](https://www.nature.com/articles/s41587-022-01288-0), CellTrek, SVCA

>> ○ Cell type deconvolution: [MIA](https://pubmed.ncbi.nlm.nih.gov/36162205/), [Stereoscope](https://www.nature.com/articles/s42003-020-01247-y), [RCTD](https://www.nature.com/articles/s41587-021-00830-w), [Cell2location](https://www.nature.com/articles/s41587-021-01139-4), [DestVI](https://www.nature.com/articles/s41587-022-01272-8), [STdeconvolve](https://www.nature.com/articles/s41467-022-30033-z), [SPOTlight](https://academic.oup.com/nar/article/49/9/e50/6129341), [SpatialDWLS](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02362-7), [GIST](https://academic.oup.com/nar/article/50/14/e80/6583238), [GraphST](https://www.nature.com/articles/s41467-023-36796-3), [DSTG](https://academic.oup.com/bib/article/22/5/bbaa414/6105942), [Tangram](https://www.nature.com/articles/s41592-021-01264-7), [CellDART](https://academic.oup.com/nar/article/50/10/e57/6534356), [Tacco](https://www.nature.com/articles/s41587-023-01657-3), [Smoother](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-023-03138-x), [CARD](https://www.nature.com/articles/s41587-022-01273-7), [Celloscope](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-023-02951-8), [Starfysh](https://www.nature.com/articles/s41587-024-02173-8), Seurat, DestVI, AdRoit, Spatial-ID (annotation transfrer from scRNA-seq), [SpaTM-G](https://www.biorxiv.org/content/10.1101/2025.01.24.634726v1.full.pdf), SpaOTsc

>> ○ Cell segmentation: Watershed, [Cellpose](https://www.biorxiv.org/content/10.1101/2024.02.10.579780v1), [JSTA](https://pubmed.ncbi.nlm.nih.gov/34057817/), [Baysor](https://www.nature.com/articles/s41587-021-01044-w), [GeneSegNet](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-023-03054-0), [SSAM](https://www.nature.com/articles/s41467-021-23807-4), [ClusterMap](https://www.nature.com/articles/s41467-021-26044-x), [SCS](https://www.nature.com/articles/s41592-023-01939-3), [QuST](https://arxiv.org/html/2406.01613v1), [Proseg](https://github.com/dcjones/proseg), [Bioturing segmentation](https://bioturing.com/blog/a-custom-cellpose-model-for-he-images/) ([github](https://github.com/bioturing-org/turing_segment)), [InstanSeg](https://arxiv.org/abs/2408.15954), [StarDist](https://github.com/stardist/stardist), [CellViT](https://arxiv.org/abs/2306.15350) ([github](https://github.com/TIO-IKIM/CellViT), [application](https://github.com/hustvl/lkcell?tab=readme-ov-file)), [HistAI](https://www.hist.ai/#celldx) ([github](https://github.com/HistAI/hibou?tab=readme-ov-file)), [BIDCell](https://www.nature.com/articles/s41467-023-44560-w), [FICTURE](https://www.biorxiv.org/content/10.1101/2023.11.04.565621v1.full-text), [Comseg](https://www.nature.com/articles/s42003-024-06480-3), [Points2Regions](https://onlinelibrary.wiley.com/doi/full/10.1002/cyto.a.24884), [Sainsc](https://www.biorxiv.org/content/10.1101/2024.08.02.603879v1.full-text), [UCS](https://www.biorxiv.org/content/10.1101/2024.07.08.601384v1), HoVer-Net, Triple U-Net, CDNet, Omnipose, CPP-Net, PathoSAM, NuLite

>>> ○ Cellpose: Trains an artificial neural network to determine whether the gradients of pixels are directed toward the cell interior. Generates nuclear and cell segmentation results in `.tif` and `.npy` formats.  

>>> ○ QuST: An extension of QuPath. Generates nuclear and cell segmentation results in GeoJSON format.  

>>> ○ Baysor: Bayesian mixture model is used. Considers transcript location·composition, cell size·shape to determine cell boundaries.

>>> ○ Proseg: Considers transcript location·composition, cell size·shape to determine cell boundaries. Cellular Potts model, MCMC, and transcript repositioning are used.

>>> ○ BIDCell: Self-supervised deep learning 

>>> ○ Points2Regions: Unsupervised clustering, K-means clustering

>>> ○ Segmentation-free method: [FICTURE](https://www.nature.com/articles/s41592-024-02415-2), [Points2Regions](https://onlinelibrary.wiley.com/doi/full/10.1002/cyto.a.24884), [ComSeg](https://www.nature.com/articles/s42003-024-06480-3) 

>> ○ Spatial niche: NicheNet, Nicheformer, [CellCharter](https://www.nature.com/articles/s41588-023-01588-4) ([Google Colab](https://colab.research.google.com/drive/1k11A-R-V2FKalK09SAU7FMIN2ZKnzqDa?authuser=5)), [GraphSAGE](https://www.nature.com/articles/s41588-025-02080-x) 

>>> ○ [Cellcharter](https://www.nature.com/articles/s41588-023-01588-4): Employes scVI embedding and GMM clustering.

>> ○ Image alignment (Image registration): DiPY, [bUnwarpJ](https://imagej.net/plugins/bunwarpj/) (ImageJ), [STalign](https://www.nature.com/articles/s41467-023-43915-7), [SpatialSPM](https://github.com/portrai-io/spatialspm/blob/main/registration.py) 

>> ○ 3D reconstruction: [PASTE](https://www.nature.com/articles/s41592-022-01459-6), [SPACEL](https://www.nature.com/articles/s41467-023-43220-3), STAGATE, STUtility 

>> ○ CNV inference: [SpatialInferCNV](https://github.com/aerickso/SpatialInferCNV), [SPATA2](https://www.nature.com/articles/s41467-024-50904-x) ([demo](https://drive.google.com/file/d/1BHO1-zHNDPfbEmL-2AkHH7krdmEG-VfE/view?usp=drive_link)), [STmut](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-023-03121-6), [STARCH](https://pubmed.ncbi.nlm.nih.gov/33022659/), [CalicoST](https://www.nature.com/articles/s41592-024-02438-9) 

>> ○ Trajectory analysis: [stLearn](https://stlearn.readthedocs.io/), [SpaceFlow](https://www.nature.com/articles/s41467-022-31739-w), [SPATA2](https://www.nature.com/articles/s41467-024-50904-x), [Startle](https://pubmed.ncbi.nlm.nih.gov/38128483/), [Spateo](https://spateo-release.readthedocs.io/), MOSCOT, SLAT

>> ○ spatial data simulation : scDesign3 

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/1bf0a6cd-e3e8-4381-a308-05103d50d8e8)

**Figure 30.** ST analysis downstream pipeline

<br>

> ④ 3D spatial transcriptomics ([ref1](https://www.science.org/doi/10.1126/sciadv.abb3446?url_ver=Z39.88-2003&rfr_id=ori:rid:crossref.org&rfr_dat=cr_pub%20%200pubmed), [ref2](https://www.nature.com/articles/s41586-023-06808-9), [ref3](https://www.biorxiv.org/content/10.1101/2023.07.21.550124v1))

> ⑤ subcellular ST: [nearest-neighbor](https://www.sciencedirect.com/science/article/pii/S2667237523000991?via%3Dihub#mmc1), [InSTAnT](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9901031/), [TopACT](https://www.nature.com/articles/s41586-024-07563-1) (cell type classification), [APEX-seq-based atlas](https://www.sciencedirect.com/science/article/pii/S0092867419305550), [Bento](https://bento-tools.readthedocs.io/en/latest/), [TEMPOmap](https://www.nature.com/articles/s41592-023-01829-8), [subcellular mRNA kinetic modeling](https://www.biorxiv.org/content/10.1101/2024.03.11.584215v1.full), [Rustem et al.](https://www.biorxiv.org/content/10.1101/2024.11.27.625536v1), [Pengfei et al.](https://www.biorxiv.org/content/10.1101/2024.12.23.630033v1.full) 

⑶ Temporal Transcription Factor Analysis

> ① **Type 1.** short time series data

>> ○ STEM (short time-series expression miner)

>> ○ TimesVector

> ② **Type 2.** Long time series data: similar to analysis of general experimental groups

> ③ **Type 3.** Temporal sequencing

>> ○ [Record-seq](https://www.nature.com/articles/s41596-019-0253-4)

>> ○ [Live-seq](https://www.nature.com/articles/s41586-022-05046-9)

>> ○ [TMI](https://www.biorxiv.org/content/10.1101/2022.08.22.504781v1.full)

>> ○ [molecular recording](https://amjad.mcdb.ucla.edu/research/)

⑷ Spatiotemporal Omics

> ① [ORBIT](https://www.nature.com/articles/s41586-019-1397-7.epdf?shared_access_token=3i3U430q2qLQV0x7sK6YBtRgN0jAjWel9jnR3ZoTv0P1z_iF2KzWeM8MdvOqRyOhVwD-UmF4piQyH4k0q2ZGmjqKtV7ZuIF9EtLgYzNrbaH5yunNuXyfh1mVEVB14ssbcwk1gMVYOIe9LIottGEL-A%3D%3D) (single-molecule DNA origami rotation measurement)

> ② 4D spatiotemporal MRI or hyperpolarized MR 

> ③ _in vivo_ 4D omics with transparent mice

<br>

<br>

## **16. `Advanced 5.`** Database Utilization

⑴ Bioinformatics Resources

> ① Examples: PubMed, NCBI, bioRxiv, BioStars, Bioinformatics Stack Exchange, Stack Overflow 

> ② Data Repositories

>> ○ ArrayExpress (EBI)

>> ○ Gene Expression Omnibus (GEO): fastq-dump is no longer supported.

>> ○ GenomeRNAi, dbGAP

>> ○ The European Genome-phenome Archive (EGA)

>> ○ Database of Interacting Proteins (DIP)

>> ○ IntAct

>> ○ Japanese Genotype-phenotype Archive (JGA)

>> ○ NCBI PubChem BioAssay

>> ○ Genomic Expression Archive (GEA)

>> ○ GWAS Catalog

>> ○ UCSC Genome Browser 

> ③ [Webpage Crawling](https://jb243.github.io/pages/2291)

⑵ [Small Molecule Database](https://jb243.github.io/pages/1365)

> ① [Integrated Small Molecule Database](https://chemicalchecker.org/): Database providing data on the physiological activity of about 800,000 small molecules in vector format

> ② [AlphaFold2 Database](https://alphafold.ebi.ac.uk/): Database with structural data of 200 million proteins

> ③ [ensembl](https://asia.ensembl.org/Homo_sapiens/Info/Index): Transcriptome database

> ④ [uniprot](https://www.uniprot.org/): Protein database

> ⑤ [The Human Protein Atlas](https://www.proteinatlas.org/): Public access resource aiming to map all human proteins in cells, tissues, and organs

> ⑥ [SGC](https://www.thesgc.org/chemical-probes) (Chemical Probes): Provides a unique probe collection along with related data, control compounds, and usage recommendations

⑶ Spatial Transcriptomics database

> ① [HCA](https://data.humancellatlas.org/) 

> ② [HuBMAP](https://portal.hubmapconsortium.org/) 

> ③ [SODB](https://gene.ai.tencent.com/SpatialOmics/) 

> ④ [STOmicsDB](https://db.cngb.org/stomics/) 

> ⑤ [SpatialDB](http://www.spatialomics.org/SpatialDB/) 

> ⑥ [SOAR](https://soar.fsm.northwestern.edu/) 

> ⑦ [HTAN](https://humantumoratlas.org/) 

> ⑧ [Allen Brain Map](https://portal.brain-map.org/)

⑷ [Drug Genomics Database](https://jb243.github.io/pages/1365#footnote_link_67_52)

> ① NCBI dbSNP

> ② gnomAD

> ③ pharmVar

> ④ PHARMGKB

> ⑤ NCBI PubChem

> ⑥ Broad Institute CMAP

> ⑦ CTD

> ⑧ Comptox

> ⑨ Drug Bank

> ⑩ Stitch (search tool for interactions of chemicals)

> ⑪ [ToppFun](https://toppgene.cchmc.org/)

> ⑫ depmap

> ⑬ L1000CDS2

> ⑭ L1000FWD

> ⑮ GDSC (Genomic of Drug Sensitivity in Cancer)

> ⑯ CCLE

> ⑰ [ClinicalTrials.gov](https://clinicaltrials.gov/): Provides information on clinical trial progress for each drug

⑸ Clinical and Non-clinical Databases

> ① [TCGA](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga) (The Cancer Genome Atlas)

>> ○ Diverse human tumor profiling data based on DNA, RNA, protein expression, and epigenetic factors

>> ○ [How to obtain TCGA data](https://jb243.github.io/pages/1694)

> ② [GWAS Catalog](https://www.ebi.ac.uk/gwas/) 

>> ○ Provides curated information and educational resources on genome-related information to identify causal variants and understand disease mechanisms for new therapies

> ③ [MGI](http://www.informatics.jax.org/) (Mouse Genome Informatics)

>> ○ Database collecting mouse mutation, phenotype, and disease data. Each gene ontology (GO) is well organized

> ④ [Open Targets Platform](http://targetvalidation.org/) 

>> ○ Integrated platform for phenotype data such as expression, co-localization, and prioritization signature related to specific targets associated with certain diseases

> ⑤ UK Biobank

>> ○ Metabolome: Sample of 120,000. Measured from blood collected between 2006 and 2010

>> ○ Blood Biomarkers: Sample of 500,000. Measured from blood collected between 2006 and 2010

>> ○ Genome (GWAS, WES, WGS): Sample of 500,000. Measured from blood collected between 2006 and 2010

>> ○ Summary-level Clinical Records: Sample of 500,000. Hospital diagnoses (ICD codes) and date of first diagnosis

>> ○ Record-level Clinical Records: Sample of 250,000. Date-specific diagnosis/prescription records. The start year for tracking is as follows

>>> ○ 1997 for England

>>> ○ 1998 for Wales

>>> ○ 1981 for Scotland

> ⑥ gnomAD

>> ○ A large-scale public database aggregating human genome variation data: Primarily used as a reference for genetic variation and rare disease research.  

>> ○ **Method 1.** Google Cloud: Use the command `$ gsutil ls gs://gcp-public-data--gnomad/release/`. Also available as a BigQuery dataset.  

>> ○ **Method 2.** AWS: Use the command `$ aws s3 ls s3://gnomad-public-us-east-1/release/`. Utilizes the AWS Command Line Interface.  

>> ○ **Method 3.** Azure: Use the command `$ azcopy ls https://datasetgnomad.blob.core.windows.net/dataset/`. Can be accessed via AzCopy or Azure Storage Explorer.  

>> ○ **Method 4.** Hail  

>> ○ **Method 5.** Terra

> ⑦ Other Clinical Databases

<br>

| **Country** | **Institution** | **Clinical Data** | **Genomic Data** | **Transcriptomic Data** | **Proteomic Data** | **Imaging Data** |
| --- | --- | --- | --- | --- | --- | --- |
| USA | PRIMED | O | O |   |   |   |
| USA | All of US | O | O |   |   |
| USA | National Institute of Diabetes and Digestive and Kidney Diseases | O | O |   |   |
| USA | Slim Initiative in Genomic Medicine for the Americas | O | O |   |   |
| UK | UK Biobank | O | O | O | O | O |
| China | Kadoorie Biobank | O | O |   | O | O |

**Table 10.** Other Clinical Databases

<br>

⑹ Policy Databases

> ① [EQIPD Quality System](https://quality-preclinical-data.eu): New non-clinical research quality system developed by the European Quality in Preclinical Data (EQIPD) consortium composed of 8 countries and 29 institutions, applicable to both public and private sectors

> ② [FAIRsharing](https://fairsharing.org/): Curated information and educational resources on database and data policy-related data and metadata standards

⑺ Networking Platforms

> ① [Chemicalprobes.org](https://www.chemicalprobes.org/): Portal site to receive expert advice on finding and using chemical probes in pharmaceutical research and drug development

> ② [European Lead Factory](https://www.europeanleadfactory.eu): Collaborative public-private partnership site for innovative drug development

> ③ [Genotype-Tissue Expression project](https://www.gtexportal.org/home/): Public resource project for tissue-specific gene expression and regulation

> ④ [GOT-IT Expert Platform](http://portal.braincommons.org/public/tools/gotit/)
**:** Platform facilitating exchange between academic researchers and industry experts to promote new academia-industry collaborations

> ⑤ [SPARK Global Initiative](https://sparkglobal.io/): International network focusing on exchanging specialized knowledge and addressing immediate unmet medical needs, enhancing and developing projects

<br>

---

_Input: 2021.10.02 13:49_

_Modification: 2023.07.11 11:19_
