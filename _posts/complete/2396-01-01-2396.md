## **Collection of Python Functions for Organic Chemistry** (Chemoinformatics; Structural Bioinformatics)

Recommended posts: „ÄêOrganic Chemistry„Äë [Organic Chemistry Index](https://jb243.github.io/pages/1483), „ÄêPython„Äë [Collection of Useful Python Functions](https://jb243.github.io/pages/1892)¬†

---

**1.** [Nomenclature](#1-nomenclature)

**2.** [Drawing](#2-drawing)

**3.** [Amino Acid](#3-amino-acid)

**4.** [Spectroscopy](#4-spectroscopy)

**5.** [Reaction Mechanism](#5-reaction-mechanism)

---

**a.** [Bioinformatics](https://jb243.github.io/pages/836)

---

<br>

## **1\. [Nomenclature](https://jb243.github.io/pages/1357)**¬†

‚ë¥ [SMILES](https://jb243.github.io/pages/1355) (Simplified Molecular-Input Line Entry System): A short ASCII string representation.

> ‚ë† Double bonds are represented by '=', and triple bonds by '#'.

> ‚ë° For cyclic compounds, numbers such as 1, 2, ... are assigned to indicate that the ends of a linear molecule are connected to form a ring.

>> ‚óã Example: CN1C=NC2=C1C(=O)N(C(=O)N2C)C

> ‚ë¢ 'C' represents a general carbon atom, whereas 'c' represents an aromatic carbon atom.

>> ‚óã C1CCCCC1: Cyclohexane

>> ‚óã c1ccccc1: Benzene

> ‚ë£ Parentheses can be used to indicate more complex cases.

>> ‚óã Charge notation can also be indicated, such as [N+].

> ‚ë§ @ symbol can be used to represent a stereocenter in a molecule.

>> ‚óã Example: C[C@H](O)[C@H](O)C

> ‚ë• / and \ symbols can be used to represent E/Z isomers.

>> ‚óã Example: CCC/C(=C/C(=O)OCC)/C(=O)OCC

‚ëµ Code for converting organic compounds into SMILES

<br>

```python
rdkit.Chem.MolToSmiles(Chem.MolFromFASTA(sequence, flavor = 1))

"""
flavor: (optional)
0 Protein, L amino acids (default)
1 Protein, D amino acids
2 RNA, no cap
3 RNA, 5‚Äô cap
4 RNA, 3‚Äô cap
5 RNA, both caps
6 DNA, no cap
7 DNA, 5‚Äô cap
8 DNA, 3‚Äô cap
9 DNA, both caps
"""
```

<br>

‚ë∂ SMILES, IUPAC Interconversion Code: It uses a transformer model.

<br>

```python
# reference: https://github.com/Kohulan/Smiles-TO-iUpac-Translator

! pip install STOUT-pypi
! pip install git+https://github.com/Kohulan/Smiles-TO-iUpac-Translator.git

from STOUT import translate_forward, translate_reverse

# SMILES to IUPAC name translation

SMILES = "CN1C=NC2=C1C(=O)N(C(=O)N2C)C"
IUPAC_name = translate_forward(SMILES)
print("IUPAC name of "+SMILES+" is: "+IUPAC_name)

# IUPAC name to SMILES translation

IUPAC_name = "1,3,7-trimethylpurine-2,6-dione"
SMILES = translate_reverse(IUPAC_name)
print("SMILES of "+IUPAC_name+" is: "+SMILES)
```

<br>

> ‚ë† SMILES code conversion may work even if the IUPAC input is not completely accurate

‚ë∑ How to find out the IUPAC nomenclature given any chemical formula 

> ‚ë† **Step 1.** Try the SMILES-to-drawing function several times to find the SMILES code representing the given compound.

> ‚ë° **Step 2.** Execute the SMILES-to-IUPAC function to obtain the final nomenclature.

<br>

<iframe src="https://www.youtube.com/embed/_qhoh9Mi8Ig" width="852" height="480" frameborder="0" allowfullscreen=""></iframe>

<br>

‚ë∏ Code for obtaining molecular weight from SMILES

<br>

```python
from rdkit import Chem
from rdkit.Chem import Descriptors

def calculate_molecular_weight(smiles):
    molecule = Chem.MolFromSmiles(smiles)
    return Descriptors.ExactMolWt(molecule)

# Example usage
smiles_code = "C1=CC=C(C=C1)O"  # SMILES code for phenol
molecular_weight = calculate_molecular_weight(smiles_code)
print(f"Molecular Weight: {molecular_weight}")
```

<br>

‚ëπ Code to determine [aromaticity](https://jb243.github.io/pages/1370#1-aromaticity) from SMILES

<br>

```python
from rdkit import Chem

def is_aromatic(smiles):
    molecule = Chem.MolFromSmiles(smiles)
    if molecule is None:
        return False
    return any(atom.GetIsAromatic() for atom in molecule.GetAtoms())

# Example usage
cyclohexane = "C1CCCCC1"  # cyclohexane
benzene = "c1ccccc1"  # benzene
imidazole = "C1=CN=CN1" # 1H-imidazole

print(f"The {cyclohexane} is {'aromatic' if is_aromatic(cyclohexane) else 'not aromatic'}")
print(f"The {benzene} is {'aromatic' if is_aromatic(benzene) else 'not aromatic'}")
print(f"The {imidazole} is {'aromatic' if is_aromatic(imidazole) else 'not aromatic'}")
```

<br>

‚ë∫ Code for calculating [dipole moment](https://jb243.github.io/pages/1330#2-dipole-moment) from SMILES

<br>

```python
# conda install -c psi4 psi4

import psi4
from rdkit import Chem
from rdkit.Chem import AllChem
import numpy as np

def calculate_dipole_moment(smiles):
    # Convert SMILES to molecule
    mol = Chem.MolFromSmiles(smiles)

    # Add Hydrogens
    mol = Chem.AddHs(mol)

    # Generate 3D coordinates
    AllChem.EmbedMolecule(mol, AllChem.ETKDG())

    # Extract coordinates
    conf = mol.GetConformer()
    xyz = ''
    for atom in mol.GetAtoms():
        pos = conf.GetAtomPosition(atom.GetIdx())
        xyz += f"{atom.GetSymbol()} {pos.x} {pos.y} {pos.z}\n"

    # Set up Psi4
    psi4.set_memory('500 MB')
    psi4.set_options({'basis': 'sto-3g'})

    # Calculate dipole moment using Psi4
    psi4_mol = psi4.geometry(xyz)
    psi4.energy('scf')
    dipole_moment = psi4.variable('SCF DIPOLE')

    return dipole_moment

### Example usage
smiles_code = "CCO"  # Example SMILES code for ethanol
dipole_moment = calculate_dipole_moment(smiles_code)
print(f"Dipole Moment: {dipole_moment} Debye")
# Dipole Moment: [ 0.04250251  0.20600936 -0.52850913] Debye

dipole_vector = np.array([0.04250251, 0.20600936, -0.52850913])
magnitude = np.linalg.norm(dipole_vector)
print(f"Magnitude of Dipole Moment: {magnitude} Debye")
# Magnitude of Dipole Moment: 0.5688305725409514 Debye
```

<br>

‚ëª A function to obtain the boiling point (bp), melting point (mp), and critical temperature from SMILES

<br>

```python
# reference: https://thermo.readthedocs.io/thermo.chemical.html

from thermo.chemical import Chemical

N2 = Chemical('Nitrogen')
print(N2.Tm, N2.Tb, N2.Tc) # melting, boiling, and critical points [K]
## 63.15 77.3549950205 126.192

molecule = Chemical('CC(C)C')
print(molecule.Tm, molecule.Tb, molecule.Tc) # melting, boiling, and critical points [K]
## 124.2 261.401014643 407.81

molecule_ = Chemical('2-methylpropane')
print(molecule_.Tm, molecule_.Tb, molecule_.Tc) # melting, boiling, and critical points [K]
## 124.2 261.401014643 407.81
```

<br>

> ‚ë† It operates on a search-based approach and not all compounds are targeted.

> ‚ë° Various machine learning models are being introduced to improve this.

‚ëº Function to crawl pK<sub>a</sub> values from PubChem

<br>

```python
import requests
import re
import statistics  # module for calculating median values

def get_median_pka(cid):
    """
    Return median after crawling pKa data from PubChem
    """
    # 1. PubChem API request (Total Experimental Properties)
    url = f"https://pubchem.ncbi.nlm.nih.gov/rest/pug_view/data/compound/{cid}/JSON?heading=Experimental+Properties"
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"}

    try:
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code != 200:
            print(f"API request failure (CID: {cid}): {response.status_code}")
            return None
            
        data = response.json()
        
        # List to store collected pKa values
        collected_pkas = []

        # 2. Recursive search function
        def find_pka_recursive(node):
            if isinstance(node, dict):
                # Explore inside if section title is pKa related
                if 'TOCHeading' in node and node['TOCHeading'] in ['Dissociation Constants', 'pKa']:
                    extract_info(node)
                # Continue navigation of sub-node
                for key, value in node.items():
                    find_pka_recursive(value)
            elif isinstance(node, list):
                for item in node:
                    find_pka_recursive(item)

        # 3. Number extraction and filtering functions from text
        def extract_info(section_node):
            if 'Information' in section_node:
                for info in section_node['Information']:
                    if 'Value' in info:
                        raw_string = ""
                        if 'StringWithMarkup' in info['Value']:
                            for markup in info['Value']['StringWithMarkup']:
                                raw_string += markup.get('String', '') + " "
                        elif 'Number' in info['Value']:
                            raw_string = str(info['Value']['Number'])
                        
                        if raw_string:
                            # a regular expression: Extract "pKa = 3.5 at 25 C" -> 3.5
                            match = re.search(r"(-?\d+\.?\d*)", raw_string)
                            if match:
                                try:
                                    val = float(match.group(1))
                                    
                                    # [Important] Filtering Logic (Sanity Check)
                                    # The pKa is usually between -10 and 20.
                                    # If it is out of this range, it is highly likely to be 'temperature (25)' or 'molecular weight', so exclude it.
                                    if -10 <= val <= 20:
                                        collected_pkas.append(val)
                                except ValueError:
                                    pass

        # Start navigation
        find_pka_recursive(data)
        
        # 4. Calculation of results (median)
        if not collected_pkas:
            return None # No data
            
        median_val = statistics.median(collected_pkas)
        return median_val

    except Exception as e:
        print(f"Error occurs: {e}")
        return None

# CID list to test (Aspirin, ibuprofen, acetaminophen)
test_cids = [2244, 3672, 1983]

print(f"{'CID':<10} | {'Median pKa':<10} | {'Status'}")
print("-" * 35)

for cid in test_cids:
    result = get_median_pka(cid)
    
    if result is not None:
        print(f"{cid:<10} | {result:<10.2f} | Success")
    else:
        print(f"{cid:<10} | {'N/A':<10} | Fail")

```

<br>

‚ëΩ Model for predicting biological activity from SMILES, etc.

> ‚ë† [Database Query](https://github.com/mims-harvard/TDC/tree/main) 

<br>

```python
""" Anaconda env
conda create --name TDC python=3.10
conda activate TDC
pip install PyTDC
pip install numpy pandas tqdm scikit-learn fuzzywuzzy seaborn
pip install jupyter jupyterlab
pip install ipykernel
python -m ipykernel install --user --name TDC --display-name TDC
"""

from tdc.multi_pred import GDA
data = GDA(name = 'DisGeNET')
data.get_data().head(2)

"""
from tdc.multi_pred import GDA
data = GDA(name = 'DisGeNET') #gene-disease association (GDA)
from tdc.multi_pred import DTI
data = DTI(name = 'BindingDB_Kd', print_stats = True) #drug-target interaction (DTI)
data = DTI(name = 'BindingDB_IC50', print_stats = True)
data = DTI(name = 'BindingDB_EC50', print_stats = True)
data = DTI(name = 'BindingDB_Ki', print_stats = True)
from tdc.generation import MolGen
data = MolGen(name = 'MOSES', print_stats = True) #molecule generation
from tdc.multi_pred import DrugRes
data = DrugRes(name = 'GDSC2') #drug response
from tdc.multi_pred import DrugSyn
data = DrugSyn(name = 'OncoPolyPharmacology') #drug synergistic effect
from tdc import utils
utils.retrieve_dataset_names('ADME')
from tdc.single_pred import ADME
data = ADME(name = 'Pgp_Broccatelli')
from tdc.multi_pred import DDI
data = DDI(name = 'DrugBank') #drug-drug interaction (DDI)
from tdc.generation import RetroSyn
data = RetroSyn(name = 'USPTO-50K') #retrosynthesis
from tdc.multi_pred import Catalyst
data = Catalyst(name = 'USPTO_Catalyst')
from tdc.single_pred import Yields
data = Yields(name = 'Buchwald-Hartwig')
from tdc.multi_pred import MTI
data = MTI(name = 'miRTarBase') #miRNA-target interaction (MTI)
from tdc.single_pred import Paratope
data = Paratope(name = 'SAbDab_Liberis') #antibody binding region
from tdc.single_pred import Epitope
data = Epitope(name = 'IEDB_Jespersen')
from tdc.multi_pred import AntibodyAff
data = AntibodyAff(name = 'Protein_SAbDab') #antigen-antibody binding affinity
from tdc.single_pred import Develop
data = Develop(name = 'TAP', label_name = 'CDR Length') #antibody developability
from tdc.multi_pred import PeptideMHC
data = PeptideMHC(name = 'MHC1_IEDB-IMGT_Nielsen') #MHC1-peptide binding affinity
from tdc.multi_pred import PeptideMHC
data = PeptideMHC(name = 'MHC2_IEDB_Jensen') #MHC2-peptide binding affinity
"""
```

<br>

> ‚ë° [Basic models](https://github.com/mims-harvard/TDC/blob/main/tutorials/TDC_104_ML_Model_DeepPurpose.ipynb)

> ‚ë¢ [ChemBERTa](https://arxiv.org/abs/2010.09885): Based on RoBERTa. Submitted to NeurIPS 2020. Performance is lower than D-MPNN.

> ‚ë£ [Smile-to-Bert](https://www.biorxiv.org/content/10.1101/2024.10.31.621293v2): Predicts ADMET (Absorption, Distribution, Metabolism, Excretion, Toxicity) from SMILES. Performance is poor.

> ‚ë§ [ADMET-AI](https://github.com/swansonk14/admet_ai): Uses Chemprop-RDKit. Predicts ADMET (Absorption, Distribution, Metabolism, Excretion, Toxicity). Provides significant advantages in speed, accuracy, licensing, ease of use and DrugBank integration.

>> ‚óã molecular_weight, logP, hydrogen_bond_acceptors, hydrogen_bond_donors, Lipinski, QED, stereo_centers, tpsa, AMES, BBB_Martins, Bioavailability_Ma, CYP1A2_Veith, CYP2C19_Veith, CYP2C9_Substrate_CarbonMangels, CYP2C9_Veith, CYP2D6_Substrate_CarbonMangels, CYP2D6_Veith, CYP3A4_Substrate_CarbonMangels, CYP3A4_Veith, Carcinogens_Lagunin, ClinTox, DILI, HIA_Hou, NR-AR-LBD, NR-AR, NR-AhR, NR-Aromatase, NR-ER-LBD, NR-ER, NR-PPAR-gamma, PAMPA_NCATS, Pgp_Broccatelli, SR-ARE, SR-ATAD5, SR-HSE, SR-MMP, SR-p53, Skin_Reaction, hERG, Caco2_Wang, Clearance_Hepatocyte_AZ, Clearance_Microsome_AZ, Half_Life_Obach, HydrationFreeEnergy_FreeSolv, LD50_Zhu, Lipophilicity_AstraZeneca, PPBR_AZ, Solubility_AqSolDB, VDss_Lombardo, molecular_weight_drugbank_approved_percentile, logP_drugbank_approved_percentile, hydrogen_bond_acceptors_drugbank_approved_percentile, hydrogen_bond_donors_drugbank_approved_percentile, Lipinski_drugbank_approved_percentile, QED_drugbank_approved_percentile, stereo_centers_drugbank_approved_percentile, tpsa_drugbank_approved_percentile, AMES_drugbank_approved_percentile, BBB_Martins_drugbank_approved_percentile, Bioavailability_Ma_drugbank_approved_percentile, CYP1A2_Veith_drugbank_approved_percentile, CYP2C19_Veith_drugbank_approved_percentile, CYP2C9_Substrate_CarbonMangels_drugbank_approved_percentile, CYP2C9_Veith_drugbank_approved_percentile, CYP2D6_Substrate_CarbonMangels_drugbank_approved_percentile, CYP2D6_Veith_drugbank_approved_percentile, CYP3A4_Substrate_CarbonMangels_drugbank_approved_percentile, CYP3A4_Veith_drugbank_approved_percentile, Carcinogens_Lagunin_drugbank_approved_percentile, ClinTox_drugbank_approved_percentile, DILI_drugbank_approved_percentile, HIA_Hou_drugbank_approved_percentile, NR-AR-LBD_drugbank_approved_percentile, NR-AR_drugbank_approved_percentile, NR-AhR_drugbank_approved_percentile, NR-Aromatase_drugbank_approved_percentile, NR-ER-LBD_drugbank_approved_percentile, NR-ER_drugbank_approved_percentile, NR-PPAR-gamma_drugbank_approved_percentile, PAMPA_NCATS_drugbank_approved_percentile, Pgp_Broccatelli_drugbank_approved_percentile, SR-ARE_drugbank_approved_percentile, SR-ATAD5_drugbank_approved_percentile, SR-HSE_drugbank_approved_percentile, SR-MMP_drugbank_approved_percentile, SR-p53_drugbank_approved_percentile, Skin_Reaction_drugbank_approved_percentile, hERG_drugbank_approved_percentile, Caco2_Wang_drugbank_approved_percentile, Clearance_Hepatocyte_AZ_drugbank_approved_percentile, Clearance_Microsome_AZ_drugbank_approved_percentile, Half_Life_Obach_drugbank_approved_percentile, HydrationFreeEnergy_FreeSolv_drugbank_approved_percentile, LD50_Zhu_drugbank_approved_percentile, Lipophilicity_AstraZeneca_drugbank_approved_percentile, PPBR_AZ_drugbank_approved_percentile, Solubility_AqSolDB_drugbank_approved_percentile, VDss_Lombardo_drugbank_approved_percentile

‚ëæ Function to generate IUPAC names from PubChem

<br>

```python
import requests
import time

def fetch_iupac_names_from_pubchem(start_cid, count):
    iupac_names = []
    base_url = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{}/property/IUPACName/JSON"
    
    current_cid = start_cid
    while len(iupac_names) < count:
        response = requests.get(base_url.format(current_cid))
        if response.status_code == 200:
            data = response.json()
            if 'PropertyTable' in data and 'Properties' in data['PropertyTable']:
                for prop in data['PropertyTable']['Properties']:
                    if 'IUPACName' in prop:
                        iupac_names.append(prop['IUPACName'])
                        if len(iupac_names) >= count:
                            break
        else:
            print(f"Failed to fetch data for CID {current_cid}")
        
        current_cid += 1
        time.sleep(0.1)  # To prevent hitting the API rate limit

    return iupac_names

# Fetch 100 IUPAC names starting from CID 1
iupac_names = fetch_iupac_names_from_pubchem(start_cid=1, count=100)
```

<br>

> ‚ë† **Application 1.** Creating [IUPAC Nomenclature](https://jb243.github.io/pages/1357) Examples

>> ‚óã Crawling IUPAC nomenclature from PubChem ‚Üí IUPAC-to-SMILES ‚Üí SMILES-to-image

>> ‚óã The example generation algorithm includes an additional step of verifying if SMILES-to-IUPAC matches the original IUPAC, which results in the following incidental effects:

>> ‚óã **Effect 1.** Exclusion of inappropriate IUPAC nomenclature

>> ‚óã **Effect 2.** By eliminating nomenclature that is difficult for computers to understand, the complexity of the nomenclature examples is adjusted.

‚ëø Function to generate SMILES names with stereochemistry from PubChem

<br>

```python
import requests
import time
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem.EnumerateStereoisomers import EnumerateStereoisomers, StereoEnumerationOptions

def fetch_smiles_from_pubchem(start_cid, count):
    smiles_list = []
    base_url = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{}/property/CanonicalSMILES/JSON"
    
    current_cid = start_cid
    while len(smiles_list) < count:
        response = requests.get(base_url.format(current_cid))
        if response.status_code == 200:
            data = response.json()
            if 'PropertyTable' in data and 'Properties' in data['PropertyTable']:
                for prop in data['PropertyTable']['Properties']:
                    if 'CanonicalSMILES' in prop:
                        smiles_list.append(prop['CanonicalSMILES'])
                        if len(smiles_list) >= count:
                            break
        else:
            print(f"Failed to fetch data for CID {current_cid}")
        
        current_cid += 1
        time.sleep(0.1)  # To prevent hitting the API rate limit

    return smiles_list

def generate_stereoisomers(smiles, max_isomers=5):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return []
    
    opts = StereoEnumerationOptions(onlyUnassigned=True, maxIsomers=max_isomers)
    isomers = list(EnumerateStereoisomers(mol, options=opts))
    
    smiles_isomers = [Chem.MolToSmiles(isomer, isomericSmiles=True) for isomer in isomers]
    return smiles_isomers

# Fetch 100 canonical SMILES codes starting from CID 1
smiles_codes = fetch_smiles_from_pubchem(start_cid=1, count=100)

# Generate stereoisomers for each fetched SMILES code
all_stereoisomers = []
for i, smiles in enumerate(smiles_codes, start=1):
    stereoisomers = generate_stereoisomers(smiles)
    all_stereoisomers.extend(stereoisomers)
    print(f"Canonical SMILES {i}: {smiles}")
    for j, isomer in enumerate(stereoisomers, start=1):
        print(f"  Stereoisomer {j}: {isomer}")

# Optionally, limit the number of generated stereoisomers for display
max_display = 100
print("\nGenerated Stereoisomers (limited to first {}):".format(max_display))
for i, isomer in enumerate(all_stereoisomers[:max_display], start=1):
    print(f"{i}: {isomer}")
    

''' Visualization code example
from rdkit import Chem
from rdkit.Chem import Draw

smiles = 'O=C(O)C[C@@]1(Cl)C=CC(=O)O1'
molecule = Chem.MolFromSmiles(smiles)
Draw.MolToImage(molecule)
'''
```

<br>

> ‚ë† **Application 1.** Creating [RS Nomenclature](https://jb243.github.io/pages/1358#3-mirror-image-isomers) Examples

>> ‚óã CrawlingSMILES nomenclature from PubChem ‚Üí canonical SMILES to stereochemical SMILES ‚Üí SMILES-to-image

> ‚ë° **Application 2.** The above code yields a structure that particularly favors the R configuration.

>> ‚óã In practice, upon examining 62 [examples of stereoisomers](https://jb243.github.io/pages/2399), 40 instances favored the R configuration while 22 favored the S configuration, indicating a preference for the R configuration in the test.

>> ‚óã The theoretical ratio of R isomers and S isomers should be identical, so it is suspected that there might be a cognitive bias instead.

<br>

<br>

## **2\. Drawing**¬†

‚ë¥ Drawing molecular formulas for organic compounds (_e.g._, peracetic acid)¬†

<br>

```python
from rdkit import Chem
from rdkit.Chem import Draw

# Define the SMILES strings for peracetic acid
smiles = 'C=CC(=O)O'

# Convert the SMILES strings to RDKit molecule objects
molecule = Chem.MolFromSmiles(smiles)

# Draw the molecules without saving
Draw.MolToImage(molecule)

# Draw the molecules with saving
Draw.MolToFile(molecule, 'peracetic_acid.png')
```

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/7d9c72d8-8c21-42c3-8a55-473f0c4ec12e)

<br>

‚ëµ Drawing electron density maps for organic compounds (ver. 1) (_e.g._, peracetic acid)

<br>

```python
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem.Draw import SimilarityMaps

# Generate a 3D structure
molecule = Chem.MolFromSmiles('CC(=O)OO')
molecule_3d = Chem.AddHs(molecule)
AllChem.EmbedMolecule(molecule_3d, AllChem.ETKDG())
AllChem.MMFFOptimizeMolecule(molecule_3d)

# Calculate Gasteiger charges
AllChem.ComputeGasteigerCharges(molecule_3d)

# Function to get atom charges
def GetAtomCharges(mol):
    charges = [float(mol.GetAtomWithIdx(i).GetProp('_GasteigerCharge')) for i in range(mol.GetNumAtoms())]
    return charges

# Draw electrostatic potential map
fig = SimilarityMaps.GetSimilarityMapFromWeights(molecule_3d, GetAtomCharges(molecule_3d), colorMap='jet', contourLines=10)
```

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/db433416-84a1-4e3f-85d4-65a1f380315d)

<br>

‚ë∂ Drawing electron density maps for organic compounds (ver. 2) (_e.g._, peracetic acid)

<br>

```python
# Refernece: https://rdkit.readthedocs.io/en/latest/Cookbook.html


## STEP 1. make a random forest model

from rdkit import Chem, DataStructs
from rdkit.Chem import AllChem
from sklearn.ensemble import RandomForestClassifier
import numpy

# generate four molecules
m1 = Chem.MolFromSmiles('c1ccccc1')
m2 = Chem.MolFromSmiles('c1ccccc1CC')
m3 = Chem.MolFromSmiles('c1ccncc1')
m4 = Chem.MolFromSmiles('c1ccncc1CC')
mols = [m1, m2, m3, m4]

# generate fingeprints: Morgan fingerprint with radius 2
fps = [AllChem.GetMorganFingerprintAsBitVect(m, 2) for m in mols]

# convert the RDKit explicit vectors into numpy arrays
np_fps = []
for fp in fps:
  arr = numpy.zeros((1,))
  DataStructs.ConvertToNumpyArray(fp, arr)
  np_fps.append(arr)

# get a random forest classifiert with 100 trees
rf = RandomForestClassifier(n_estimators=100, random_state=1123)

# train the random forest
# with the first two molecules being actives (class 1) and
# the last two being inactives (class 0)
ys_fit = [1, 1, 0, 0]
rf.fit(np_fps, ys_fit)

# use the random forest to predict a new molecule
m5 = Chem.MolFromSmiles('c1ccccc1O')
fp = numpy.zeros((1,))
DataStructs.ConvertToNumpyArray(AllChem.GetMorganFingerprintAsBitVect(m5, 2), fp)

print(rf.predict((fp,)))
print(rf.predict_proba((fp,)))



## STEP 2. run the random forest model for the input

from rdkit.Chem.Draw import SimilarityMaps

# helper function
def getProba(fp, predictionFunction):
  return predictionFunction((fp,))[0][1]

m5 = Chem.MolFromSmiles('CC(=O)OO')
fig, maxweight = SimilarityMaps.GetSimilarityMapForModel(m5, SimilarityMaps.GetMorganFingerprint, lambda x: getProba(x, rf.predict_proba))
```

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/b21fc949-7d74-4794-a0d0-4857ba1959c0)

<br>

‚ë∑ Drawing three-dimensional molecular structures of organic compounds.

<br>

```python
from rdkit import Chem
from rdkit.Chem import AllChem
import py3Dmol

def draw_3d_molecule(smiles):
    # Convert SMILES to RDKit molecule
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        print("Invalid SMILES code.")
        return
    
    # Generate 3D coordinates for the molecule
    mol = Chem.AddHs(mol)  # Add hydrogens
    AllChem.EmbedMolecule(mol, AllChem.ETKDG())  # Embed molecule in 3D space
    
    # Convert RDKit molecule to 3Dmol.js viewable format
    mb = Chem.MolToMolBlock(mol)
    
    # Visualization with Py3Dmol
    viewer = py3Dmol.view(width=400, height=300)
    viewer.addModel(mb, 'mol')
    viewer.setStyle({'stick': {}})
    viewer.zoomTo()
    
    return viewer.show()

# Example usage
smiles_code = "CCO"  # Ethanol
draw_3d_molecule(smiles_code)
```

<br>

> ‚ë† **Review 1:** In methanol, the two methyl groups are in a [staggered orientation](https://jb243.github.io/pages/1356#5-conformational-isomers-conformers) to minimize steric hindrance, whereas in ethanol, this is not the case due to intramolecular hydrogen bonding.

<br>

<img width="376" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2024-06-11 ·Ñã·Ö©·Ñí·ÖÆ 12 34 59" src="https://github.com/JB243/jb243.github.io/assets/55747737/be3f689e-3b8e-4a49-9a6a-6b0d071987ad">

<br>

> ‚ë° **Review 2:** The structure is also well implemented in the following conjugated ring compounds.

<br>

<img width="423" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2024-06-11 ·Ñã·Ö©·Ñí·ÖÆ 12 34 31" src="https://github.com/JB243/jb243.github.io/assets/55747737/1135920d-9b34-4d29-a560-958d1b4e9011">

<br>

> ‚ë¢ This is the charm of chemoinformatics, where new knowledge can be created solely with machine learning models.

‚ë∏ Displaying 2D molecular structure with [R/S nomenclature](https://jb243.github.io/pages/1358#3-mirror-image-isomers) for organic compounds 

<br>

```python
from rdkit import Chem
from rdkit.Chem import AllChem, Draw
from rdkit.Chem.rdMolDescriptors import CalcMolFormula
from PIL import Image, ImageDraw, ImageFont
import matplotlib.font_manager as fm

def get_stereochemistry(mol):
    Chem.AssignStereochemistry(mol, cleanIt=True, force=True)
    stereo_info = {}
    for atom in mol.GetAtoms():
        if atom.HasProp('_CIPCode'):
            stereo_info[atom.GetIdx()] = atom.GetProp('_CIPCode')
    return stereo_info

def draw_2d_molecule_with_stereochemistry(smiles, filename="molecule.png"):
    # Convert SMILES to RDKit molecule
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        print("Invalid SMILES code.")
        return
    
    # Generate 2D coordinates for the molecule
    AllChem.Compute2DCoords(mol)
    
    # Get stereochemistry information
    stereo_info = get_stereochemistry(mol)
    print(stereo_info)
    
    # Draw the molecule
    img = Draw.MolToImage(mol, size=(300, 300), kekulize=True, wedgeBonds=True)
    
    # Convert the RDKit image to a PIL image
    pil_img = img.convert("RGBA")
    
    # Create a drawing context
    draw = ImageDraw.Draw(pil_img)
    
    # Load fonts
    font_size = 18  # You can change the font size here
    try:
        # Use DejaVuSans.ttf for regular text
        font_path = fm.findfont(fm.FontProperties(family="DejaVu Sans"))
        font = ImageFont.truetype(font_path, font_size)
        # Use DejaVuSans-Oblique.ttf for italic text
        italic_font_path = fm.findfont(fm.FontProperties(family="DejaVu Sans", style="italic"))
        italic_font = ImageFont.truetype(italic_font_path, font_size)
    except IOError:
        font = ImageFont.load_default()
        italic_font = font  # Fallback if no italic font is found
    
    # Generate 2D coordinates for the drawing
    AllChem.Compute2DCoords(mol)
    conf = mol.GetConformer()
    
    # Get 2D coordinates for each atom
    coords = conf.GetPositions()
    
    # Add stereo annotations
    for atom_idx, stereo in stereo_info.items():
        atom = mol.GetAtomWithIdx(atom_idx)
        pos = coords[atom_idx]
        
        # Calculate pixel position from molecule coordinates
        x = pos[0] * 35 + 135
        y = -pos[1] * 35 + 150
        
        # Draw the text annotation with non-italicized brackets and italicized R/S
        draw.text((x, y), "(", fill=(0, 0, 0), font=font)
        draw.text((x + 10, y), stereo, fill=(0, 0, 0), font=italic_font)
        draw.text((x + 30, y), ")", fill=(0, 0, 0), font=font)
    
    # Save the image to a file
    pil_img.save(filename)
    print(f"Image saved as {filename}")

# Example usage
smiles_code = "C[C@H](O)[C@H](O)C"  # Example molecule with stereochemistry
draw_2d_molecule_with_stereochemistry(smiles_code, "molecule_with_stereochemistry.png")
```

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/367dd4fa-de2c-444a-9871-6a88f37cc30f)

<br>

‚ëπ Displaying 3D molecular structure with [R/S nomenclature](https://jb243.github.io/pages/1358#3-mirror-image-isomers) for organic compounds

<br>

```python
from rdkit import Chem
from rdkit.Chem import AllChem, Draw
from rdkit.Chem.rdMolDescriptors import CalcMolFormula
import py3Dmol

def get_stereochemistry(mol):
    Chem.AssignStereochemistry(mol, cleanIt=True, force=True)
    stereo_info = {}
    for atom in mol.GetAtoms():
        if atom.HasProp('_CIPCode'):
            stereo_info[atom.GetIdx()] = atom.GetProp('_CIPCode')
    return stereo_info

def draw_3d_molecule_with_stereochemistry(smiles):
    # Convert SMILES to RDKit molecule
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        print("Invalid SMILES code.")
        return
    
    # Generate 3D coordinates for the molecule
    mol = Chem.AddHs(mol)  # Add hydrogens
    AllChem.EmbedMolecule(mol, AllChem.ETKDG())  # Embed molecule in 3D space
    
    # Get stereochemistry information
    stereo_info = get_stereochemistry(mol)
    print(stereo_info)
    
    # Convert RDKit molecule to 3Dmol.js viewable format
    mb = Chem.MolToMolBlock(mol)
    
    # Visualization with Py3Dmol
    viewer = py3Dmol.view(width=400, height=300)
    viewer.addModel(mb, 'mol')
    viewer.setStyle({'stick': {}})
    
    # Annotate the stereochemistry on the molecule
    for atom_idx, stereo in stereo_info.items():
        pos = mol.GetConformer().GetAtomPosition(atom_idx)
        viewer.addLabel(stereo, {
            'position': {'x': pos.x, 'y': pos.y, 'z': pos.z}, 
            'backgroundColor': 'black', 
            'fontColor': 'white', 
            'fontSize': 14, 
            'showBackground': True
        })
    
    viewer.zoomTo()
    
    return viewer.show()

# Example usage
smiles_code = "C[C@H](O)[C@H](O)C"  # Example molecule with stereochemistry
draw_3d_molecule_with_stereochemistry(smiles_code)
```

<br>

<img width="291" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2024-06-11 ·Ñã·Ö©·Ñí·ÖÆ 12 35 18" src="https://github.com/JB243/jb243.github.io/assets/55747737/689de35d-156a-4f8b-bdfa-99ad59bf8a7a">

<br>

‚ë∫ Code that draws all of the structural isomers of alkanes according to the number of carbon atoms

<br>

```python
from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem import AllChem
from rdkit.Chem.rdchem import Mol
from IPython.display import display

def generate_alkanes(n_carbons):
    if n_carbons == 1:
        return [Chem.MolFromSmiles('C')]
    elif n_carbons == 2:
        return [Chem.MolFromSmiles('CC')]
    
    smaller_alkanes = generate_alkanes(n_carbons - 1)
    new_alkanes = set()
    
    for mol in smaller_alkanes:
        for atom in mol.GetAtoms():
            if atom.GetDegree() < 4:  # Carbon can have at most four bondings 
                new_mol = Chem.RWMol(mol)
                new_idx = new_mol.AddAtom(Chem.Atom(6))
                new_mol.AddBond(atom.GetIdx(), new_idx, Chem.BondType.SINGLE)
                Chem.SanitizeMol(new_mol)
                smiles = Chem.MolToSmiles(new_mol, canonical=True)
                new_alkanes.add(smiles)
    
    return [Chem.MolFromSmiles(smiles) for smiles in new_alkanes]

# Generation and Visualization of All Structural Isomers of C7H16 
n_carbons = 7
alkanes = generate_alkanes(n_carbons)
img = Draw.MolsToGridImage(alkanes, molsPerRow=5, subImgSize=(200, 200))

# Directly display images (works only in Jupyter notebooks)
display(img)
```

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/833eb689-8af0-48e9-aeb5-353e3fedd97c)

<br>

| **Chemical Formula** | **# of Structural Isomers** |
| --- | --- |
| C<sub>3</sub>H<sub>8</sub> | 1 |
| C<sub>4</sub>H<sub>10</sub> | 2 |
| C<sub>5</sub>H<sub>12</sub> | 3 |
| C<sub>6</sub>H<sub>14</sub> | 5 |
| C<sub>7</sub>H<sub>16</sub> | 9 |
| C<sub>8</sub>H<sub>18</sub> | 18 |
| C<sub>9</sub>H<sub>20</sub> | 35 |
| C<sub>10</sub>H<sub>22</sub> | 75 |
| C<sub>11</sub>H<sub>24</sub> | 159 |
| C<sub>12</sub>H<sub>26</sub> | 355 |
| C<sub>13</sub>H<sub>28</sub> | 802 |
| C<sub>14</sub>H<sub>30</sub> | 1,858 |
| C<sub>15</sub>H<sub>32</sub> | 4,347 |
| C<sub>16</sub>H<sub>34</sub> | 10,359 |
| C<sub>17</sub>H<sub>36</sub> | 24,894 |
| C<sub>18</sub>H<sub>38</sub> | 60,523 |
| C<sub>19</sub>H<sub>40</sub> | 148,284 |
| C<sub>20</sub>H<sub>42</sub> | 366,319 |
| C<sub>30</sub>H<sub>62</sub> | 4,111,846,763 |
| C<sub>40</sub>H<sub>82</sub> | 62,481,801,147,341 |

<br>

**Table 1.** Number of structural isomers of alkanes based on carbon count

<br>

> ‚ë† [The structural isomers of alkane and recurrence relation](https://jb243.github.io/pages/2412) 

‚ëª Code to Draw All Alkane Substituents Using a Tree Data Structure (Duplicates exist starting from `n_carbons = 6`)

<br>

```python
from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem.rdchem import AtomValenceException
from IPython.display import display

class Node:
    def __init__(self, id):
        self.id = id
        self.children = []

class Tree:
    def __init__(self, root):
        self.nodes = [root]

    def add_node(self, parent_id, node_id, max_nodes):
        if len(self.nodes) >= max_nodes or len(self.nodes[parent_id].children) >= 3:
            return None
        new_node = Node(node_id)
        self.nodes.append(new_node)
        self.nodes[parent_id].children.append(new_node)
        return new_node

def generate_trees(current_tree, current_id, max_nodes):
    if len(current_tree.nodes) == max_nodes:
        if is_valid_tree(current_tree):
            return [current_tree]
        else:
            return []
    
    trees = []
    for node_id in range(len(current_tree.nodes)):
        new_tree = Tree(Node(0))
        new_tree.nodes = [Node(i) for i in range(len(current_tree.nodes))]
        for i in range(len(current_tree.nodes)):
            new_tree.nodes[i].children = [new_tree.nodes[n.id] for n in current_tree.nodes[i].children]

        new_node = new_tree.add_node(node_id, current_id, max_nodes)
        if new_node and is_valid_tree(new_tree):
            trees.extend(generate_trees(new_tree, current_id + 1, max_nodes))
    return trees

def is_valid_tree(tree):
    for node in tree.nodes:
        children_counts = [len(child.children) for child in node.children]
        if any(children_counts[i] > children_counts[i+1] for i in range(len(children_counts)-1)):
            return False
    return True

def visualize_organic_structures(trees):
    mols = []
    for tree in trees:
        mol = Chem.RWMol()
        atom_index = {}
        for node in tree.nodes:
            if node.id == 0:
                atom = Chem.Atom(6)
                atom.SetNumRadicalElectrons(1)  # Set radical electron for the root
            else:
                atom = Chem.Atom(6)
            atom_index[node.id] = mol.AddAtom(atom)
        for node in tree.nodes:
            for child in node.children:
                mol.AddBond(atom_index[node.id], atom_index[child.id], Chem.BondType.SINGLE)
        mols.append(mol)
    return mols

# Input the total number of nodes
n_nodes = 4

# Start with a single root node
initial_tree = Tree(Node(0))
all_trees = generate_trees(initial_tree, 1, n_nodes)
all_mols = visualize_organic_structures(all_trees)

# Visualization
img = Draw.MolsToGridImage(all_mols, molsPerRow=5, subImgSize=(200, 200), useSVG=False)
display(img)
```

<br>

> ‚ë† `n_carbons = 3`: Total 2 sets

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/85341bc8-a102-4dbf-a4d6-bf42ab1869dc)

<br>

> ‚ë° `n_carbons = 4`: Total 4 sets

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/7f8c04f0-ec2f-4b4e-92be-872852a607a0)

<br>

> ‚ë¢ `n_carbons = 5`: Total 8 sets

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/9d744fe8-57fb-4c10-9c50-f67266c9586b)

<br>

> ‚ë£ `n_carbons = 6`: Total 17 sets

<br>

![image](https://github.com/JB243/jb243.github.io/assets/55747737/5342b0fc-85ce-4d5a-ab65-d54851088873)

<br>

<br>

## **3. [Amino Acid](https://jb243.github.io/pages/1391)**

‚ë¥ A function of converting a sequence into an amino acid sequence

<br>

```python
from Bio.Seq import Seq

# Assuming 'sequence' is your string of nucleotides:
sequence = "ACTCATTCTCCCCAGACGCCAAGGATGGTGGTCATGGCGCCCCGAACCCTCTTCCTGCTGCTCTCGGGGGCCCTGACCCTGACCGAGACCTGGGCGG"  # truncated for brevity

# Create a sequence object
seq_obj = Seq(sequence)

# Translate the sequence
amino_acid_sequence = seq_obj.translate(to_stop=True)

# Print the amino acid sequence
print(amino_acid_sequence)
```

<br>

‚ëµ Function to convert gene names into amino acid sequences

<br>

```python
!git clone https://github.com/deepmind/alphafold.git
!cd alphafold/scripts
!sudo apt install aria2
!bash download_uniprot.sh ./

from pathlib import Path

def extract_sequences_from_uniprot(uniprot_fasta_path, gene_list, output_path="selected_genes.fa"):
    """
    Extract the protein sequence of the gene contained in gene_list from the UniProt FASTA file and save it as a .fa file
    """
    result = []
    current_header = ""
    current_seq = []
    include = False
    gene_set = set(g.upper() for g in gene_list)

    with open(uniprot_fasta_path, 'r') as f:
        for line in f:
            if line.startswith('>'):
                if include and current_header and current_seq:
                    result.append((gene_name, ''.join(current_seq)))
                # Start a new sequence
                current_header = line.strip()
                current_seq = []
                include = False
                # Extract the gene name from the header
                if 'GN=' in current_header:
                    try:
                        gene_name = current_header.split('GN=')[1].split()[0].upper()
                        if gene_name in gene_set:
                            include = True
                    except Exception:
                        pass
            else:
                if include:
                    current_seq.append(line.strip())

        # Add the last sequence
        if include and current_header and current_seq:
            result.append((gene_name, ''.join(current_seq)))

    # Save
    if result:
        with open(output_path, 'w') as f:
            for gene, seq in result:
                f.write(f">{gene}\n{seq}\n")
        print(f"‚úÖ {len(result)} sequences saved in '{output_path}'")
    else:
        print("‚ùå The sequence of this gene could not be found.")
        
# üîß Execute an example
gene_list = ['THBS4', 'CD36']
uniprot_fasta_path = "uniprot.fasta"
extract_sequences_from_uniprot(uniprot_fasta_path, gene_list, output_path="genes_from_local_uniprot.fa")

# ‚úÖ 1312 sequences were stored in 'genes_from_local_uniprot.fa'.
```

<br>

‚ë∂ Function to generate PDB files regarding amino acid structure from amino acid sequence using AlphaFold2

> ‚ë† Installing AlphaFold2

<br>

```python
git clone https://github.com/deepmind/alphafold.git
cd alphafold/scripts
sudo apt install aria2

bash download_all_data.sh ./ 
docker build -f docker/Dockerfile -t alphafold . 

docker run --gpus all -it \
  --name alphafold_cpu_session \
  -v "$(pwd)":/app/alphafold \
  -v "$(pwd)/afdb":/mnt/databases \
  -v "$(pwd)/output":/mnt/output \
  --entrypoint /bin/bash \
  alphafold

#docker start -ai alphafold_cpu_session
#docker exec -it alphafold_cpu_session bash
#docker stop alphafold_cpu_session
#docker rm alphafold_cpu_session
```

<br>

> ‚ë° Run AlphaFold 2 Monomer

<br>

```python
#export TF_FORCE_UNIFIED_MEMORY=1           ## for GPU
#export XLA_PYTHON_CLIENT_PREALLOCATE=false ## for GPU
#export XLA_PYTHON_CLIENT_MEM_FRACTION=.85  ## for GPU

export JAX_PLATFORM_NAME=cpu                ## for CPU
export JAX_TRACEBACK_FILTERING=off          ## for CPU

python3 /app/alphafold/run_alphafold.py \
  --fasta_paths=/app/alphafold/data/data.fa \
  --output_dir=/mnt/output \
  --data_dir=/app/alphafold/scripts \
  --model_preset=monomer \
  --db_preset=reduced_dbs \
  --uniref90_database_path=/app/alphafold/scripts/uniref90/uniref90.fasta \
  --mgnify_database_path=/app/alphafold/scripts/mgnify/mgy_clusters_2022_05.fa \
  --small_bfd_database_path=/app/alphafold/scripts/small_bfd/bfd-first_non_consensus_sequences.fasta \
  --pdb70_database_path=/app/alphafold/scripts/pdb70/pdb70 \
  --template_mmcif_dir=/app/alphafold/scripts/pdb_mmcif/mmcif_files \
  --obsolete_pdbs_path=/app/alphafold/scripts/pdb_mmcif/obsolete.dat \
  --max_template_date=2023-12-31 \
  --use_gpu_relax=False
```

<br>

> ‚ë¢ Run AlphaFold 2 Mumtimer

<br>

```python
#export TF_FORCE_UNIFIED_MEMORY=1           ## for GPU
#export XLA_PYTHON_CLIENT_PREALLOCATE=false ## for GPU
#export XLA_PYTHON_CLIENT_MEM_FRACTION=.85  ## for GPU

export JAX_PLATFORM_NAME=cpu                ## for CPU
export JAX_TRACEBACK_FILTERING=off          ## for CPU

python3 /app/alphafold/run_alphafold.py \
  --fasta_paths=/app/alphafold/data/data.fa \
  --output_dir=/mnt/output \
  --data_dir=/app/alphafold/scripts \
  --model_preset=multimer \
  --db_preset=reduced_dbs \
  --uniref90_database_path=/app/alphafold/scripts/uniref90/uniref90.fasta \
  --mgnify_database_path=/app/alphafold/scripts/mgnify/mgy_clusters_2022_05.fa \
  --small_bfd_database_path=/app/alphafold/scripts/small_bfd/bfd-first_non_consensus_sequences.fasta \
  --template_mmcif_dir=/app/alphafold/scripts/pdb_mmcif/mmcif_files \
  --obsolete_pdbs_path=/app/alphafold/scripts/pdb_mmcif/obsolete.dat \
  --pdb_seqres_database_path=/app/alphafold/scripts/pdb_seqres/pdb_seqres.txt \
  --uniprot_database_path=/app/alphafold/scripts/uniprot/uniprot.fasta \
  --max_template_date=1900-01-01 \
  --use_gpu_relax=False
```

<br>

> ‚ë£ [Biopolymer Library](https://jb243.github.io/pages/1327)

‚ë∑ Embedding amino acids with a SMILES embedding function and visualizing them in 2D

<br>

```python
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from transformers import AutoTokenizer, AutoModel
from sklearn.manifold import TSNE
import os

# -------------------------------
# 0) Setting
# -------------------------------
os.environ["TOKENIZERS_PARALLELISM"] = "false"
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
print(f"[INFO] Using device: {DEVICE}")

# -------------------------------
# 1) Define 20 amino acids
# -------------------------------
aa_groups = {
    "Nonpolar": ["Ala","Ile","Leu","Met","Phe","Pro","Trp","Val","Gly"],
    "Polar (uncharged)": ["Asn","Cys","Gln","Ser","Thr","Tyr"],
    "Charged (+)": ["Arg","His","Lys"],
    "Charged (-)": ["Asp","Glu"],
}

aa_1letter = {
    "Ala":"A","Arg":"R","Asn":"N","Asp":"D","Cys":"C","Gln":"Q","Glu":"E","Gly":"G",
    "His":"H","Ile":"I","Leu":"L","Lys":"K","Met":"M","Phe":"F","Pro":"P","Ser":"S",
    "Thr":"T","Trp":"W","Tyr":"Y","Val":"V",
}

amino_acids = sum(aa_groups.values(), [])

AA_SEQ = {
    "Ala": "C[C@@H](C(=O)O)N",
    "Arg": "C(C[C@@H](C(=O)O)N)CN=C(N)N",
    "Asn": "C([C@@H](C(=O)O)N)C(=O)N",
    "Asp": "C(C(C(=O)O)N)C(=O)O",
    "Cys": "C([C@@H](C(=O)O)N)S",
    "Gln": "C(CC(=O)N)[C@@H](C(=O)O)N",
    "Glu": "C(CC(=O)O)[C@@H](C(=O)O)N",
    "Gly": "C(C(=O)O)N",
    "His": "C1=C(NC=N1)C[C@@H](C(=O)O)N",
    "Ile": "CC[C@H](C)[C@@H](C(=O)O)N",
    "Leu": "CC(C)C[C@@H](C(=O)O)N",
    "Lys": "C(CCN)C[C@@H](C(=O)O)N",
    "Met": "CSCC[C@@H](C(=O)O)N",
    "Phe": "C1=CC=C(C=C1)C[C@@H](C(=O)O)N",
    "Pro": "C1C[C@H](NC1)C(=O)O",
    "Ser": "C([C@@H](C(=O)O)N)O",
    "Thr": "C[C@H]([C@@H](C(=O)O)N)O",
    "Trp": "C1=CC=C2C(=C1)C(=CN2)C[C@@H](C(=O)O)N",
    "Tyr": "C1=CC(=CC=C1C[C@@H](C(=O)O)N)O",
    "Val": "CC(C)[C@@H](C(=O)O)N",
}

def get_sequence(aa3):
    s = AA_SEQ.get(aa3, "")
    if isinstance(s, str) and len(s.strip()) > 0:
        return s.strip()
    return aa_1letter[aa3]  # If no input, replace with 1-letter

texts = [get_sequence(a) for a in amino_acids]

# -------------------------------
# 3) Load embedding models
# -------------------------------
MODEL_ID_CHEM = "DeepChem/ChemBERTa-100M-MLM"
MODEL_ID_MOL = "ibm-research/MoLFormer-XL-both-10pct"
tok = AutoTokenizer.from_pretrained(MODEL_ID_MOL, trust_remote_code=True)
model = AutoModel.from_pretrained(MODEL_ID_MOL, trust_remote_code=True).to(DEVICE).eval()

@torch.no_grad()
def embed_smiles_molformer_batch(smiles_list, batch_size=64):
    embeddings = []
    total = len(smiles_list)
    
    for i in range(0, total, batch_size):
        batch = smiles_list[i : i + batch_size]
        
        enc = tok(batch, padding=True, truncation=True, return_tensors="pt")
        enc = {k: v.to(DEVICE) for k, v in enc.items()}
        
        out = model(**enc)
        
        if hasattr(out, "pooler_output") and out.pooler_output is not None:
            emb = out.pooler_output
        else:
            last = out.last_hidden_state
            mask = enc["attention_mask"].unsqueeze(-1)
            emb = (last * mask).sum(1) / mask.sum(1).clamp(min=1)
            
        embeddings.append(emb.cpu().numpy())
            
    return np.vstack(embeddings)

# DataFrame
df = pd.DataFrame({
    "AA": amino_acids,
    "Seq": texts,
    "Group": [g for g, items in aa_groups.items() for _ in items]
})

# -------------------------------
# 4) Embedding + t-SNE
# -------------------------------
X = embed_smiles_molformer_batch(df["Seq"].tolist(), batch_size=16)

tsne = TSNE(n_components=2, perplexity=5, random_state=42, init="pca", learning_rate="auto")
X2 = tsne.fit_transform(X)

df["tSNE1"] = X2[:, 0]
df["tSNE2"] = X2[:, 1]

# -------------------------------
# 5) Visualization (colored by group)
# -------------------------------
color_map = {
    "Nonpolar": "tab:blue",
    "Polar (uncharged)": "tab:green",
    "Charged (+)": "tab:red",
    "Charged (-)": "tab:purple",
}

plt.figure(figsize=(10, 8))

for grp in df["Group"].unique():
    sub = df[df["Group"] == grp]
    plt.scatter(
        sub["tSNE1"], sub["tSNE2"],
        s=140, alpha=0.85, label=grp,
        c=color_map[grp], edgecolors="k", linewidths=0.5
    )

for _, r in df.iterrows():
    plt.text(r["tSNE1"] + 0.5, r["tSNE2"] + 0.5, r["AA"], fontsize=11)

plt.title("20 Amino Acids (Manual sequences) - t-SNE 2D", fontsize=16, fontweight="bold")
plt.xlabel("t-SNE 1", fontsize=14)
plt.ylabel("t-SNE 2", fontsize=14)
plt.legend(fontsize=12)
plt.grid(True, linestyle="--", alpha=0.4)
plt.tight_layout()
plt.show()
```

<br>

<img width="637" height="498" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2026-01-13 ·Ñã·Ö©·Ñí·ÖÆ 4 36 52" src="https://github.com/user-attachments/assets/1e10cf88-e11b-4791-94ea-1609ea9f391c" />

<br>

<br>

## **4. [Spectroscopy](https://jb243.github.io/pages/1404)**

‚ë¥ Overview

> ‚ë† Research on predicting MS, IR, and NMR spectra from chemical formulas or predicting chemical formulas from MS, IR, and NMR data is actively being conducted.

> ‚ë° This research is making significant progress with the advancement of deep learning technology.

>> ‚óã Example: [NMR-TS](https://github.com/tsudalab/NMR-TS)

<br>

<br>

## **5. Reaction Mechanism 

‚ë¥ ASKCOS

‚ëµ AiZynthFinder

‚ë∂ [SPARROW](https://arxiv.org/html/2311.02187v3) 

‚ë∑ Recently, several AI companies‚Äîincluding Chemical.AI‚Äîhave announced AI systems capable of reconstructing organic chemical reactions.

<br>

<img width="1280" height="460" alt="image" src="https://github.com/user-attachments/assets/7b391a8a-88af-4f72-b2ab-86b778a89814" />

<br>

---

_Input: 2023.11.30 02:40_


