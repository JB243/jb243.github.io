## **C语言最短路径算法**（Floyd算法）

更高类别：[C 语言] [C 语言目录](https://jb243.github.io/pages/802)

---

**1\.** [各种距离概念](#1-各种距离-概念)

**2.** [示例1：使用贝尔曼方程的最短路径算法](#2-example-1-shortest-path-algorithm-using-bellman-equation)

**3.** [示例2：Dijkstra算法](#3-example-2-dijkstra-algorithm)

**4\.** 【示例3：C语言实现的最短路径算法】(#4-example-3-shortest-path-algorithm-implemented-in-c-language)

---

**a.** [GitHub](https://github.com/JB243/nate9389/blob/main/C/Floyd%20Algorithm:%20Shortest%20Path%20Algorithm) 

---

<br>

## **1\.**（参考）**各种距离概念**

⑴ [距离函数](https://jb243.github.io/pages/1897#:~:text=%E2%91%A0-,%EA%B1%B0%EB%A6%AC%ED%95%A8%EC%88%98,-(distance%20function%2C%20metric))：定义距离

<br><center><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/ccd7FN/btsiPjG0Ca9/d96m4ynkREQIPulkhR3LS0/img.png" alt="绘图" /></center><br>

⑵ **类型1：** L1距离 

<br><center><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/RnRpu/btsiNbb3RP0/EA4urb8At1q2Qk4EBGnzN0/img.png" alt="绘图" /></center><br>

⑶ **类型2：** L2距离：使用勾股定理的欧氏距离（标准）

<br><center><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/s65ur/btsiJ69LcXe/ctURuxUHS7HKiZbE0fxVP1/img.png" alt="绘图" /></center><br>

⑷ **类型3：** p-范数

<br><center><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/lrCJQ/btsivPajjHM/cwJJHvHwFrzqdKbYu9WDD1/img.png" alt="绘图" /></中心><br>

⑸ **类型4：**点积 

⑹ **类型5：** [linkage metric](https://jb243.github.io/pages/2150#:~:text=%E2%91%B6-,linkage%20metric,-%3A%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%20%EA%B0%84)：定义簇之间的距离

⑺ **类型 6：** [KL距离](https://jb243.github.io/pages/2145#:~:text=%E2%91%A7-,%EC%83%81%EB%8C%80%20%EC%97%94%ED%8A%B8%EB%A1%9C%ED%94%BC,-(相对%20熵%2C)(Kullback-Leibler散度)

⑻ **类型 7：** 汉明距离：通过为每个数据点指定二进制值来测量数据点之间的距离

⑼ **类型8：** 马氏距离：衡量数据的分布情况

<br>

<br>

## **2\.示例 1：使用贝尔曼方程的最短路径算法**

考虑一个有根二叉树网络。每个内部节点 x 有两个子节点，分别表示为 x(lhs) 和 x(rhs)。从 x 移动到其子节点 x(a) 的成本为 l<sub>a</sub>，其中 a ∈ {lhs,rhs}。对于每个节点 x，令 L<sub>x</sub> 为从 x 到叶节点的任何路径的最小成本。对于每个叶节点 y，定义 L<sub>y</sub> = 0。表明对于任何内部节点 x，以下内容成立： 

<br>

<center>L<sub>x</sub> ​= min<sub>a∈{lhs,rhs}</sub> ​ {l<sub>a</sub> + L<sub>x</sub>(a)}.</center>

<br>

证明可以在此[链接](https://www.youtube.com/watch?v=yzZVRXJ0d80&list=PLGboZ4litMr_TOwUANH-s-uFnczzy2uuW)中找到。

<br>

<br>

## **3\.示例 2：Dijkstra 算法**

⑴ **问题**：下图展示了一个带有顶点集（V={A,B,C,D,E,F,G,H}）的有向加权图。使用 Dijkstra 算法，找到从顶点 A 到顶点 H 的最短距离和最短路径。

<br>

<img width="262" height="218" alt="스크린샷 2025-12-12 오후 8 32 37" src="https://github.com/user-attachments/assets/c91b6411-d89d-4183-8032-6d5b8329aa98" />

<br>

⑵ **解决办法**

> ① 初始化

>> ○ d[A]=0, 且所有其他 d[·] = ∞

> ② 从A开始，松弛相邻顶点

>> ○ d[B] = 7, d[D] = 8, d[C] = 12> ③ 未访问过的顶点中，当前最小值为B(7)→从B开始松弛

>> ○ (d[D] = min(当前 d[D], d[B] + 5) = 当前 d[D] = 8) → 无改善

>> ○ d[E] = min(当前 d[E], d[B] + 9) = d[B] + 9 = 16 → 更新为 16

> ④ 未访问顶点中，当前最小值为D(8)→从D开始松弛

>> ○ d[E] = min(当前 d[E], d[D] + 2) = d[D] + 2 = 10 → 更新为 10

>> ○ d[G] = min(当前 d[G], d[D] + 14) = d[D] + 14 = 22 → 更新为 22

>> ○ d[C] = min(当前 d[C], d[D] + 5) = 当前 d[C] = 12 → 无改善

> ⑤ 未访问顶点中，当前最小值为E(10) → 从E开始松弛

>> ○ d[H] = min(当前 d[H], d[E] + 3) = d[E] + 3 = 13 → 更新为 13

> ⑥ 未访问顶点中，当前最小值为C(12)，但(d[H])没有提高

> ⑦ 未访问顶点中，当前最小值为目标顶点H，因此(d[H])最终确定→停止

> ⑧ 结论

>> ○ 最短距离：13

>> ○ 最短路径：A → D → E → H

<br>

<br>

## **4\. C语言实现的最短路径算法**

⑴问题情况：比如从0到5的路径需要花费6，也就是说需要移动6的距离。

<br>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/lP82U/btrzvctwQMU/UKM74ZhG1d0rm3Ar0kOvI1/img.png" alt="绘图" />

<b>表1.</b>问题情况

<br>
 
⑵ Dijkstra算法：特点是for短语的两层嵌套

<br>

__受保护_0__

<br>

⑶弗洛伊德算法（Floyd–Warshall）：特点是三重嵌套的for循环。比 Dijkstra 算法更直观。

<br>

__受保护_1__

<br>

---

*输入：2013 年 12 月 13 日 22:55*