## **第25章数值分析算法集**

推荐帖子：【算法】【算法索引】(https://jb243.github.io/pages/1278)

---

**1.** [托马斯算法](#1-托马斯算法)

**2.** 【高斯消除算法】(#2-gauss-elimination-algorithm)

**3.** [杜利特尔方法](#3-杜利特尔方法)

**4.** [乔列斯基方法](#4-乔列斯基方法)

**5.** [雅可比迭代法](#4-雅可比迭代法)

**6.** [高斯-赛德尔算法](#5-gauss-seidel-算法)

**7.** [改进的欧拉算法（Heum 方法）](#7-improved-euler-algorithm-heum-s-method)

**8.** [经典RUNGE-KUTTA算法](#8-classifcal-runge-kutta-algorithm)

**9.** [改进的RUNGE-KUTTA算法](#9-improved-runge-kutta-algorithm)

**10.** [RUNGE-KUTTA-FEHLBERG 算法](#10-runge-kutta-fehlberg-algorithm)

**11.** [Adams-Bashforth 算法](#11-adams-bashforth-算法)

**12.** [Adams-Moulton 算法](#12-adams-moulton-algorithm)

**13.** [显式方法](#13-显式方法)

**14.** [完全（简单）隐式方法]（#14-完全简单隐式方法）

**15.** [曲柄尼科尔森方法](#15-曲柄尼科尔森方法)

**16.** [积分近似公式](#16-积分近似公式)

**17.** [优化算法](#17-优化算法)

---

<br>

## **1\.托马斯算法** 

A → A* = [a<sub>jk</sub>] = [A**r**]

该算法对三对角矩阵 A 唯一计算 A**x** = [x<sub>j</sub>] 或表明不存在唯一解。

（这里，设 A 的对角线元素为 f、下对角线元素为 e、上对角线元素为 g。）

---

输入：n × (n+1) 的增广矩阵 A* = [a<sub>jk</sub>]，其中 a<sub>j, n+1</sub> = b<sub>j</sub>

输出：方程 (1) 的解 **x** = [x<sub>j</sub>] 或指示无唯一解的消息

> // 分解

> DO k = 2, ..., n

>> e<sub>k</sub> = e<sub>k</sub> / f<sub>k-1</sub>

>> f<sub>k</sub> = f<sub>k</sub> \- e<sub>k</sub> × g<sub>k-1</sub>

> 结束

> // 前向替换

> DO k = 2, ..., n

>> r<sub>k</sub> = r<sub>k</sub> \- e<sub>k</sub> × r<sub>k-1</sub>

> 结束

> // 向后替换

> x<sub>n</sub> = r<sub>n</sub> / f<sub>n</sub>

> DO k = n - 1, ..., 1

>> x<sub>k</sub> = (r<sub>k</sub> \- g<sub>k</sub> × x<sub>k+1</sub>) / f<sub>k</sub>

> 结束

结束高斯

---

<br>

<br>

## **2\.高斯消去算法** 

A → A* = [a<sub>jk</sub>] = [A**b**]

该算法唯一计算 A**x** = **b** 的 **x** = [x<sub>j</sub>] 或表明不存在唯一解。

---

输入：n × (n+1) 的增广矩阵 A* = [a<sub>jk</sub>]，其中 a<sub>j, n+1</sub> = b<sub>j</sub>

输出：方程 (1) 的解 **x** = [x<sub>j</sub>] 或指示无唯一解的消息

> 对于 k = 1, ..., n - 1 执行：

>> m = k

>> 对于 j = k + 1, ..., n，执行：

>>> 如果 |a<sub>mk</sub>| < |a<sub>jk</sub>|那么 m = j 结束

>> 结束

>> 如果 a<sub>mk</sub> = 0 那么

>>> 输出“没有唯一的解决方案”

>>> 停止

>> 结束

>> 否则将 k 行与 m 行交换

>> 对于 j = k + 1, ..., n，执行：

>>> m<sub>jk</sub> = a<sub>jk</sub> / a<sub>kk</sub>

>>> 对于 p = k + 1, ..., n + 1，执行：

>>>> a<sub>jp</sub> = a<sub>jp</sub> \- m<sub>jk</sub>a<sub>kp</sub>

>>> 结束

>> 结束

> 结束

> 如果 a<sub>nn</sub> = 0 那么

>> 输出“没有唯一的解决方案”

>> 停止

> 结束

> x<sub>n</sub> = a<sub>n,n+1</sub> / a<sub>nn</sub> [开始向后替换]

> 对于 i = n - 1, ..., 1，执行：

>> x<sub>i</sub> = (1/a<sub>ii</sub>)(a<sub>i,n+1</sub> \- (a<sub>i,i+1</sub>x<sub>i+1</sub> \+ ... + a<sub>i, n</sub>x<sub>n</sub>))

> 结束

> 输出 x = [x<sub>j</sub>]

> 停止

结束高斯

---

<br>

<br>

## **3\.杜利特尔法**

---

A**x** = LU**x** = **b**

U**x** = L<sup>-1</sup>**b** = **y**

**x** = U<sup>-1</sup>**y**

---

<br>

<br>

## **4\.乔列斯基法**---

A**x** = LL<sup>T</sup>**x** = **b**

L<sup>T</sup>**x** = L<sup>-1</sup>**b** = **y**

**x** = (L<sup>T</sup>)<sup>-1</sup>**y**

---

<br>

<br>

## **5\.雅可比迭代法**

---

例如

> x<sub>1</sub> \- 0.25x<sub>2</sub> \- 0.25x<sub>3</sub> = 50 ⇔ x<sub>1</sub> = 0.25x<sub>2</sub> \+ 0.25x<sub>3</sub> \+ 50

> -0.25x<sub>1</sub> \+ x<sub>2</sub> \- 0.25x<sub>4</sub> = 50 ⇔ x<sub>2</sub> = 0.25x<sub>1</sub> \+ 0.25x<sub>4</sub> \+ 50

> -0.25x<sub>1</sub> \+ x<sub>3</sub> \- 0.25x<sub>4</sub> = 25 ⇔ x<sub>3</sub> = 0.25x<sub>1</sub> \+ 0.25x<sub>4</sub> \+ 25

> -0.25x<sub>2</sub> \- 0.25x<sub>3</sub> \+ x<sub>4</sub> = 25 ⇔ x<sub>4</sub> = 0.25x<sub>2</sub> \+ 0.25x<sub>3</sub> \+ 25

参见

> **x**<sup>(m+1)</sup> = **b** \- L**x**<sup>(m)</sup> \- U**x**(m) = **b** \- (L+U)**x**<sup>(m)</sup>

---

<br>

<br>

**6\.高斯-赛德尔算法** 

A, **b** , **x**(0), ε, N

该算法在给定 n × n 矩阵 A = [a<sub>jk</sub>] 的初始近似 **x**<sup>(0)</sup> 的情况下，计算 A**x** = **b** 的解 **x**，其中，对于 j = 1, ..., n，a<sub>jj</sub> ≠ 0。

---

输入：A，**b**，初始近似**x**<sup>(0)</sup>，容差ε，最大迭代次数N

输出：近似值 **x**<sup>(m)</sup> = [**x** <sub>j</sub><sup>(m)</sup>] 或指示 **x**<sup>(N)</sup> 不满足容差条件的错误消息

> 对于 m = 0, ..., N - 1 执行：

>> 对于 j = 1, ..., n 执行：

>>> x<sub>j</sub><sup>(m)</sup> = (1/a<sub>jj</sub>)(b<sub>j</sub> \- (a<sub>j1</sub>x<sub>1</sub><sup>(m+1)</sup> \+ ... + a<sub>j, j-1</sub>x<sub>j-1</sub><sup>(m+1)</sup>) - (a<sub>j, j+1</sub>x<sub>j+1</sub><sup>(m)</sup> \+ ... + a<sub>jn</sub>x<sub>n</sub><sup>(m)</sup>))

>> 结束

>> 如果 <sup>∀</sup>j, |x<sub>j</sub><sup>(m+1)</sup> \- x<sub>j</sub><sup>(m)</sup>|然后

>>> 输出 **x**<sup>(m+1)</sup>

>>> 停止

>> 结束

> 结束

> 输出

结束高斯-赛德尔

例如

> x<sub>1</sub> - 0.25x<sub>2</sub> - 0.25x<sub>3</sub> = 50 ⇔ x<sub>1</sub> = 0.25x<sub>2</sub> + 0.25x<sub>3</sub> + 50

> -0.25x<sub>1</sub> + x<sub>2</sub> - 0.25x<sub>4</sub> = 50 ⇔ x<sub>2</sub> = 0.25x<sub>1</sub> + 0.25x<sub>4</sub> + 50

> -0.25x<sub>1</sub> + x<sub>3</sub> - 0.25x<sub>4</sub> = 25 ⇔ x<sub>3</sub> = 0.25x<sub>1</sub> + 0.25x<sub>4</sub> + 25

> -0.25x<sub>2</sub> - 0.25x<sub>3</sub> + x<sub>4</sub> = 25 ⇔ x<sub>4</sub> = 0.25x<sub>2</sub> + 0.25x<sub>3</sub> + 25

参见 

> **x**<sup>(m+1)</sup> = **b** - L**x**<sup>(m+1)</sup> - U**x**<sup>(m)</sup> ⇔ **x**<sup>(m+1)</sup> = (I + L)<sup>-1</sup>**b** - (I + L)<sup>-1</sup>U**x**<sup>(m)</sup>

<br>

<br>

## **7.改进的欧拉算法（Heum 法）** 

f、x<sub>0</sub>、y<sub>0</sub>、h、N

该算法解决等距点 x<sub>1</sub> = x<sub>0</sub> + h、x<sub>2</sub> = x<sub>0</sub> + 2h、...、x<sub>N</sub> = x<sub>0</sub> + Nh 处的初始值问题 y' = f(x, y)、y(x<sub>0</sub>) = y<sub>0</sub>。

这里，f 是定义在 [x<sub>0</sub>, x<sub>N</sub>] 上的函数，保证唯一的解决方案。

---

INPUT：初始值x<sub>0</sub>，y<sub>0</sub>，步长h，步数N

输出：在 x<sub>n+1</sub> = x<sub>0</sub> + (n+1)h (n = 0, ..., N-1) 处解 y(x<sub>n+1</sub>) 的近似值 y<sub>n+1</sub>

> 对于 n = 0, 1, ..., N-1 执行：

>> x<sub>n+1</sub> = x<sub>n</sub> + h

>> k<sub>1</sub> = hf(x<sub>n</sub>, y<sub>n</sub>)

>> k<sub>2</sub> = hf(x<sub>n+1</sub>, y<sub>n</sub>+k<sub>1</sub>)

>> y<sub>n+1</sub> = y<sub>n</sub> + 0.5(k<sub>1</sub> + k<sub>2</sub>)

>> 输出 x<sub>n+1</sub>, y<sub>n+1</sub>

> 结束

> 停止

结束欧拉

---

<br>

<br>

## **8.经典的 RUNGE-KUTTA 算法** 

f、x<sub>0</sub>、y<sub>0</sub>、h、N该算法解决等距点 x<sub>1</sub> = x<sub>0</sub> + h、x<sub>2</sub> = x<sub>0</sub> + 2h、...、x<sub>N</sub> = x<sub>0</sub> + Nh 处的初始值问题 y' = f(x, y)、y(x<sub>0</sub>) = y<sub>0</sub>。

这里，f 是定义在 [x<sub>0</sub>, x<sub>N</sub>] 上的函数，保证唯一的解决方案。

---

INPUT：初始值x<sub>0</sub>，y<sub>0</sub>，步长h，步数N

输出：在 x<sub>n+1</sub> = x<sub>0</sub> + (n+1)h (n = 0, ..., N-1) 处解 y(x<sub>n+1</sub>) 的近似值 y<sub>n+1</sub>

> 对于 n = 0, 1, ..., N-1 执行：

>> k<sub>1</sub> = hf(x<sub>n</sub>, y<sub>n</sub>)

>> k<sub>2</sub> = hf(x<sub>n</sub> + 0.5h, y<sub>n</sub> + 0.5k<sub>1</sub>)

>> k<sub>3</sub> = hf(x<sub>n</sub> + 0.5h, y<sub>n</sub> + 0.5k<sub>2</sub>)

>> k<sub>4</sub> = hf(x<sub>n</sub> + h, y<sub>n</sub> + k<sub>3</sub>)

>> x<sub>n+1</sub> = x<sub>n</sub> + h

>> y<sub>n+1</sub> = y<sub>n</sub> + (1/6)(k<sub>1</sub> + 2k<sub>2</sub> + 2k<sub>3</sub> + k<sub>4</sub>)

>> 输出 x<sub>n+1</sub>, y<sub>n+1</sub>

> 结束

> 停止

结束龙格-库塔

---

<br>

<br>

## **9。改进的 RUNGE-KUTTA 算法** 

f、x<sub>0</sub>、y<sub>0</sub>、h、N

该算法解决等距点 x<sub>1</sub> = x<sub>0</sub> + h、x<sub>2</sub> = x<sub>0</sub> + 2h、...、x<sub>N</sub> = x<sub>0</sub> + Nh 处的初始值问题 y' = f(x, y)、y(x<sub>0</sub>) = y<sub>0</sub>。

这里，f 是定义在 [x<sub>0</sub>, x<sub>N</sub>] 上的函数，保证唯一的解决方案。

---

INPUT：初始值x<sub>0</sub>，y<sub>0</sub>，步长h，步数N

输出：在 x<sub>n+1</sub> = x<sub>0</sub> + (n+1)h (n = 0, ..., N-1) 处解 y(x<sub>n+1</sub>) 的近似值 y<sub>n+1</sub>

> 对于 n = 0, 1, ..., N-1 执行：

>> k<sub>1</sub> = hf(x<sub>n</sub>, y<sub>n</sub>)

>> k<sub>2</sub> = hf(x<sub>n</sub> + (1/4)h, y<sub>n</sub> + (1/4)k<sub>1</sub>)

>> k<sub>3</sub> = hf(x<sub>n</sub> + (3/8)h, y<sub>n</sub> + (3/32)k<sub>1</sub> + (9/32)k<sub>2</sub>)

>> k<sub>4</sub> = hf(x<sub>n</sub> + (12/13)h, y<sub>n</sub> + (1932/2197)k<sub>1</sub> - (7200/2197)k<sub>2</sub> + (7296/2197)k<sub>3</sub>)

>> k<sub>5</sub> = hf(x<sub>n</sub> + h, y<sub>n</sub> + (439/216)k<sub>1</sub> - 8k<sub>2</sub> + (3680/513)k<sub>3</sub> - (845/4104)k<sub>4</sub>)

>> x<sub>n+1</sub> = x<sub>n</sub> + h

>> y<sub>n+1</sub> = y<sub>n</sub> + (25/216)k<sub>1</sub> + (1408/2565)k<sub>3</sub> + (2197/4104)k<sub>4</sub> - (1/5)k<sub>5</sub>

>> 输出 x<sub>n+1</sub>, y<sub>n+1</sub>

> 结束

> 停止

结束龙格-库塔

---

<br>

<br>

## **10。龙格-库塔-菲尔伯格算法** 

f、x<sub>0</sub>、y<sub>0</sub>、h、N

该算法解决等距点 x<sub>1</sub> = x<sub>0</sub> + h、x<sub>2</sub> = x<sub>0</sub> + 2h、...、x<sub>N</sub> = x<sub>0</sub> + Nh 处的初始值问题 y' = f(x, y)、y(x<sub>0</sub>) = y<sub>0</sub>。

这里，f 是定义在 [x<sub>0</sub>, x<sub>N</sub>] 上的函数，保证唯一的解决方案。

---

INPUT：初始值x<sub>0</sub>，y<sub>0</sub>，步长h，步数N

输出：在 x<sub>n+1</sub> = x<sub>0</sub> + (n+1)h (n = 0, ..., N-1) 处解 y(x<sub>n+1</sub>) 的近似值 yn+1

> 对于 n = 0, 1, ..., N-1 执行：

>> k<sub>1</sub> = hf(x<sub>n</sub>, y<sub>n</sub>)

>> k<sub>2</sub> = hf(x<sub>n</sub> + (1/4)h, y<sub>n</sub> + (1/4)k<sub>1</sub>)

>> k<sub>3</sub> = hf(x<sub>n</sub> + (3/8)h, y<sub>n</sub> + (3/32)k<sub>1</sub> + (9/32)k<sub>2</sub>)

>> k<sub>4</sub> = hf(x<sub>n</sub> + (12/13)h, y<sub>n</sub> + (1932/2197)k<sub>1</sub> - (7200/2197)k<sub>2</sub> + (7296/2197)k<sub>3</sub>)

>> k<sub>5</sub> = hf(x<sub>n</sub> + h, y<sub>n</sub> + (439/216)k<sub>1</sub> - 8k<sub>2</sub> + (3680/513)k<sub>3</sub> - (845/4104)k<sub>4</sub>)>> k<sub>6</sub> = hf(x<sub>n</sub> + (1/2)h, y<sub>n</sub> - (8/27)k<sub>1</sub> + 2k<sub>2</sub> + (3544/2565)k<sub>3</sub> - (1859/4104)k<sub>4</sub> - (11/40)k<sub>5</sub>)

>> x<sub>n+1</sub> = x<sub>n</sub> + h

>> y<sub>n+1</sub> = y<sub>n</sub> + (16/135)k<sub>1</sub> + (6656/12825)k<sub>3</sub> + (28561/56430)k<sub>4</sub> - (9/50)k<sub>5</sub> + (2/55)k<sub>6</sub>

>> 输出 x<sub>n+1</sub>, y<sub>n+1</sub>

> 结束

> 停止

结束龙格-库塔

---

<br>

<br>

## **11。 Adams-Bashforth 算法** 

x<sub>n</sub>、x<sub>n-1</sub>、x<sub>n-2</sub>、x<sub>n-3</sub>、f<sub>n</sub>、f<sub>n-1</sub>、f<sub>n-2</sub>、f<sub>n-3</sub>、h、N

该算法考虑在某些包含 x<sub>0</sub> 的开区间中具有唯一解的初始值问题：

y' = f(x, y), y(x<sub>0</sub>) = y<sub>0</sub>, f<sub>n</sub> = f(x<sub>n</sub>, y<sub>n</sub>)。

该方法使用牛顿后向差分公式将被积函数 f(x, y(x)) 替换为插值多项式，然后对其进行积分。

---

输入：x<sub>n</sub>、x<sub>n-1</sub>、x<sub>n-2</sub>、x<sub>n-3</sub>、f<sub>n</sub>、f<sub>n-1</sub>、f<sub>n-2</sub>、f<sub>n-3</sub>、h、N

输出：步骤 x<sub>n+m</sub> = x<sub>0</sub> + (n+m)h (m = 1, ..., N) 处的解 y(x<sub>n+m</sub>) 的近似值 yn+m

> k<sub>4</sub> = hf<sub>n</sub>

> k<sub>3</sub> = hf<sub>n-1</sub>

> k<sub>2</sub> = hf<sub>n-2</sub>

> k<sub>1</sub> = hf<sub>n-3</sub>

> 对于 m = 1, ..., N 执行：

>> x<sub>n+m</sub> = x<sub>n+m-1</sub> + h

>> y<sub>n+m</sub> = y<sub>n+(m-1)</sub> + (1/24)(55k<sub>4</sub> - 59k<sub>3</sub> + 37k<sub>2</sub> - 9k<sub>1</sub>)

>> k<sub>1</sub> = k<sub>2</sub>

>> k<sub>2</sub> = k<sub>3</sub>

>> k<sub>3</sub> = k<sub>4</sub>

>> k<sub>4</sub> = hf(x<sub>n+m</sub>, y<sub>n+m</sub>)

>> 输出 x<sub>n+m</sub>, y<sub>n+m</sub>

> 结束

> 停止

结束 ADAMS-巴什福斯

---

<br>

<br>

## **12。亚当斯-莫尔顿算法** 

x<sub>n</sub>、x<sub>n-1</sub>、x<sub>n-2</sub>、x<sub>n-3</sub>、f<sub>n</sub>、f<sub>n-1</sub>、f<sub>n-2</sub>、f<sub>n-3</sub>、h、N

该算法考虑在某些包含 x0 的开区间中具有唯一解的初始值问题：

y' = f(x, y), y(x<sub>0</sub>) = y<sub>0</sub>, f<sub>n</sub> = f(x<sub>n</sub>, y<sub>n</sub>)。

该方法添加了预测器-校正器步骤。误差估计如下：

ε<sub>n+1</sub> = (1/15)(y<sub>n+1</sub> - y*<sub>n+1</sub>)。

---

输入：x<sub>n</sub>、x<sub>n-1</sub>、x<sub>n-2</sub>、x<sub>n-3</sub>、f<sub>n</sub>、f<sub>n-1</sub>、f<sub>n-2</sub>、f<sub>n-3</sub>、h、N

输出：步骤 x<sub>n+m</sub> = x<sub>0</sub> + (n+m)h (m = 1, ..., N) 处的解 y(x<sub>n+m</sub>) 的近似值 yn+m

> k<sub>4</sub> = hf<sub>n</sub>

> k<sub>3</sub> = hf<sub>n-1</sub>

> k<sub>2</sub> = hf<sub>n-2</sub>

> k<sub>1</sub> = hf<sub>n-3</sub>

> 对于 m = 1, ..., N 执行：

>> x<sub>n+m</sub> = x<sub>n+m-1</sub> + h

>> y*<sub>n+m</sub> = y<sub>n+(m-1)</sub> + (1/24)(55k<sub>4</sub> - 59k<sub>3</sub> + 37k<sub>2</sub> - 9k<sub>1</sub>)

>> k* = f(x<sub>n+m</sub>, y*<sub>n+m</sub>)

>> y<sub>n+m</sub> = y<sub>n+(m-1)</sub> + (1/24)(9k* + 19k<sub>4</sub> - 5k<sub>3</sub> + k<sub>2</sub>)

>> k<sub>1</sub> = k<sub>2</sub>

>> k<sub>2</sub> = k<sub>3</sub>

>> k<sub>3</sub> = k<sub>4</sub>

>> k<sub>4</sub> = hf(x<sub>n+m</sub>, y<sub>n+m</sub>)

>> 输出 x<sub>n+m</sub>, y<sub>n+m</sub>

> 结束

> 停止

结束 亚当斯-莫尔顿

---

<br>

<br>

## **13。显式方法**

---

**x**<sup>(m+1)</sup> = A**x**<sup>(m)</sup> + **b**

例如

> 3×3：A = ((1 - 2λ, λ, 0)<sup>T</sup>, (λ, 1 - 2λ, λ)<sup>T</sup>, (0, λ, 1 - 2λ)<sup>T</sup>), b = (λx<sub>0</sub>, 0, λx<sub>n+1</sub>)<sup>T</sup>

---

<br>

<br>

## **14。完全（简单）隐式方法**

---**x**<sup>(m+1)</sup> = A<sup>-1</sup>**x**<sup>(m)</sup> - A<sup>-1</sup>**b**

 例如

> 3×3: A = ((1 + 2λ, -λ, 0)<sup>T</sup>, (-λ, 1 + 2λ, -λ)<sup>T</sup>, (0, -λ, 1 + 2λ)<sup>T</sup>), b = (λx<sub>0</sub>, 0, λx<sub>n+1</sub>)<sup>T</sup>

---

<br>

<br>

## **15。曲柄尼科尔森法**

---

**x**<sup>(m+1)</sup> = A<sub>im</sub><sup>-1</sup>(A<sub>ex</sub>**x**<sup>(m)</sup> + **b**<sub>ex</sub>) - A<sup>-1</sup>**b**<sub>im</sub>

例如

> 3×3: A = ((1 + 2λ, -λ, 0)<sup>T</sup>, (-λ, 1 + 2λ, -λ)<sup>T</sup>, (0, -λ, 1 + 2λ)<sup>T</sup>), b = (λx<sub>0</sub>, 0, λx<sub>n+1</sub>)<sup>T</sup>

---

<br>

<br>

## **16。积分近似公式**

 ⑴ 梯形法则
 
> ①数值积分法。

> ② **证明：** 假设f是线性的（一次）并证明等式在单位区间上成立。

<br>
 
<img width="484" alt="스크린샷 2024-12-04 11 40 59" src="https://github.com/user-attachments/assets/c22c581e-804e-4bc2-bce1-fe1b118f03d9">

<br>

 ⑵ 辛普森法则
 
> ①数值积分法 

> ② **证明：** 假设f是二次（抛物线）并证明等式在单位区间上成立。

> ③ 比梯形法则更准确。

<br>

<img width="561" alt="스크린샷 2024-12-04 11 41 19" src="https://github.com/user-attachments/assets/d78329cf-c3e7-4e7c-9e3c-fba67960014e">

<br>

 ⑶ 辛普森3/8规则

> ①数值积分法

> ② **证明：** 假设f是三次方（三次）并证明等式在单位区间上成立

> ③ 比辛普森法则更准确。

<br>

<img width="602" alt="스크린샷 2024-12-04 11 41 32" src="https://github.com/user-attachments/assets/7ade3e12-6248-466c-aa8a-350d00f1a82d">

<br>

⑷ 波德法则

<br>

<img width="690" alt="스크린샷 2024-12-04 11 41 49" src="https://github.com/user-attachments/assets/5effb035-01e1-4374-a5a5-926d3e0ef122">

<br>

⑸ 移动平均法

## **17。优化算法**

⑴【牛顿-拉夫逊法】(https://jb243.github.io/pages/1773)

⑵【最优传输定理】(https://jb243.github.io/pages/2386)

⑶ [Nelder-Mead 方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-neldermead.html#optimize-minimize-neldermead)

<br>

__受保护_0__

<br>

⑷【鲍威尔法】(https://docs.scipy.org/doc/scipy/reference/optimize.minimize-powell.html#optimize-minimize-powell)

⑸ [CG方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-cg.html#optimize-minimize-cg)

⑹【BFGS方法】(https://www.sciencedirect.com/science/article/pii/0009261485805741?viaihub)

> ①定义：近似Hessian矩阵的逆，以减少牛顿法的计算量。

> ② 公式

<br>

<img width="581" alt="스크린샷 2024-12-04 11 42 24" src="https://github.com/user-attachments/assets/26ec8387-1513-48a0-a73b-ca0b30df9f3d">

<br>

⑺ [L-BFGS-B方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb)

⑻【TNC方法】(https://docs.scipy.org/doc/scipy/reference/optimize.minimize-tnc.html#optimize-minimize-tnc)

⑼ [COBYLA方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-cobyla.html#optimize-minimize-cobyla)

⑽ 【SLSQP方法】(https://docs.scipy.org/doc/scipy/reference/optimize.minimize-slsqp.html#optimize-minimize-slsqp)

⑾ [信任约束方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)

⑿ 【狗腿法】(https://docs.scipy.org/doc/scipy/reference/optimize.minimize-dogleg.html#optimize-minimize-dogleg)

⒀ [牛顿CG方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-newtoncg.html#optimize-minimize-newtoncg)⒁ [Trust-NCG 方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-trustncg.html#optimize-minimize-trustncg)

⒂ [信任精确方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-trustexact.html#optimize-minimize-trustexact)

⒃ [Trust-Krylov 方法](https://docs.scipy.org/doc/scipy/reference/optimize.minimize-trustkrylov.html#optimize-minimize-trustkrylov)

⒄ 涅斯特罗夫法

⒅ SANN（模拟退火）

> ① 一种慢速随机全局优化方法。

> ② 适用于不可微分或非凸函数。

⒆ 与编程相关

> ① 优化算法相关的R包及函数：RSolnp、optim、GenSA、alabama

<br>

---

_输入：2016.12.11 02:10_

_修改时间：2024.03.28 22:20_