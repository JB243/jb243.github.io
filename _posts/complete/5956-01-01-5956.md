## **第 20 章. 自动编码器**

推荐帖子：【算法】【算法目录】(https://jb243.github.io/pages/1278)

---

**1.** [概述](#1-概述)

**2.类型 1.** [变分自动编码器](#2-type-1-变分自动编码器)

**3.类型 2.** [图自动编码器](#3-type-2-graph-autoencoder)

**4.类型 3.** [矩阵分解](#4-type-3-矩阵分解)

**5.类型 4.** [潜在主题模型](#5-type-4-潜在主题模型)

**6。类型 5.** [生成对抗网络](#6-type-5-generative-adversarial-network)

**7.类型6.** [流量模型](#7-type-6-flow-model)

---

<br>

## **1.概述**

 ⑴ 定义：尽可能压缩输入数据，然后将压缩数据重建回原始形式的神经网络

> ① **编码器**：从输入层到隐藏层的人工神经网络。也称为**识别网络**

>> ○ 识别网络：检测模式并分配含义的专用网络

> ② **解码器**：从隐藏层到输出层的人工神经网络。也称为**生成网络**

>> ○ 生成网络：能够生成与输入数据非常相似的新数据的网络

>> ○ 在自动编码器中，解码器应该尽可能简单：因此解码器中不经常使用GCN。

> ③ 编码器和解码器一起训练

<br>

![图片](https://github.com/user-attachments/assets/db77c95f-6d19-4873-86f7-f2f92799153e)

**图 1.** 自动编码器的结构

<br>

⑵ 形式化

> Z = E<sub>θ</sub>(X), X̂ = D<sub>ψ</sub>(Z)

> ① Z：潜变量

> ② E<sub>θ</sub>：编码器网络

> ③ X̂：重构输入

> ④ D<sub>phi</sub>：解码器网络

 ⑶ 特点

> ① 无监督学习神经网络

> ②编码器进行降维

> ③ 解码器充当生成模型

> ④ 输入层节点数等于输出层节点数

> ⑤ 隐藏层节点数少于输入层节点数

> ⑥ [降维算法](https://jb243.github.io/pages/2158)也可以被认为是自动编码器的例子

 ⑷ 效果

> ① **效果1.** 数据压缩：如果隐藏层的节点数少于输入层，则网络可以压缩输入数据

> ② **效果2.** 数据抽象：将复杂数据转换为多维向量，实现输入数据的分类或重组

>> ○ 这些多维向量也称为隐藏层或特征

>> ○ PCA是代表性的重组算法

> ③ **效果3.** 潜在变量推断：如果形成输入数据的先验被视为潜在变量，则自动编码器可以推断它们

>> ○ 也称为反卷积

<br>

<br>

## **2.类型 1.** 变分自动编码器

 ⑴ 概述

> ① 使用潜在空间和[变分推理](https://jb243.github.io/pages/2145)合并已知的概率分布

> ② 根据分布类型，示例包括 ZINB 自动编码器（零膨胀负二项式自动编码器）

 ⑵ 结构

> ① 编码器：将输入数据映射为隐藏层中的概率分布，即参数化分布

> ② 解码器：将参数化分布视为贝叶斯推理中的先验，映射到输出层

>> ○ 训练：使用成本函数最小化参数后验和真实后验之间的差异

> ③ 与自动编码器的区别：自动编码器是**确定性的**，而变分自动编码器是**概率性的**

> ④ 变分自动编码器自然地比常规自动编码器执行更好的潜在匹配

 ⑶ 形式化

> Z ~ q<sub>θ</sub>(Z | X), X̂ = D<sub>ψ</sub>(Z)

> ① Z：潜变量> ② q<sub>θ</sub>：条件概率分布

> ③ X̂：重构输入

> ④【AE与VAE损失函数的区别】(https://jb243.github.io/pages/2432) 

⑷ **应用1.** [β-VAE](https://openreview.net/pdf?id=Sy2fzU9gl)：每个嵌入轴分别对应年龄、性别、种族 

<br>

<br>

## **3。类型 2.** 图自动编码器 

 ⑴ 利用【图论】(https://jb243.github.io/pages/616)和拉普拉斯矩阵，定义了类似于自动编码器的损失函数

<br>

![图片](https://github.com/user-attachments/assets/16cfe8fe-3708-47e0-9939-e0f01273ebb0)

<br>

 ⑵ 当图自编码器与变分推理相结合时，称为变分图自编码器（VGAE）

 ⑶【AE、GAE、VAE、VGAE损失函数比较】(https://jb243.github.io/pages/2432)

<br>

<br>

## **4。类型 3.** 矩阵分解

 ⑴ 定义：将已知矩阵A分解为矩阵W和H的乘积的算法。A ~ W × H

> ① 矩阵A：代表样本特征。从样本可知

> ② 矩阵H：代表可变特征

> ③ 类似于K-means聚类和PCA

> ④ 由于自动编码器包含非线性变换，因此它们是比矩阵分解更广泛的概念

> ⑤ 以下算法基于最小二乘法，但也可以使用[梯度下降法](https://jb243.github.io/pages/1140#:1., 9% 98 95,-\(Gradientdescent))

 ⑵ 算法：求U和V，使得R = UV，R ε ℝ<sup>5×4</sup>，U ε ℝ<sup>5×2</sup>，V ε ℝ<sup>2×4</sup>

<br>

__受保护_0__

<br>

 ⑶ **3-1.** **NMF**（非负矩阵分解）

<br>

__受保护_1__

<br>

 ⑷ **3-2.** **矩阵补全**（Netflix 算法）：对 masked R 执行矩阵分解

<br>

__受保护_2__

<br>

 ⑸ **3-3.** [**SVD**](https://jb243.github.io/pages/2158)（奇异值分解）

 ⑹ **应用1.** 细胞类型分类

> ① 从组织收集的 scRNA-seq 数据中获取细胞类型比例

> ② 减少细胞类型异质性造成的混杂影响很重要

> ③ **1-1.** 约束线性回归

> ④ **1-2.** 基于参考的方法

>> ○ **1-2-1.** CIBERSORT（通过估计 RNA 转录本的相对子集进行细胞类型识别）：可以检查每个样本的细胞类型比例和 p 值

 ⑺ **应用2.** 联合NMF：能够扩展到多组学

 ⑻ **应用3.** 元基因提取

 ⑼ **应用4.** [Starfysh](https://www.nature.com/articles/s41587-024-02173-8#Methods)：一种推断空间转录组学中的原型并确定每个原型的代表性锚点的算法。

> ① **步骤1.** 构建自动编码器

>> Y = WBX

>> ○ X ∈ ℝ<sup>S×G</sup>：输入数据（点×基因）

>> ○ D: 原型数量

>> ○ B ∈ ℝ<sup>D×S</sup>：编码器。推断原型；对于每个原型，所有点的总分布必须为 1

>> ○ H = BX：潜变量

>> ○ W ∈ ℝ<sup>S×D</sup>：解码器。重建输入数据；对于每个点，原型的总权重必须为 1。

>> ○ Y = WBX：重构输入

> ② **步骤2.** 求解优化算法来计算W和B

<br>

<img width="373" alt="스크린샷 2025-06-22 오후 7 17 42" src="https://github.com/user-attachments/assets/0f21c504-b694-4bec-96df-be181b73cd84" />

<br>

> ③ **步骤3.** 选择W矩阵中每个原型权重最高的点作为锚点

> ④ **步骤4.** 粒度调整：当原型之间的距离很近时，使用层次结构进行合并或调整

> ⑤ **步骤 5.** 对于每个锚点，搜索最近的点以形成原型群落并识别标记基因> ⑥ **步骤6.** 如果给定了特征基因集，则将原型标记基因添加到现有集合中并重新计算锚点

>> ○ 在这种情况下，使用稳定的婚姻匹配算法将每个原型与最相似的签名配对

<br>

<br>

## **5。类型 4.** 潜在主题模型

 ⑴ **4-1.** 一元语法

 ⑵ **4-2.** LSI（潜在语义索引）

> ① **应用1.** 概率LSI

>> ○ **限制 1.** 不适合作为自然语言文档的生成模型：难以对未见过的文档进行概率建模

>> ○ **限制2.** 参数数量随着训练中使用的文档数量线性增加

 ⑶ **4-3.** 潜在狄利克雷分配（[LDA](https://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf)）

> ① 概述

>> ○ 定义：给定一个文档×词的比例，将其分为文档×主题和主题×词的比例。

>> ○ 在LDA模型中，潜在多项式变量称为主题。

>> ○ 与NMF类似，生成稀疏矩阵

> ② 公式：对于文档d的主题分布θ<sub>d</sub>，以及主题k的词分布β<sub>k</sub>，

<br>

<img width="162" height="68" alt="스크린샷 2025-08-06 오후 5 14 46" src="https://github.com/user-attachments/assets/bc5fc3a4-b5d3-49b7-856b-dab71c3049dc" />

<br>

> ③ **应用1.** 形式化

>> ○ 前提：参数α、β、主题混合联合分布θ、大小为N的主题集**z**、大小为N的词集**w**

>> ○ 目标：利用[贝叶斯定理](https://jb243.github.io/pages/1623#:-,,-\(Bayestheroem\))求θ和**z**。

<br>

<img width="263" alt="스크린샷 2025-06-22 7 18 38" src="https://github.com/user-attachments/assets/c5017a0c-5566-4f35-8907-0250f5b01b1f" />

<br>

>> ○ 联合概率分布

<br>

<img width="401" alt="스크린샷 2025-06-22 7 18 57" src="https://github.com/user-attachments/assets/e23490ab-e061-4492-9dac-50c17876e5d2" />

<br>

>> ○ 使用变分 EM（期望最大化）来查找 θ 和 **z**

> ④ **应用2.** 两层模型：关于隐藏主题变量z

<br>

<img width="302" alt="스크린샷 2025-06-22 7 19 30" src="https://github.com/user-attachments/assets/980e927f-7f1d-465c-adc9-e13e405f0233" />

<br>

> ⑤ **应用3.** [ProdLDA](https://arxiv.org/pdf/1703.01488) ([Github](https://github.com/hyqneuron/pytorch-avitm/tree/master))

>> ○ 传统的 LDA 将单词生成的概率建模为多项式的混合，而 ProdLDA 将其建模为专家的产物。

<br>

<img width="497" height="174" alt="스크린샷 2025-08-06 오후 5 17 08" src="https://github.com/user-attachments/assets/24762130-0c09-47c6-9c42-6ec3bc85c06e" />

<br>

>> ○ **优点 1.** LDA 直接根据概率分布（如 θ<sub>d</sub> ~ Dirichlet(α)）进行采样建模，并使用变分推理等推理方法或基于 MCMC 的方法（如吉布斯采样），使其速度较慢。相比之下，ProdLDA 可以使用 PyTorch 或 Tensorflow 在深度学习框架中快速进行端到端训练。

>> ○ **优点 2.** LDA 使用混合模型实现主题词分布，而 ProdLDA 将它们表示为多个主题的乘积。结果，单词分布变得更加尖锐——因为如果任何组件分配零概率，那么乘积也将为零。

>> ○ **优点 3.** ProdLDA 从服从高斯分布的 z 生成 p，其条目总和为 1 并且非零（参见 p = Softmax(z)）。此设置允许集成预训练的嵌入、图形特征和嵌入空间中的其他信息。

> ⑥ Python 编程：[`sklearn.decomposition.LatentDirichletAllocation`](https://scikit-learn.org/stable/modules/ generated/sklearn.decomposition.LatentDirichletAllocation.html)

<br>__受保护_3__

<br>

⑷ **4-4.** CountClust（Dey 等人，2017）

⑸ **4-5.** FastTopics（Carbonetto 等人，2023）

<br>

<br>

## **6。类型 5.** 生成对抗网络

⑴ 概述

> ① 实现两个相互竞争的神经网络。

> ② 竞争对手：**生成器 (G)** 和 **鉴别器 (D)**（又名对手）。

> ③ 训练过程：生成器逐渐产生更真实的图像，而鉴别器则变得更好地区分真假。

> ④ 无监督学习

<br>

<img width="449" height="168" alt="스크린샷 2025-12-13 12 53 15" src="https://github.com/user-attachments/assets/83c2c3a0-2605-4c9c-a620-14c623808f82" />

**图2.** GAN示意图

<br>

⑵ 发电机（G）型号

> ①作用：以随机*n*维数据（噪声）作为输入，生成图像。

>> ○ 示例：28 × 28 × 1 灰度图像

> ② 优化器：创建一个单独的优化器，这样它就不会与鉴别器的优化器共享。

> ③损失函数：

>> ○ 目标：生成假图像，以便鉴别器 (D) 将其分类为真实图像 (1)。
   
>> ○ 使用 BCE（二元交叉熵）计算全 1 标签矩阵与鉴别器输出之间的损失。
   
>> ○ L<sub>G</sub> = BCE(1, D(G(z)))
   
⑶ 判别器（D）模型

> ①作用：以图像（包括G生成的图像）作为输入，进行二元分类：real vs. fake。

>> ○ 示例：通过 sigmoid 函数输出概率

> ② 优化器：创建一个单独的优化器，这样它就不会与生成器的优化器共享。

> ③ 损失函数：两个损失之和

>> ○ 目标：将真实图像分类为真实图像 (1)，将生成的（假）图像分类为假图像 (0)。

>> ○ 真实图像的损失： L<sub>D,real</sub> = BCE(1, D(x))
   
>> ○ 假图像损失：L<sub>D,fake</sub> = BCE(0, D(G(z)))

>> ○ 最终鉴别器损失： L<sub>D</sub> = L<sub>D,real</sub> + L<sub>D,fake</sub>

<br>

<br>

## **7.类型 6.** 流量模型

⑴ XVFI：光流的一种。

⑵ FILM(Frame Interpolation for Large Motion)：编码器+类似U-Net的解码器

<br>

---

_输入：2023.06.27 00:55_

_修改: 2025.06.22 18:49_