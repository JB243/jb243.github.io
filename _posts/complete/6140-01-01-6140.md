## **第 15 章。多层感知器** (MLP)

推荐帖子：【算法】【算法索引】(https://jb243.github.io/pages/1278)

---

**1.** [通用逼近定理](#1-通用逼近定理)

**2.** [多层感知器算法](#2-多层感知器分析)

**3.** [MLP 应用](#3-mlp-application)

---

<br>

## **1\.万能逼近定理**

⑴ Cybenko (1989) 和 Hornik (1991) 提出

⑵ 详情

> ① Hornik (1991) 指出任何有界和归一化函数 f: ℝd → ℝ 都可以由具有单个隐藏层的有限大小神经网络表示，具有相同的激活函数和单个线性输出神经元（[ref](http://neuralnetworksanddeeplearning.com/chap4.html)）

> ② 令 𝜙 为有界、连续且单调递增的激活函数。另外，令 𝐾𝑑 为 ℝ𝑑 的紧子集，并令 𝐶(𝐾𝑑) 为 𝐾𝑑 上的连续函数。那么，对于任何 𝜖 > 0，存在一些 𝑁 ε ℕ、实数 𝑣𝑖、𝑏𝑖、ℝ𝑑 和向量 𝜔𝑖，当定义如下时，

<br>

<img width="257" alt="스크린샷 2025-03-24 11 42 47" src="https://github.com/user-attachments/assets/5d3dc947-5fbb-4b89-b27f-57cf9f20bee4" />

<br>

> 得到以下结果：

<br>

<img width="301" alt="스크린샷 2025-03-24 오전 11 43 06" src="https://github.com/user-attachments/assets/3f9cac30-83a1-4833-ac80-cee0813ee6cd" />

<br>

> ③ sigmoid 激活函数特例的万能逼近定理已被 Cybenko (1989) 证明

⑶ 局限性

> ①这个理论理论上很有趣，但是用单个隐藏层来实现会需要隐藏层中的神经元数量过多，从而使其不切实际：深度学习的效果在于深度，即隐藏层的数量

<br>

<br>

## **2\.多层感知器算法** 

⑴ 概述

> ① 本节讨论由输入层、隐藏层和输出层组成的三层感知器

<br>

![图片](https://github.com/user-attachments/assets/0e8195f1-d94d-49f8-93c0-3773de8c4e36)

**图 1.** 两层感知器

<br>

>> ○ 输入层：一般情况下，输入层不包含在感知器层数中

>> ○ 隐藏层

>> ○ 输出层

> ② 参数定义

>> ○ L：输入层神经元数量

>> ○ M：隐藏层神经元数量。可以设置为超参数

>> ○ N：输出层神经元数量

>> ○ i：代表输入层神经元的迭代变量

>> ○ j：代表隐藏层神经元的迭代变量

>> ○ k：表示输出层神经元的迭代变量

>> ○ x<sub>ι</sub>：第ι个输入层神经元的节点值，即输入值

>> ○ x<sub>0</sub>: 定义为-1

>> ○ h<sub>ze</sub>：第 ze 个隐藏层神经元的突触和，也表示为 h<sub>ze</sub><sup>hidden</sup> 以避免混淆

>> ○ a<sub>ze</sub>：第 ze 个隐藏层神经元的节点值 **（必须小于 1）**

>> ○ a<sub>0</sub>: 定义为-1

>> ○ h<sub>κ</sub>：第 κ 个输出层神经元的突触和，也表示为 hκoutput 以避免混淆

>> ○ y<sub>κ</sub>：第κ个输出层神经元的节点值，即输出值**（必须小于1）**

>> ○ t<sub>κ</sub>：第κ个输出层神经元的目标值，即训练数据提供的值

>> ○ v<sub>0z</sub>：应用于 h<sub>z</sub> 的偏差

>> ○ v<sub>ιze</sub>：第ι个输入层神经元和第ze个隐藏层神经元之间的突触权重

>> ○ ω<sub>0κ</sub>：应用于 hκ 的偏置

>> ○ ω<sub>zeκ</sub>：第 ze 个隐藏层神经元和第 κ 个输出层神经元之间的突触权重

>> ○ **v**：包含所有 v<sub>ιze</sub> 的矩阵

>> ○ **w**：包含所有 ω<sub>ζκ</sub> 的矩阵>> ○ δ<sub>h</sub>(z): 第 z 个隐藏层神经元的误差值

>> ○ δ<sub>o</sub>(κ)：第κ个输出层神经元的误差值

>> ○ g(**·**): 激活函数

> ③ 注意，节点值是将激活函数应用于突触和的结果

> ④ Bias的含义：反映类本身的模式，与各个数据集无关

 ⑵ 激活函数

> ① Identity Function = x：也称为[线性分类器](https://jb243.github.io/pages/2161)

> ② S 型函数 σ(x) = 1 / (1 + e<sup>-σx</sup>)

>> ○ 可微且函数值保持在 [0, 1] 中，这就是为什么它传统上最常被用作激活函数

>> ○ 与生物实验数据相似

>> ○ 饱和度曲线可通过σ调节

>> ○ 当 σ 发散到 Infini 时，它成为硬限制器

>> ○ 当x的绝对值变大时，斜率接近0，降低了模型的学习能力

> ③ tanh(x) = (exp(x) - exp(-x)) / (exp(x) + exp(-x))

> ④ 反正切 (x)

> ⑤ 强阈值函数：如果 x ≥ β，则 φ<sub>β</sub>(x) = 1

> ⑥ ReLU（修正线性单元）：max(0, x)。最常用的

> ⑦ Leaky ReLU: max(0.1x, x)

> ⑧ maxout: max(w<sub>1</sub><sup>T</sup>x + b<sub>1</sub>, w<sub>2</sub><sup>T</sup>x + b<sub>2</sub>)

> ⑨ elu（指数线性单位）：x 如果 x ≥ 0； α(e<sup>x</sup> - 1) 如果 x < 0

> ⑩ [softmax](https://jb243.github.io/pages/1633)

<br>

<img width="198" alt="스크린샷 2025-03-24 11 47 25" src="https://github.com/user-attachments/assets/88782b2e-39e2-4a21-a145-4671fa3b115a" />

<br>

 ⑶ 损失函数：也称为误差函数或成本函数

> ① 定义：当前训练模型的预测准确程度的数值度量

> ② **方法1.** L2损失函数

>> ○ 对输出与目标值之间的差值进行平方，并使用这些平方差值之和 \( E \) 作为误差函数来计算误差。

>> ○ 这里使用系数 \( \frac{1}{2} \) 是为了求导时方便；乘以 \( \frac{1}{2} \) 不是强制性的。

>> ○ 损失函数也可以定义为平均值而不是总和的形式，即考虑 \( E/N \)。

>> ○ 因此，误差函数可表示为：

<br>

<img width="173" alt="스크린샷 2025-03-24 11 47 58" src="https://github.com/user-attachments/assets/b04682e4-fecd-4617-a06c-53642758b184" />

<br>

> ③ **方法2.** L1损失函数

>> ○ 根据输出的大小和目标值，有些值输出负值，有些值输出正值。

>> ○ 这些可能会相互抵消，导致 E0 接近于零的问题。

> ④ **方法3.** 【交叉熵】(https://jb243.github.io/pages/2145)

>> ○ 一般定义

<br>

<img width="234" alt="스크린샷 2025-03-24 오전 11 55 52" src="https://github.com/user-attachments/assets/942de367-94aa-4436-92e3-ea53ca47d566" />

<br>

>> ○ 二元分类

<br>

<img width="376" alt="스크린샷 2025-03-24 오전 11 56 09" src="https://github.com/user-attachments/assets/547d422e-edc6-4dda-8bf9-9d76f43cd270" />

<br>

>> ○ 如果 y 表示为 one-hot 向量 [0, ···, 1, ···, 0]，则可以表示为：

<br>

<img width="551" alt="스크린샷 2025-03-24 오전 11 56 24" src="https://github.com/user-attachments/assets/4ae26ec9-09ac-4b77-a379-d216a93264f0" />

<br>

> ⑤ **方法4.** [KLD](https://jb243.github.io/pages/2145#:,%C%8)(Kullback-Leibler 散度)

<br>

<img width="279" alt="스크린샷 2025-03-24 오전 11 56 40" src="https://github.com/user-attachments/assets/67f9a3a8-8411-40c0-a6f4-4134aecae5b4" />

<br>

> ⑥ **方法5.** 拉普拉斯矩阵和成本函数

>> ○ 拉普拉斯矩阵的定义

<br><img width="497" height="111" alt="스크린샷 2025-12-12 오후 3 38 18" src="https://github.com/user-attachments/assets/f12c0b08-fb93-4512-acee-a557e8afec98" />

<br>

>> ○ 使用 **f**<sup>T</sup>L**f** = Σ<sub>e<sub>i,j</sub>, i < j</sub> (**f**(v<sub>i</sub>) - **f**(v<sub>j</sub>))<sup>2</sup> = (1/2) Σe<sub>i,j</sub> 定义 cons 函数(**f**(v<sub>i</sub>) - **f**(v<sub>j</sub>))<sup>2</sup>。

>> ○ 当使用矩阵 **p** 代替 **f** 时，表示为 tr(**p**ᵀL**p**)。

> ⑦ **方法6.** DT（Delaunay三角剖分）和成本函数

<br>

<img width="395" alt="스크린샷 2025-03-24 오전 11 57 08" src="https://github.com/user-attachments/assets/11b136e4-58f8-468b-abcf-2c31d8ba034d" />

 **图 2.** Delaunay 三角剖分示例

<br>

>> ○ 损失函数的定义方式与拉普拉斯矩阵类似，但构建图的方法不同。

>> ○ 形成三角形，使得没有点位于任何三角形的外接圆（穿过所有三个顶点的圆）内。

>> ○ 自动适应点密度的变化，在较密集的区域提供更多的连接，在较稀疏的区域提供更少的连接。

> ⑧ 【其他类型的距离和相似度】(https://jb243.github.io/pages/879)

 ⑷ **反向传播**

> ① 概述

>> ○ 使用梯度下降算法所需的梯度计算过程

>> ○ 通过计算前向传播后的预测值与真实值之差的梯度来更新权重（训练）的过程

>> ○ 权重计算使用微分，并使用链式法则重新组织方程以便理解

>> ○ 反向传播算法由 Rumelhart 等 PDP 小组提出，Geoffrey Hinton 等研究人员解决了计算成本问题

>> ○ 神经网络通过模式识别对字符识别和图像识别等任务做出了重大贡献

> ② **示例1**

>> ○ **步骤1.** 使用固定的 ζ 和 κ 值调整每个权重 ωδκ，并在 -E(**w**) 方向上更新。

>>> ○ 应用链式法则的结果和 hκ 的定义如下：

>>> ○ 根据 hκ 的定义，可以计算出以下公式：

>>> ○ ∂E / ∂hκ 项表示误差或变化，这使得它足够重要，需要单独考虑。

>>> ○ 这可以使用链式法则来解决。

>>> ○ 输出层神经元κ的输出值如下：

>>> ○ 这里，g(·) 可以被认为是一个通用函数，因为激活函数可以变化，包括 sigmoid 函数。

>>> ○ 因此，输出层权重 ωδκ 的更新公式如下：

>> ○ **步骤2.** 用固定的ι和ζ值调整每个权重vιζ，并沿-E(**v**)方向更新。

>>> ○ 应用链式法则的结果和 h z 的定义如下：

>>> ○ 根据 hz 的定义，可以计算出以下公式：

>>> ○ ∂E / ∂hze 项也很重要，需要单独考虑。

>>> ○ 这可以使用链式法则来解决。

>>> ○ 然而，根据突触和、激活函数和权重的定义，出现以下等式：

>>> ○ 这直接意味着以下内容：

>>> ○ 如果采用 sigmoid 函数作为激活函数，则方程可以简化如下：

>>> ○ 因此，推导如下：

>>> ○ 因此，vιze 的更新规则如下：

>> ○ **步骤3.** 如果输入和输出之间有更多隐藏层，则可以应用相同的计算。

>>> ○ 然而，跟踪哪些功能应该被区分变得越来越困难。

> ③ **示例2**

<br>![图片](https://github.com/user-attachments/assets/b80db166-5285-4259-810c-bc900c266f37)

 **图 3.** 梯度下降算法示例

<br>

> ④ **示例 3**

>> ○ 概述

>>> ○ 不需要复杂的微分。

>>> ○ 类似于递归关系。

>>> ○ 与反向传播相反的是前馈算法。

>> ○ 方法

<br>

![图片](https://github.com/user-attachments/assets/68978d53-c607-48ac-861e-43d6459da2df)

 **图 4.** 反向传播算法示例

<br>

>>> ○ **步骤 1.** 前向传递

>>> ○ **步骤2.** 最后的上游梯度为1

>>> ○ **步骤3.**计算局部梯度**：**节点本身生成的梯度。

>>> ○ **步骤4.** 计算下游梯度**：** 根据微积分的链式法则，计算为上游梯度×局部梯度。

>>> ○ **步骤 5.** 梯度实现

>> ○ 梯度流模式

<br>

![图片](https://github.com/user-attachments/assets/86c6ec6e-fb0a-4f58-8446-e9ba8f307389)

 **图 5.** 梯度流模式

<br>

>>> ○ 添加闸门 **:** 梯度分配器

>>> ○ Mul 门 **:** 交换乘数

>>> ○ 复制门 **:** 梯度加法器

>>> ○ 最大门 **:** 梯度路由器

 ⑸ **梯度下降算法**

> ① 概述

>> ○ 定义 **：** 使用反向传播获得的梯度来更新权重的方法。

>> ○ 也称为更新算法。

> ② 损失函数一般遵循L2损失函数。

> ③ 更新矩阵形式表示的方程

> ④ 更新单个参数的方程

> ⑤ 局限性 **：** 尚未解决的问题

>> ○ **问题1.** 曲面可能不是凸函数，而是凹函数或鞍点。

>> ○ **问题2.** 成本函数必须是可微的。

>>> ○ 例如，0/1 损失并不总是可微的。

>>> ○ 尝试使用替代的可微函数来解决。

>> ○ **问题 3.** 接近局部最小值的学习速度并不快。

> ⑥ **应用 1.** [**随机梯度下降**](https://en.wikipedia.org/wiki/Stochastic_gradient_descent) (SGD)：由 Rumelhart 等人提出。 (1988)

>> ○ 定义：SGD 是一种旨在解决全批量梯度下降计算成本高的方法，它使用整个数据集来执行每次更新。 SGD 不是在每次迭代时计算完整数据集的梯度，而是使用随机选择的样本子集（甚至单个样本）来近似梯度，从而实现更频繁的更新。换句话说，全批量梯度下降使用从整个数据集计算出的梯度来更新参数，而 SGD 使用子集（或一个样本）中的梯度来更新参数。

>> ○ **类型 1.** 小批量 SGD **：** 通常考虑 32、64、128、···、8192 的小批量。

>> ○ **类型 2.** SGD **：** 最极端的情况是根据单个元素的结果更新参数。

>> ○ 时间成本 **:** 小批量 SGD < 全批量 SGD < SGD

>>> ○ Mini-Batch SGD 通过生成批次并减少梯度计算涉及的变量数量来降低时间成本。

>>> ○ 但是，SGD 在生成批次时会产生时间成本。

>> ○ 最佳损失值 **:** Full-Batch SGD < Mini-Batch SGD < SGD

>>> ○ 创建批次会牺牲准确性以节省时间成本。

>>> ○ 批量梯度下降理论上不会影响收敛值，但会在训练过程中引入噪声。

 ⑹ **类型 3. 动量**

> ① 基于物体在梯度方向受力时加速的物理定律的算法。

> ② 运动就像一个球滚向最佳点。

 ⑺ **类型4.** **涅斯特罗夫动量**（NAG，涅斯特罗夫加速梯度）

> ① 计算动量方向上预先应用的位置处的梯度。⑻ **类型5.** **AdaGrad**（自适应梯度算法）

> ① 当损失函数梯度很大时，最初学习显着，但随着接近最优点，学习率降低。

 ⑼ **类型6.** **Adam**（自适应矩估计）

> ① 结合了动量方法和AdaGrad方法的优点。

> ② 移动时动量较大，但左右晃动较少。

> ③ **6-1.** 亚当W

 ⑽ **类型 7.** **RMSProp**（均方根道具）

> ① 使用指数移动平均线代替简单累加，更强烈地反映最近的梯度。

 ⑾ **类型8.** **L-BFGS**（有限内存BFGS）算法

⑿ **9 型.** 分布式洗发水

⒀ **类型 10.** 肥皂

⒁ **类型 11.** 正交-SGDM

⒂ **类型 12.** 随机谱下降和 RMS 谱

⒃ **类型 13.** [Muon](https://kellerjordan.github.io/posts/muon/) 

<br>

<br>

## **3\. MLP 应用**

 ⑴ **示例1.** 【分类算法】(https://jb243.github.io/pages/2161)

 ⑵ **示例2.** 【时间序列预测】(https://jb243.github.io/pages/870#:- 97 B0 84,-3A 98 9E 97 A4%)

 ⑶ **示例 3.** **自动联想学习** **:** 也称为[自动编码器](https://jb243.github.io/pages/956)

<br>

---

_输入：2018.06.09 10:01_

_修改: 2021.11.21 22:29_