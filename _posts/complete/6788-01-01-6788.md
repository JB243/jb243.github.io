## **使用 Seurat 确定细胞类型**

推荐文章**：** 【生物信息学】【生物信息学分析目录】(https://jb243.github.io/pages/836)

---

**1.** [官方教程](#1-official-tutorial-r-studio)

**2.** [定制](#2-定制)

**3.** [故障排除](#3-故障排除)

---

**a.** [细胞类型分类管道](https://jb243.github.io/pages/1782)

**b.** [通过分散确定细胞类型](https://jb243.github.io/pages/1799)

**c.** [使用scanpy确定细胞类型](https://support.parsebiosciences.com/hc/en-us/articles/360052794312-Scanpy-Tutorial-65k-PBMCs)

---

※ 本文档是最近升级到 Seurat v5.0 之前的文档。

※ 修拉是以乔治·修拉的名字命名的。

<br>

## **1\.官方教程**（R STUDIO）

<br>

__受保护_0__

![图片](https://github.com/JB243/jb243.github.io/assets/55747737/114a2f2e-abcf-4d4a-ad14-ef3e240dbccf)

**图。 1.** 基于 DimPlot 表示的细胞类型的聚类

<br>

 ⑴ **示例文件**

 ⑵ scRNA-seq数据表示reads计数除以总转录本再乘以10,000

 ⑶_创建SeuratObject_

> ① **min.features** **:** 值越小，缺失数据越少

 ⑷ 使用_FindVariableFeatures_函数中的nfeatures参数选择表达量最高的前2000个基因

> ① **nfeatures** **:** 值越大，聚类效果越好。一般来说，拥有超过 2,000 个特征不会对聚类产生显着影响

 ⑸_标准化数据_

> ① scRNA-seq 数据使用对数标准化进行缩放

> ② 随后，通过细胞总读取计数和线粒体读取计数的回归将数据缩放为 z 分数

 ⑹_比例数据_

> ① pbmc@assays$RNA@scale.data 是从 pbmc@assays$RNA@data 创建的

> ② **操作1：**调整pbmc@assays$RNA@data中存储的归一化表达的零点

>> ○ pbmc@assays$RNA@scale.data 的最小值通常为负数

> ③ **操作2：**缩放后超过10的值设置为10

>> ○ 如果没有此分配操作，pbmc@assays$RNA@data 和 pbmc@assays$RNA@scale.data 之间的 Spearman 相关性将为 1：保留等级

> ④ 通过pbmc@assays$RNA@scale.data可以更好地观察真实的基因表达

>> ○ TCGA（癌症基因组图谱）等bulk-RNA seq中常用的0-10标度被推断为基于scale.data

 ⑺_运行PCA_

> ①进行PCA（主成分分析）进行降维：提高聚类效率

> ② 利用50个主成分进行聚类

 ⑻_杰克斯特劳_

> ① 参考指南中指定的参数如果给出则可以省略

> ② **num.replicate** **:** 值为1不影响后续步骤

 ⑼_ScoreJackStraw_

> ① 参考指南中指定的参数如果给出则可以省略

 ⑽ 通过_FindClusters_进行聚类，通常分辨率为0.5

> ① **分辨率** **：** 值越大，细胞类型的分类越多样化

> ② _FindClusters_ 采用基于图的方法

 ⑾_运行UMAP_

> ① **变暗** **:** 可以稍微改变地图的形状

 ⑿ Wilcoxon 秩和检验用于_FindAllMarkers_

> ① 标记基因需要在簇内超过 25% 的细胞中表达，并且倍数变化大于 0.25（对数刻度）

 ⒀ **点图**

> ① [链接](https://github.com/satijalab/seurat/issues/2491)

> ② 虽然上面的代码中没有显示，但是这个是经常使用的

 ⒁ **特征图**

> ① [链接](https://github.com/satijalab/seurat/issues/2400)

> ② 虽然上面的代码中没有显示，但是这个是经常使用的

<br>

<br>

## **2\.定制**

 ⑴ 概述：如果你想用Seurat分析自己的数据

 ⑵ 在filtered_gene_bc_matrices/hg19/目录下，有三个文件> ① `barcodes.tsv` **:** 每个单元的条形码

> ② `genes.tsv` **:** 人类基因的正式名称和别名

> ③ `matrix.mtx` **:** 表示每个条形码和基因的基因表达的稀疏矩阵

 ⑶ 第一<sup>第一</sup>。修改矩阵.mtx

> ① 1<sup>st</sup> \- 仅包含 1<sup>st</sup> 的矩阵 \- 将给出 1<sup>st</sup> 数据（带有行名和列名）

> ② 1<sup>st</sup> \- 2<sup>nd</sup> \- 将第一个值指定为matrix.mtx中数据指示的非零基因的位置

> ③ 1<sup>st</sup> \- 3<sup>rd</sup> \- 将第二个值指定为非零数据指示的单个单元格的条形码

> ④ 1<sup>st</sup> \- 4<sup>th</sup> \- 将第三个值指定为非零数据指示的表达水平

> ⑤ 1<sup>st</sup> \- 5<sup>th</sup> \- 将第一、第二、第三个值组合成一行，构造整个矩阵（稀疏矩阵结构）

> ⑥ 1<sup>st</sup> \- 6<sup>th</sup> \- 将整个矩阵保存为文本文件并将其转换为 .mtx 文件

> ⑦ 1<sup>st</sup> \- 7<sup>th</sup> \- 替换原来的matrix.mtx文件，添加前三行如下

<br>

![图片](https://github.com/JB243/jb243.github.io/assets/55747737/4346dfad-6ad6-4ee2-829e-215bcfbc34bc)

**图。 2.**矩阵.mtx的格式

<br>

>>> %%MatrixMarket 矩阵坐标实数通用
>>> %
>>> 32738 1047 2572919

>> ○ 32,738 **:** 人类基因数量，无需改变

>> ○ 1,047为条码数量，需根据实验调整

>> ○ 2,572,919 为非零数据点数，需根据实验进行调整

> ⑧ 建议阅读`matrix.mtx.gz` 而不是matrix.mtx

 ⑷ 第二<sup>第二</sup>。修改barcodes.tsv **:** 将条形码随机分配给实验数据中的单细胞数量（不重叠）

> ① 如果matrix.mtx中的条码顺序超出barcodes.tsv中的条码计数范围，则会显示以下错误消息：

>> readMM(): 列值 'j' 不在 1:nc 中

> ② 建议阅读 `barcodes.tsv.gz` 而不是 `barcodes.tsv`

 ⑸ 第三<sup>rd</sup>。无需修改genes.tsv

> ① 随着 Seurat 版本的更新，genes.tsv 应重命名为 `features.tsv`

> ② 建议阅读 `genes.tsv.gz` 而不是 `genes.tsv`

<br>

<br>

## **3\.** 故障排除

 ⑴“文件太大，无法用记事本打开。”

> ① 当文本文件开始接近 1 GB 时无法添加内容

> ② 写字板速度慢且缺乏所需功能

> ③ 使用 **gVim 8.0** (Windows) 或 [**sublime txt**](https://www.sublimetext.com/download_thanks?target=mac) (Mac) 等程序编辑大文本文件 

 ⑵“提供的目录不存在”

<br>

__受保护_1__

<br>

> ① 直接解压文件并更改生成文档的目录地址

> ② 文件可在各个网站上获取 

> ③修改代码如下

<br>

__受保护_2__

<br>

 ⑶ 条码文件丢失。期待 `barcodes.tsv.gz`

> ① 最近的 Seurat 管道需要 `barcodes.tsv.gz`、`features.tsv.gz`、`matrix.mtx.gz` 而不是 `barcodes.tsv`、`genes.tsv`、`matrix.mtx`

> ② 如果处理针对旧 Seurat 版本定制的数据集，请使用 [**ReadMtx**](https://satijalab.org/seurat/reference/readmtx) 而不是 [**Read10X**](https://satijalab.org/seurat/reference/read10x)

 ⑷“错误：loadNamespace(j <\- i[[1L]], c(lib.loc, .libPaths()) versionCheck = vI[[j]]) 中‘Seurat’的包或命名空间加载失败：没有名为‘multtest’的包”

<br>

__受保护_3__

<br>

 ⑸ “错误：无法分配大小为 13.3 GB 的向量”

> ①原因：进程超出内存限制

>> ○ `pbmc ← ScaleData(object = pbmc, features = all.genes)` 期间通常需要大量内存

>> ○ `pbmc ← JackStraw(object = pbmc, num.replicate = 100)` 也需要内存，将 num.replicate 改为 1 即可解决>> ○ Memory.limit 不能超过 RAM 内存

>> ○ 任务管理器 → 性能 → 内存

>>> ○ 检查总内存容量

>>> ○ Seurat 一般使用 7 GB，根据数据大小需要额外内存（例如 13.3 GB）

>>> ○ 在检查已使用的插槽后购买额外的 RAM 会有所帮助

>>> ○（评论）对于数据分析，32 GB RAM 似乎是必要的

> ② 解决方案（R 4.1.x 版本或更低版本）

<br>

__受保护_4__

<br>

> ③解决方案（R 4.2.x版本或更高版本）

>> ○ “不再支持 memory.limit()”错误

>> ○ 增加 R 的最大内存限制，如下所示（[参考](https://stackoverflow.com/questions/73776480/memory-limit-is-no-longer-supported-work-around)）

<br>

__受保护_5__

<br>

>> ○ 不过，在R 4.2.x及以上版本，内存会自动增加，所以不用担心([参考](https://community.rstudio.com/t/how-to-increase-the-memory-allocation-after-r-version-4-2/148935#:~ :text=need%20to%20worry%2C-R%20will%20access%20all%20available%20memory%20and%20not%20limit%20本身。,-解决方案））

 ⑹“错误：在 dimnamesGets(x, value) 中为“dgTMatrix”对象指定的暗名称无效”

> ① 问题：genes.tsv 中的值排序不正确导致 Read10X 出现问题

> ② 确保所有元组都在 3 列中，以便顺利进行下一步

 ⑺ 旧的 seurat 对象 624 个样本中的 23341 个基因

> ① 问题：旧的 seurat 对象难以分析或观察

> ② 解决方案：使用UpdateSeuratObject

<br>

__受保护_6__

<br>

⑻ 如何从 Seurat 对象保存 `matrix.mtx`、`barcodes.tsv` 和 `genes.tsv` 文件。 (右)

<br>

__受保护_7__

<br>

⑼ 当您有 `matrix.mtx`、`barcodes.tsv` 和 `features.tsv`（或 `genes.tsv`）时创建 h5ad 文件 (Python)

<br>

__受保护_8__

<br>

⑽ 当存在包含`matrix.mtx.gz`、`barcodes.tsv`、`features.tsv`的tissue_dir目录以及spatial文件夹时，Python中读取Visium数据的代码

<br>

__受保护_9__

<br>

⑾ 如果 `matrix.mtx.gz`、`barcodes.tsv` 或 `features.tsv` 已损坏：

> ① 如果 `matrix.mtx.gz` 文件损坏，请在 R 环境中使用 `readMM` 读取它，并使用 `writeMM` 恢复损坏的文件。

> ② 对于`barcodes.tsv`和`features.tsv`，在R环境中使用`read.table`读取它们，并使用`write.table`恢复损坏的文件。

⑿ 相同的代码可能会根据计算机的不同产生不同或相似的结果

> ① 原因：初始条件（即种子）可能略有不同。

⒀ 输入文件是 `.rds`

<br>

__受保护_10__

<br>

> ① `.rds` 文件：存储R中的单个变量

⒁ 输入文件为 `.RData` 或 `.Rdata`

<br>

__受保护_11__

<br>

> ① `.RData` 文件：存储R中所有变量

⒂ 输入文件为 `.RDS` 或 `.Rds`

<br>

__受保护_12__

<br>

> ① `.RDS` 文件：存储R中所有变量或单个变量

⒃ 输入文件是 `.h5`

> ① R **:** 以下代码读取 `.h5` 文件作为稀疏矩阵

<br>

__受保护_13__

<br>

> ② Python **:** 以下代码读取一个 `.h5` 文件作为 AnnData

<br>

__受保护_14__

<br>

⒄ 输入文件是.h5ad

> ① R **:** 以下代码将 `.h5ad` 文件读取到 Anndata 对象中（[2023 年 3 月新建立](https://cran.r-project.org/web/packages/anndata/index.html)）

<br>

__受保护_15__

<br>

> ② Python **:** 以下代码将 `.h5ad` 文件读入 Anndata 对象

<br>

__受保护_16__

<br>

> ③ 将 Seurat 对象 pbmc3k 保存为 `h5ad` （[参考](https://mojaveazure.github.io/seurat-disk/articles/convert-anndata.html)）。

<br>

__受保护_17__

<br>

⒅ 输入文件是 `.rda`

<br>

__受保护_18__

<br>> ① `.rda` 文件：在 R 中存储单个变量。与 `.rds` 不同，变量使用加载函数加载，没有返回类型

> ②注意RStudio中安装了ipynb.rda文件

__受保护_19__

⒆ 输入文件是 `.Rmd`

> ① `.ipynb` 和 `.Rmd` 文件是可以相互转换的

> ② 从 `.Rmd` 文件创建 `.ipynb` 文件的代码（[参考](https://medium.datadriveninvestor.com/transforming-your-rmd-to-ipynb-file-r-markdown-to-python-jupyter-b1306646f50b)）

__受保护_20__

⒇ 输入文件是 `.Robj`

> ① 使用 `load()` 函数可以输入

> ② [参考](https://github.com/satijalab/seurat/discussions/4021)

__受保护_21__

⒇ 输入文件为 `.cel` ([ref1](http://www.sthda.com/english/wiki/affymetrix-cel-files), [ref2](https://wiki.bits.vib.be/index.php/Analyze_your_own_microarray_data_in_R/Bioconductor)) 

> ① `.cel` 文件是 Affymetrix 创建的原始数据文件扩展名

> ② 代码

__受保护_22__

>> ○ 上述例子的特点如下

>> ○ 读取单个文件并且只有 1 个样本：但也可以读取文件夹本身

>> ○ 使用名为 HG-U133A 的检测

>> ○ 22283 个特征：特征表示基因，probe_id

>> ○ 基因表达量扩大至 14

⒇ 当源文件为 `.ipynb` 时

> ① [Jupyter Notebook文件](https://jb243.github.io/pages/2069)包含记录的代码和执行过程

> ② `.ipynb` 文件不仅可以在Python中生成，也可以在R中生成
  
> ③ 如何查看内容 **:** [Anaconda](https://jb243.github.io/pages/2069)、Google Colab、GitHub

⒇ 当源文件为 `.Rmd` 时

> ① 将 `Rmd` 文件转换为 `ipynb` 文件的软件包

__受保护_23__

<br>

---

_输入**：** 2019年11月25日 20:22_

_修改**：** 2022年12月28日 23:39_