## Stochastic Control Theory

Recommended post: „ÄêControl Theory„Äë [Table of Contents for Control Theory](https://jb243.github.io/pages/1909)

---

**1.** [Sigma-algebra](#1-sigma-algebra)

**2.** [Terminology of Stochastic Control Theory](#2-terminology-of-stochastic-control-theory)

**3.** [Laws of Stochastic Control Theory](#3-laws-of-stochastic-control-theory)

---

**a.** [Reinforcement Learning](https://jb243.github.io/pages/2162)

**b.** [The Power of Belief](https://jb243.github.io/pages/869)

---

<br>

## **1. Sigma-algebra**

‚ë¥ [Probability Space](https://jb243.github.io/pages/1623)

‚ëµ [Sigma-algebra](https://jb243.github.io/pages/910)(œÉ-algebra)

<br>

<br>

## **2. Terminology of Stochastic Control Theory**

‚ë¥ Variable definitions

> ‚ë† **state** (system state) x<sub>t</sub>**:** denotes a specific value or a random variable; same below

> ‚ë° **observation** y<sub>t</sub>**:** in the perfect observation case, y<sub>t</sub> = x<sub>t</sub>

> ‚ë¢ **noise** (system noise), **disturbance**, **error**, **primitive random variable** w<sub>t</sub>, v<sub>t</sub>

> ‚ë£ **system state noise** w<sub>t</sub>

> ‚ë§ **observation noise** v<sub>t</sub>

> ‚ë• primitive random seed creating stochastic uncertainty x<sub>0</sub>

> ‚ë¶ **control** u<sub>t</sub>

> ‚ëß **control strategy / law / policy** g<sub>t</sub>

<br>

<img width="298" height="231" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-15 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 06 54" src="https://github.com/user-attachments/assets/8b0ca3a5-17d6-451e-8338-dff0aabc9759" />

<br>

> ‚ë® **system state sequence** x<sub>t+1</sub> := f<sub>t</sub>(x<sub>t</sub>, u<sub>t</sub>, w<sub>t</sub>)

> ‚ë© **observation sequence** y<sub>t</sub> := h<sub>t</sub>(x<sub>t</sub>, v<sub>t</sub>)

> ‚ë™ **control input**, **action** u<sub>t</sub> := g<sub>t</sub>(y<sub>0:t</sub>, u<sub>0:t-1</sub>). Using all past information is called **perfect recall**.

‚ëµ Classification by system sequence

> ‚ë† **DDS** (deterministic system)**:** x<sub>t+1</sub> := f<sub>t</sub>(x<sub>t</sub>, u<sub>t</sub>, w<sub>t</sub>) = f<sub>t</sub>(x<sub>t</sub>, u<sub>t</sub>). y<sub>t</sub> := h<sub>t</sub>(x<sub>t</sub>, v<sub>t</sub>) = h<sub>t</sub>(x<sub>t</sub>). Case where at any time t both the state variable xt and the output variable y<sub>t</sub> are known

> ‚ë° **SDS** (stochastic dynamical model): x<sub>t+1</sub> := f<sub>t</sub>(x<sub>t</sub>, u<sub>t</sub>, w<sub>t</sub>), y<sub>t+1</sub> := h<sub>t</sub>(x<sub>t</sub>, v<sub>t</sub>), w<sub>t</sub>, v<sub>t</sub> ‚â¢ 0.

‚ë∂ Classification by control input

> ‚ë† **open loop control**: u<sub>t</sub> := g<sub>t</sub>(y<sub>0:t</sub>, u<sub>0:t-1</sub>) = g<sub>t</sub>(u<sub>0:t-1</sub>).

> ‚ë° **feedback control**: cases where past outputs y<sub>0:t</sub> influence the control action u

> ‚ë¢ **centralized stochastic control :** **(1)** stochastic dynamical system + **(2)** one controller + **(3)** controller with perfect recall

> ‚ë£ **multi-controller problem**: team problem, competitive game, etc.

‚ë∑ Classification by policy

> ‚ë† **decision process**: a general framework that deals with decision-making problems where state, action, and reward follow through a process

> ‚ë° **Markov process**: (regardless of whether it is a decision process) the future depends only on the current state

<br>

<img width="577" height="29" alt="image" src="https://github.com/user-attachments/assets/5ce57777-d8e9-4464-ad03-14c48e2c9e82" />

<br>

>> ‚óã **Markov chain**: among Markov processes, refers to those with a finite or countably infinite state space

>> ‚óã **controlled Markov chain**: Markov chain + decision process

<br>

<img width="330" height="26" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 2 11 59" src="https://github.com/user-attachments/assets/4433ae56-3122-497e-b289-8897944f23b9" />

<br>

> ‚ë¢ **MDP** (Markov decision process): among decision processes, cases where the future depends only on the current state

>> ‚óã **dynamic programming**: recurrence relation (break the time dependence). If MDP refers to the system framework, dynamic programming refers to the methodology.

>> ‚óã **POMDP** (partially observed Markov decision process): an MDP system where only partial information rather than full state information can be used

>> ‚óã **constrained MDP**, **constrained POMDP** also exist

>> ‚óã [Related algorithms](https://jb243.github.io/pages/2162)

> ‚ë£ **Gaussian process**: the state process {X<sub>t</sub>} is such that any finite subset follows a joint Gaussian distribution

> ‚ë§ **Gaussian-Markov process**

>> ‚óã **Condition 1.** {X<sub>t</sub>} is a Gaussian process

>> ‚óã **Condition 2.** Markov property: P(X<sub>n+1</sub> ‚àà A <span>„Ö£</span> X<sub>0</sub>, ¬∑¬∑¬∑, X<sub>n</sub>) = P(X<sub>n+1</sub> ‚àà A <span>„Ö£</span> X<sub>n</sub>)

<br>

<br>

## **3. Laws of Stochastic Control Theory**

‚ë¥ **Lemma 1.** In open-loop control, x<sub>t</sub> is a function of x<sub>0</sub>, u<sub>0:t-1</sub>, w<sub>0:t-1</sub>, and y<sub>t</sub> is a function of x<sub>0</sub>, u<sub>0:t-1</sub>, w<sub>0:t-1</sub>, v<sub>t</sub>

<br>

<img width="599" height="207" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 2 13 47" src="https://github.com/user-attachments/assets/ac28b4fd-761c-4b26-948d-c19f489626d5" />

<br>

‚ëµ **Lemma 2.** open-loop system vs. feedback system

> ‚ë† **open loop control**: u<sub>t</sub> := g<sub>t</sub>(y<sub>0:t</sub>, u<sub>0:t-1</sub>) = g<sub>t</sub>(u<sub>0:t-1</sub>).

> ‚ë° **feedback control**: cases where past outputs y<sub>0:t</sub> influence the control action u

> ‚ë¢ Under DDS, open-loop and feedback systems are equivalent.

>> ‚óã open-loop ‚Üí feedback (proof): Given an open-loop control input sequence u, define a feedback control that ignores the state (i.e., a map returning the predetermined u<sub>t</sub> at each time t). Then, from the initial state x<sub>0</sub>, it produces the same trajectory and cost. Thus, regardless of DDS/SDS, for any open-loop there exists a feedback policy that is equivalent at that initial state. That is, open-loop ‚äÇ feedback holds always.

>> ‚óã feedback ‚Üí open-loop (proof): In a DDS, all control inputs are uniquely determined (determinism). Therefore, if you pre-specify the same input sequence u as an open-loop policy, the resulting state evolution is identical and so is the cost.

> ‚ë° Under SDS, open-loop and feedback systems are not equivalent

>> ‚óã **Counterexample 1.**

<br>

<img width="298" height="368" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 2 14 49" src="https://github.com/user-attachments/assets/fcac0b86-524a-4099-bcad-0cfe27647da7" />

<br>

>> ‚óã In the above counterexample, the feedback system outperforms the open-loop system (i.e., it generates the lower cost).

<br>

<img width="504" height="237" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-11 ·Ñã·Ö©·Ñí·ÖÆ 5 44 43" src="https://github.com/user-attachments/assets/5c6f4c5d-5fb9-4301-9010-7de04bdf1641" />

<br>

‚ë∂ **Lemma 3.** **policy independence**: If W<sub>t</sub> is independent of X<sub>0:t-1</sub>, U<sub>0:t-1</sub>, then ‚Ñô(x<sub>t+1</sub><sup>g</sup> ‚àà A <span>|</span> x<sub>0:t</sub>, u<sub>0:t</sub>) = ‚Ñô(x<sub>t+1</sub><sup>g</sup> ‚àà A <span>|</span> x<sub>t</sub>, u<sub>t</sub>) = ‚Ñô(f<sub>t</sub>(x<sub>t</sub>, u<sub>t</sub>, w<sub>t</sub>) ‚àà A <span>|</span> x<sub>t</sub>, u<sub>t</sub>) (**Markov property**), so dependence on policy g disappears

<br>

<img width="300" height="285" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 2 16 25" src="https://github.com/user-attachments/assets/a841d6d1-4d9a-46f9-9f78-b5753b49c126" />

<br>

> ‚ë† In DDS, if you know the current state, you can know the next state immediately, but in SDS, past states matter, so conditional probabilities on the history are important.

> ‚ë° That is, when w<sub>t</sub> is independent, system evolution follows natural laws + pure noise, so the policy is irrelevant; but if w<sub>t</sub> depends on the policy, the policy changes the noise distribution, so the future state distribution depends on the policy.

‚ë∑ **Lemma 4.** **Gaussian process** (GP)

> ‚ë† Definition: the state process {X<sub>t</sub>} is such that any finite subset follows a joint Gaussian distribution

> ‚ë° **4-1.** Even if each X<sub>i</sub> is Gaussian, it does not imply {X<sub>i</sub>}<sub>i‚àà‚Ñï</sub> is a GP.

>> ‚óã Example: X<sub>2</sub> = X<sub>1</sub> *I*{<span>|</span>X<sub>1</sub><span>|</span> ‚â§ k} + (-X<sub>1</sub>) *I*{<span>|</span>X<sub>1</sub><span>|</span> > k}, Y = (X<sub>1</sub> + X<sub>2</sub>) / 2 is not a GP

> ‚ë¢ **4-2.** For X<sub>t+1</sub> = AX<sub>t</sub> + BU<sub>t</sub> + GW<sub>t</sub>, X<sub>0</sub> ~ ùí©(0, ‚àë<sub>0</sub>), W<sub>t</sub> ~ ùí©(0, Q), {X<sub>t</sub>} is a GP

> ‚ë£ **4-3.** Under a feedback policy, {X<sub>t</sub>} is generally not a GP

>> ‚óã Example: If U<sub>t</sub> := g<sub>t</sub>(Y<sub>t</sub>) = g<sub>t</sub>(X<sub>t</sub>) = X<sub>t</sub><sup>2</sup>, then X<sub>1</sub> = AX<sub>0</sub> + BX<sub>0</sub><sup>2</sup> + GW<sub>0</sub>, which is not Gaussian

>> ‚óã On the other hand, in a linear Gaussian SDS, for a general open-loop policy the state process {X<sub>t</sub>} is always Gaussian.

> ‚ë§ (Note) **MMSE** (minimum mean-square estimator)

<br>

<img width="449" height="38" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 49 29" src="https://github.com/user-attachments/assets/ef12dfc3-3813-4761-a9b8-33943b51ad30" />

<br>

> ‚ë• (Note) **orthogonality principle**

<br>

<img width="300" height="26" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 50 20" src="https://github.com/user-attachments/assets/44661695-ddf0-4556-9130-5626fcf459fb" />

<br>

> ‚ë¶ (Note) **LMMSE** (linear minimum mean-square estimator)

<br>

<img width="161" height="34" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 50 46" src="https://github.com/user-attachments/assets/a9ec5dab-5b53-4ea7-b6de-e2257b21fdbe" />

<br>

> ‚ëß If X and Y are jointly Gaussian, then LMMSE = MMSE holds.

<br>

<img width="597" height="220" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-13 ·Ñã·Ö©·Ñí·ÖÆ 7 55 13" src="https://github.com/user-attachments/assets/fe6205b8-97b7-4488-8394-83b5cbc8bfb2" />

<br>

‚ë∏ **Lemma 5.** **multi-step prediction**

> ‚ë† In general, ‚Ñô(x<sub>t+2</sub><sup>g</sup> ‚àà A <span>|</span> x<sub>t</sub>, u<sub>t</sub>, u<sub>t+1</sub>) ‚â† ‚Ñô(x<sub>t+2</sub><sup>g</sup> ‚àà A <span>|</span> x<sub>0:t</sub>, u<sub>0:t+1</sub>)

<br>

<img width="502" height="273" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 52 01" src="https://github.com/user-attachments/assets/2382de29-9682-47f6-ae97-f2148d18c4dc" />

<br>

> ‚ë° Since u<sub>t+1</sub> = g<sub>t</sub>(y<sub>0:t+1</sub>, u<sub>0:t</sub>) that is not independent of u<sub>0:t-1</sub> implies information about w<sub>t</sub> via observation, conditioning on u<sub>t+1</sub> breaks the past-independence of w<sub>t</sub>: here ‚Äúpast‚Äù means x<sub>0:t-1</sub>, u<sub>0:t-1</sub>

>> ‚óã **Counterexample 1.** In open-loop control, u<sub>t+1</sub> = g<sub>t</sub>(u<sub>0:t</sub>) holds, so it cannot imply information about wt, hence equality holds.

>> ‚óã **Counterexample 2.** When w<sub>t</sub> is a constant

>> ‚óã **Counterexample 3.** When u<sub>t</sub> is defined to have the Markov property and memoryless feedback, e.g., u<sub>t</sub> = Œº<sub>t</sub>(x<sub>t</sub>): the following is the case y<sub>t</sub> = x<sub>t</sub> = u<sub>t</sub>

<br>

<img width="246" height="333" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 54 51" src="https://github.com/user-attachments/assets/375d7041-6970-49e6-9623-19563f95ce8d" />

<br>

> ‚ë¢ multi-step prediction with open-loop control

<br>

<img width="466" height="35" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 55 21" src="https://github.com/user-attachments/assets/c10995c6-98a2-44bd-94b7-2036f2485582" />

<br>

> ‚ë£ **Chapman-Kolmogorov decomposition**

<br>

<img width="546" height="294" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 55 47" src="https://github.com/user-attachments/assets/0f52ce9e-6c8f-41a9-9717-2a7e6d5f0218" />

<br>

‚ëπ **Lemma 6.** **linear Gaussian state-space model**

> ‚ë† (Note) **Gaussian-Markov process**

>> ‚óã **Condition 1.** {X<sub>t</sub>} is a Gaussian process

>> ‚óã **Condition 2.** Markov property: P(X<sub>n+1</sub> ‚àà A | X<sub>0</sub>, ¬∑¬∑¬∑, X<sub>n</sub>) = P(X<sub>n+1</sub> ‚àà A | X<sub>n</sub>)

> ‚ë° System definition

<br>

<img width="198" height="208" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 57 08" src="https://github.com/user-attachments/assets/1c825a4f-25ea-46b2-b9a4-a7291b845b5f" />

<br>

>> ‚óã Markov property: applies even with feedback policy

<br>

<img width="278" height="27" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 57 35" src="https://github.com/user-attachments/assets/b0448876-e3a5-4e74-a0c1-546142625455" />

<br>

>> ‚óã multi-step Markov property

<br>

<img width="446" height="248" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 58 08" src="https://github.com/user-attachments/assets/dd51a25b-5405-4bc8-a71d-9e3ce6b354f7" />

<br>

>> ‚óã mean propagation

<br>

<img width="403" height="33" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 58 34" src="https://github.com/user-attachments/assets/3931106d-6da3-4e15-a25b-00ab4675831c" />

<br>

>> ‚óã cross-covariance Cov(**X**<sub>t+m</sub>, **X**<sub>t</sub>)

<br>

<img width="498" height="202" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 59 18" src="https://github.com/user-attachments/assets/eabaf28e-9f85-4074-a97d-a04e47017cfb" />

<br>

>> ‚óã covariance propagation

<br>

<img width="450" height="191" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 59 48" src="https://github.com/user-attachments/assets/ece67a8f-b4bb-4e1d-9258-691b8a6ba055" />

<br>

> ‚ë¢ **DALE** (discrete-time algebraic Lyapunov equation)

>> ‚óã If the absolute values of all eigenvalues (including complex ones) of a square matrix A are less than 1, the matrix is defined as stable: because A<sup>‚àû</sup> = 0

>> ‚óã If A is stable, then ‚àë<sub>‚àû</sub> = lim<sub>t‚Üí‚àû</sub> ‚àë<sub>t</sub> = lim<sub>t‚Üí‚àû</sub> ùîº[(X<sub>t</sub> - ùîº[X<sub>t</sub>])(X<sub>t</sub> - ùîº[X<sub>t</sub>])·µÄ] exists uniquely

<br>

<img width="636" height="72" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 01 17" src="https://github.com/user-attachments/assets/380b05a6-c4db-44e3-a17d-9b8bc1a09f0f" />

<br>

>> ‚óã Proof of uniqueness of ‚àë<sub>‚àû</sub>

<br>

<img width="330" height="182" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-11 ·Ñã·Ö©·Ñí·ÖÆ 11 40 32" src="https://github.com/user-attachments/assets/b4715e3b-71ca-47c4-a2e5-ced52ca8fe7c" />

<br>

>> ‚óã **Remark 1.** Stability of A is a **sufficient**, but **not necessary** condition

>>> ‚óã ‚àë<sub>‚àû</sub> may still exist uniquely even if A is not stable. 

>>> ‚óã A trivial example is given by ‚àë<sub>0</sub> = 0, Q = 0, in which case ‚àë<sub>k</sub> ‚â° 0 independent of A. (No noise in the first place.)

>> ‚óã **Remark 2.** ‚àë<sub>‚àû</sub> may not be strictly positive definite.

>>> ‚óã A trivial example is A = O, rank(GQG<sup>T</sup>) < n. (Noise does not touch all directions in the state.)

>> ‚óã **Remark 3.** If the input disturbance w<sub>k</sub> affects all the components of the state vector, then the stability of A would be necessary for the convergence of ‚àë<sub>k</sub>, and the limiting covariance ‚àë<sub>‚àû</sub> would be positive definite ‚Üí the concept of recapability is born

> ‚ë£ **reachability**

>> ‚óã Definition: Related to controllability and observability.

<br>

<img width="700" height="115" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 02 24" src="https://github.com/user-attachments/assets/e8a36fb8-de6d-4914-9044-449c77f95397" />

<br>

>> ‚óã **Theorem 1.** The following are all equivalent: assume w ‚àà ‚Ñù<sup>s</sup>

<br>

<img width="700" height="147" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 02 54" src="https://github.com/user-attachments/assets/1c335335-ac4f-464a-bb0f-65990d3c6cce" />

<br>

>>> ‚óã In condition 3, the noise sequence w should be interpreted as the control input applied to the system; due to them, the system can be steered from 0 to a given state x over n time steps.

>> ‚óã **Theorem 2.** **Lyapunov stability test**

<br>

<img width="700" height="131" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 03 34" src="https://github.com/user-attachments/assets/aeb1568e-edf9-4db7-b5d5-854602df1dd3" />

<br>

>>> ‚óã Note that in condition 2 it is PD (positive definite), not PSD (positive semidefinite)

‚ë∫ **Lemma 7.** [Graph Theory](https://jb243.github.io/pages/616)

> ‚ë† strongly connected (= irreducible, communicable): a condition where from any node i in the graph one can reach any other node j

<br>

<img width="181" height="280" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 04 05" src="https://github.com/user-attachments/assets/f8a6de25-c6b1-42bf-a3a5-c78649d56a6d" />

**Figure 1.** Example of irreducible

<br>

<img width="206" height="311" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 04 55" src="https://github.com/user-attachments/assets/051ce217-a9e3-4ad8-9689-86c916ec4473" />

**Figure 2.** Example of reducible (state 3 is a sink)

<br>

> ‚ë° period: the period of a specific node i is the greatest common divisor of the lengths of all paths from i back to i

>> ‚óã Example: with two nodes A, B connected by two edges A=B, the period of each node is 2

>> ‚óã The transition matrix with period m should have the following form when allowing for state rearrangements like Q<sup>T</sup>PQ given a proper permutation matrix Q. 

<br>

<img width="859" height="170" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 05 44" src="https://github.com/user-attachments/assets/d92111d7-767e-4d2d-969a-e689714632ba" />

**Figure 3.** Example of a transition matrix with period m

S<sub>1</sub> ‚Üí S<sub>2</sub> ‚Üí ¬∑¬∑¬∑ ‚Üí S<sub>m</sub> ‚Üí S<sub>1</sub> ‚Üí ¬∑¬∑¬∑ has such a cycle

<br>

> ‚ë¢ aperiodic: all nodes have period 1

>> ‚óã aperiodic ‚äÇ irreduicible

>> ‚óã Example: if each node has a walk to itself, it is aperiodic

> ‚ë£ stationary state: If Pr(x<sub>n</sub> <span>|</span> x<sub>n-1</sub>) is independent of n, the Markov process is stationary (time-invariant)

> ‚ë§ regular

>> ‚óã regular ‚äÇ irreduicible

>> ‚óã For some natural number k, every entry of the power Mk of the transition matrix M is positive (i.e., nonzero)

> ‚ë• transition matrix

<br>

<img width="456" height="177" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 06 49" src="https://github.com/user-attachments/assets/faff3d86-9ccb-4cbd-9c57-76adc359f6a9" />

<br>

> ‚ë¶ Markov policy: u<sub>t</sub> = g<sub>t</sub>(x<sub>t</sub>)

> ‚ëß One can prove the second law of thermodynamics (law of increasing entropy) using a Markov process

>> ‚óã Because one can simulate the law of diffusion: provided a uniform stationary distribution is assumed

>> ‚óã Related concept: random walk

> ‚ë® **Perron-Frobenius theorem**

>> ‚óã **Theorem 1.** If a Markov chain with transition matrix P is strongly connected, there exists exactly one stationary distribution **q**

>>> ‚óã The stationary distribution satisfies P**q** = **q**

>> ‚óã **Theorem 2.** If a finite Markov chain with transition matrix P is strongly connected and aperiodic, it is called an **Ergodic Markov chain** and satisfies:

>>> ‚óã P<sub>ij</sub>: probability of transition from node j to node i. ‚àë<sub>i</sub> P<sub>ij</sub> = 1. Note that P<sub>ij</sub> means the probability of transition from node i to node j in other **Lemma**.

>>> ‚óã **2-1.** The (i, j) entry P<sub>ij</sub>(k) of P<sup>k</sup> converges to **q**<sub>i</sub> as k ‚Üí ‚àû: note it converges to the same value for fixed i regardless of j

>>> ‚óã **2-2.** Regardless of the initial state **x**<sub>0</sub>, the k-th state **x**<sub>k</sub> converges to **q** as k ‚Üí ‚àû

<br>

<img width="319" height="88" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-12 ·Ñã·Ö©·Ñí·ÖÆ 1 24 03" src="https://github.com/user-attachments/assets/299e8127-0ef5-41b5-a5a0-201769a91b93" />

<br>

‚ëª **Lemma 8.** Value function following deterministic Markov property

> ‚ë† Expected cost and transition probability

<br>

<img width="406" height="244" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-12 ·Ñã·Ö©·Ñí·ÖÆ 1 52 21" src="https://github.com/user-attachments/assets/5911d1ab-e6b4-4981-8dc3-33abd34e05ce" />

<br>

> ‚ë° **recursive and backward iteration**: Dynamic programming 

<br>

<img width="569" height="652" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 11 12 32" src="https://github.com/user-attachments/assets/71c9a2a9-e5b2-422e-8b0b-fb0f06a48a29" />

<br>

>> ‚óã J<sub>T</sub><sup>g</sup> ‚àà ‚Ñù<sup>1√ó1</sup>

>> ‚óã œÄ<sub>0</sub> ‚àà ‚Ñù<sup>1√ón</sup>: initial distribution of the Markov chain

>> ‚óã V<sub>0</sub><sup>g</sup> ‚àà ‚Ñù<sup>n√ó1</sup>: vector of state-wise value functions collecting expected cumulative cost at each state under policy g

>> ‚óã When T = ‚àû, J<sup>g</sup> becomes infinite, being unable to find the optimal policy g; thus, Bellman equation, Ces√†ro limit concepts are introduced.

> ‚ë¢ **Bellman equation****:** related to the discounted cost problem

>> ‚óã (Note) time-homogeneous: {x<sub>t</sub><sup>g</sup>}<sub>t‚â•0</sub> and {x<sub>t</sub><sup>g</sup>}<sub>t‚â•œÑ,‚àÄœÑ‚àà‚Ñ§<sup>+</sup></sub> follow the same distribution. Also means strictly stationary.

<br>

<img width="841" height="280" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñå·Ö•·Ü´ 1 34 29" src="https://github.com/user-attachments/assets/279f5a7f-dd38-43c8-985a-6ea3fcd7f6fa" />

<br>

>> ‚óã **Condition 1.** time-homogeneous transition: P<sub>t</sub>(j <span>|</span> i, u) = P(j <span>|</span> i, u) ‚àÄt

>> ‚óã **Condition 2.** time-homogeneous cost: C<sub>t</sub>(x, y) = C(x, y) ‚àÄt

>> ‚óã **Condition 3.** stationary policy: g<sub>t</sub> = g ‚àÄt

>> ‚óã If all the above hold, one can obtain the following fixed-point equation

<br>

<img width="398" height="245" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 10 36" src="https://github.com/user-attachments/assets/2b7ba5cf-3dcb-428a-a5ef-c764e7e6e193" />

<br>

>>> ‚óã J<sup>g</sup>: The present value of the cost; generally used in an economic context.

>>> ‚óã Since P<sup>g</sup> is stable, all eigenvalues have absolute value less than 1, so det(I - Œ≤P<sup>g</sup>) = Œ≤ det( (1/Œ≤)I - P<sup>g</sup> ) ‚â† 0

<br>

<img width="201" height="195" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 12 01" src="https://github.com/user-attachments/assets/710ac80e-c439-4a5c-b687-ced04c799a26" />

<br>

>>> ‚óã V<sup>g</sup> ‚àà ‚Ñù<sup>n√ó1</sup>: vector of state-wise value functions collecting expected discounted cumulative cost at each state under policy g

<br>

<img width="500" height="65" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 12 57" src="https://github.com/user-attachments/assets/bb1d01b0-e238-4732-96cf-e5ad211e37d1" />

<br>

>>> ‚óã P<sup>g</sup> ‚àà ‚Ñù<sup>n√ón</sup>: transition matrix; the (i, j) entry is the probability of transition from i to j

> ‚ë£ **Ces√†ro limit**: related to the long-term average cost problem

<br>

<img width="553" height="136" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 13 39" src="https://github.com/user-attachments/assets/e1f7e8d8-a5df-4c59-a8a8-f7ec5ac58903" />

<br>

> ‚ë§ **Poisson equation**: related to average cost

<br>

<img width="503" height="264" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 14 13" src="https://github.com/user-attachments/assets/bb71851f-1c70-4979-8655-dd0002b9c4b1" />

<br>

>> ‚óã J<sup>g</sup>: Value function. J<sup>g</sup> is unique

<br>

<img width="350" height="253" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 14 45" src="https://github.com/user-attachments/assets/9f6ccc83-4392-475d-acc0-552829a2c658" />

<br>

>> ‚óã L<sup>g</sup>: relative value function. L<sup>g</sup> is not unique (**‚àµ** L<sup>g</sup> + Œ±**1** ‚àÄŒ± ‚àà ‚Ñù is also a solution to the Poisson equation)

>> ‚óã Existence of solutions

<br>

<img width="599" height="273" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 15 31" src="https://github.com/user-attachments/assets/dc4df273-2ffb-48f3-868b-babcc5be93fa" />

<br>

‚ëº **Lemma 9.** When not irreducible

> ‚ë† If P<sup>g</sup> is not irreducible, the state space S splits into the transient states T and one or more recurrent communicating classes C<sub>1</sub>, ¬∑¬∑¬∑

> ‚ë° transient state: visited only finitely many times. Eventually the process leaves the transient states and enters a recurrent state.

>> ‚óã **Theorem:** The stationary distribution œÄ<sup>g</sup> of a finite-state Markov chain assigns probability 0 to all transient states.

<br>

<img width="752" height="278" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 11 27 58" src="https://github.com/user-attachments/assets/1279e4e6-bb1b-4359-a3c9-8b89164e3686" />

<br>

>> ‚óã (i) Proof: Pigeonhole principle. The finiteness is critical (and needs to be used).

>>> ‚óã _Suppose that a certain transient state i satisfies Q<sub>i</sub>=0. Since a recurrent communicating class is a closed set, no communication occurs with outside nodes once the process enters the recurrent class. Thus, the assumption implies that the transient state i moves to only transient states for all K transitions. Thus, by Pigeonhole Principle, at least one transient state is visited twice among K+1 pigeonholes (counting the start), which yields a directed cycle entirely contained in the transient set. This cycle is closed (no edge leaves it to the recurrent class within these K steps), so it forms a closed communicating class disjoint from the given recurrent class. In a finite Markov chain, every closed communicating class is recurrent; thus, we have produced a second recurrent class, contradicting the assumption of uniqueness. Therefore, the assumption Q<sub>i</sub> is false, and hence Q<sub>i</sub>>0 for every transient state i._

>> ‚óã (ii) Proof

<br>

<img width="439" height="247" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 11 28 44" src="https://github.com/user-attachments/assets/04025777-b0c7-491f-916b-830831f83486" />

<br>

> ‚ë¢ recurrent state: since a recurrent communicating class is a closed set, no communication occurs with outside nodes

>> ‚óã i ‚Üí j: means there exists a path with positive probability from i to j

>> ‚óã i ‚ÜîÔ∏é j: means i ‚Üí j and j ‚Üí i; i and j communicate

>> ‚óã positive recurrent: the mean return time to that state is finite.

>>> ‚óã A chain starting in a positive recurrent state has a unique stationary distribution.

>> ‚óã null recurrent: the mean return time to that state is infinite. No stationary distribution exists.

>>> ‚óã Example: X<sub>n+1</sub> = X<sub>n</sub> + Œæ<sub>n</sub>, X<sub>0</sub> = 0, ‚Ñô(Œæ<sub>n</sub> = +1) = ‚Ñô(Œæ<sub>n</sub> = ‚àí1) = 0.5 ‚Üí The probability of going back to the origin is 1 but the expected time is ‚àû.

>> ‚óã absorbing state: a state that, once entered, you remain in forever

> ‚ë£ **Example 1.** Stationary state set F 

<br>

<img width="300" height="270" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-12 ·Ñã·Ö©·Ñí·ÖÆ 3 34 50" src="https://github.com/user-attachments/assets/1911891b-ac5c-48c9-b212-1d32ae1ef337" />

<br>

> ‚ë§ **Example 2.** Finite state space

>> Let S = {0, 1, ¬∑¬∑¬∑, I}. Since V<sup>g</sup>(0) = 0 and C(0, g(0)) = 0, we can focus only on ≈ö = S \ {0} = {1, ¬∑¬∑¬∑, I}, the non-absorbing states. Let ·πº<sup>g</sup> be the value vector for states in ≈ö, and let R<sup>g</sup> be the submatrix of P<sup>g</sup> for transitions among states inside ≈ö. (i.e., the matrix that describes how the chain moves only among the non-absorbing states before hitting 0.) Then the system of equations for these states is ·πº<sup>g</sup> = cÃÉ + R<sup>g</sup>·πº<sup>g</sup>. To show uniqueness of ·πº<sup>g</sup>, suppose there are two solutions ·πº<sub>1</sub><sup>g</sup>, ·πº<sub>2</sub><sup>g</sup>. Let their difference be U<sup>g</sup> = ·πº<sub>1</sub><sup>g</sup> - ·πº<sub>2</sub><sup>g</sup>; subtracting the two equations yields U<sup>g</sup> = R<sup>g</sup>U<sup>g</sup> = ‚ãØ = (R<sup>g</sup>)<sup>n</sup>U<sup>g</sup> = ‚ãØ = **0** (‚àµ lim<sub>n‚Üí‚àû</sub> (R<sup>g</sup>)<sup>n</sup> = 0, method of infinite descent) ‚áî ·πº<sub>1</sub><sup>g</sup> = ·πº<sub>2</sub><sup>g</sup>. Thus, in a finite state space where state 0 is absorbing and all other states can reach 0, the first-passage-time cost equation has a unique nonnegative solution.

> ‚ë• **Example 3.** Countably infinite state space

<br>

<img width="593" height="164" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-05 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 40 17" src="https://github.com/user-attachments/assets/51e73f3c-8fae-41e3-bc3e-e677123ea938" />

**Figure 4.** Countably infinite state space diagram

<br>

<img width="304" height="176" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-14 ·Ñã·Ö©·Ñí·ÖÆ 9 04 27" src="https://github.com/user-attachments/assets/5e685188-771a-40ac-a097-e9f3623c760a" />

<br>

>> Uniqueness is not trivial. Assuming the solution is bounded often allows one to show uniqueness. Consider the equation for the difference of two solutions U<sup>g</sup> = R<sup>g</sup>U<sup>g</sup>. Connecting this to the diagram yields U<sup>g</sup>(‚Ñì+1) - U<sup>g</sup>(‚Ñì) = (Œª - 1)(U<sup>g</sup>(‚Ñì) - U<sup>g</sup>(‚Ñì-1)). The consecutive differences Œî(‚Ñì) = U<sup>g</sup>(‚Ñì+1) - U<sup>g</sup>(‚Ñì) form a geometric sequence with ratio (Œª - 1). If <span>|</span>Œª - 1<span>|</span> < 1, these differences converge to 0, suggesting a bounded solution. If <span>|</span>Œª - 1<span>|</span> ‚â• 1, the differences may diverge, implying that uniqueness may fail.

‚ëΩ **Lemma 10.** [Martingale](https://jb243.github.io/pages/910)

> ‚ë† **Doob's theorem**

>> ‚óã œÉ(X<sub>1</sub>, X<sub>2</sub>, ¬∑¬∑¬∑, X<sub>n</sub>): the smallest œÉ-algebra that makes X<sub>1</sub>, X<sub>2</sub>, ¬∑¬∑¬∑, X<sub>n</sub> measurable

>> ‚óã Doob's theorem: œÉ(X<sub>1</sub>, X<sub>2</sub>, ¬∑¬∑¬∑, X<sub>n</sub>) is equivalent to the collection of all functions of the form g(X<sub>1</sub>, X<sub>2</sub>, ¬∑¬∑¬∑, X<sub>n</sub>)

>> ‚óã The larger the œÉ-algebra, the more functions are measurable with respect to it; i.e., the more information it contains.

> ‚ë° filtration

>> ‚óã a collection of œÉ-algebras ordered increasingly by inclusion

>> ‚óã Ordered by ‚äÜ; if ‚Ñ±<sub>1</sub> ‚äÜ ‚Ñ±<sub>2</sub>, then ‚Ñ±<sub>2</sub> is afterwards relative to ‚Ñ±<sub>1</sub>

>> ‚óã For convenience, let time index t = 0, 1, 2, ‚ãØ; then the filtration is {‚Ñ±<sub>t</sub>}<sub>t‚àà‚Ñ§<sup>+</sup></sub> and satisfies ‚Ñ±<sub>s</sub> ‚äÜ ‚Ñ±<sub>t</sub> for all s ‚â§ t

>> ‚óã Intuition: represents situations where information increases as observations accumulate over time

> ‚ë¢ **martingale**

>> ‚óã Property of conditional expectation

>>> ‚óã For any random variable Y, ùîº[Y <span>|</span> X<sub>1</sub>, ¬∑¬∑¬∑, X<sub>n</sub>] = ùîº[Y <span>|</span> œÉ(X<sub>1</sub>, ¬∑¬∑¬∑, X<sub>n</sub>)] holds

>>> ‚óã Reason: because œÉ(X<sub>1</sub>, ¬∑¬∑¬∑, X<sub>n</sub>) is equivalent to the set of all functions generated by X<sub>1</sub>, ¬∑¬∑¬∑, X<sub>n</sub>

>> ‚óã Martingale: a stochastic process {X<sub>t</sub>}<sub>t‚àà‚Ñ§<sup>+</sup></sub> adapted to a filtration {‚Ñ±<sub>t</sub>}<sub>t‚àà‚Ñ§<sup>+</sup></sub> that satisfies all of the following

>>> ‚óã **Condition 1.** X<sub>t</sub> is ‚Ñ±<sub>t</sub>-measurable for all t ‚àà ‚Ñ§<sup>+</sup>

>>>> ‚óã If s ‚â§ t ‚â§ s‚Ä≤ and ‚Ñ±><sub>s</sub>‚Äã ‚äÜ ‚Ñ±<sub>t</sub> ‚äÜ ‚Ñ±<sub>s‚Ä≤</sub>, then X<sub>t</sub> ‚àà ‚Ñ±<sub>t</sub> is not ‚Ñ±<sub>s</sub>-measurable (insufficient information) but is ‚Ñ±<sub>s‚Ä≤</sub>-measurable.

>>> ‚óã **Condition 2.** ùîº[<span>|</span>X<sub>t</sub><span>|</span>] is finite for all t ‚àà ‚Ñ§<sup>+</sup>

>>> ‚óã **Condition 3.** ùîº[X<sub>t</sub> <span>|</span> ‚Ñ±<sub>s</sub>] = X<sub>s</sub> almost surely for all s ‚â§ t and all t ‚àà ‚Ñ§<sup>+</sup>

>>>> ‚óã **Interpretation:** Given only the information up to time s (‚Ñ±<sub>s</sub>), the optimal prediction of X<sub>t</sub> equals X<sub>s</sub> (i.e., the prediction is constrained to X<sub>s</sub>; ùîº[X<sub>t</sub> „Ö£ ‚Ñ±<sub>s</sub>] is an orthogonal projection of X<sub>t</sub> into the ‚Ñ±<sub>s</sub>-measurable random variable space ('best prediction')).

>>>> ‚óã **Remark:** The martingale property is needed only when predicting the future from the past. In particular, for s > t we have ùîº[X<sub>t</sub> <span>„Ö£</span> ‚Ñ±<sub>s</sub>] = X<sub>t</sub> regardless of whether (X<sub>t</sub>) is a martingale (assuming integrability).

>>>> ‚óã For s < t, ùîº[X<sub>s</sub> „Ö£ ‚Ñ±<sub>t</sub>] = Xs also holds, because X<sub>s</sub> is ‚Ñ±<sub>s</sub>-measurable, but has insufficient information due to ‚Ñ±<sub>s</sub> ‚äÜ ‚Ñ±<sub>t</sub>.

>> ‚óã Note: an i.i.d. process is generally not a martingale (except for the constant process)

>> ‚óã Application: ùîº[U<sup>g</sup>(X<sub>t</sub><sup>g</sup>) <span>|</span> X<sub>t-1</sub><sup>g</sup>] = U<sup>g</sup>(X<sub>t-1</sub><sup>g</sup>)

> ‚ë£ Martingale and stochastic control theory

<br>

<img width="605" height="95" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-15 ·Ñã·Ö©·Ñå·Ö•·Ü´ 11 58 24" src="https://github.com/user-attachments/assets/0ddcf3f7-d599-4469-96d6-615f0f8356e0" />

<br>

‚ëæ **Lemma 11.** Optimal Policy

> ‚ë† Problem definition: cost-to-go function under **perfect observation**. Since control input {U<sub>t</sub>, ..., U<sub>1</sub>} is measurable by {X<sub>t</sub>, ..., X<sub>0</sub>}, the following holds:

<br>

<img width="495" height="223" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 1 59 08" src="https://github.com/user-attachments/assets/a6f57e3f-04a6-465a-abd4-b063fe9d0eeb" />

<br>

> ‚ë° When following Markov property, Bellman equation is established. Here, J<sub>t</sub><sup>g</sup>, V<sub>t</sub><sup>g<sup>M</sup></sup>(X<sub>t</sub>) is a cost-to-go from t to future.

<br>

<img width="602" height="96" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 2 01 58" src="https://github.com/user-attachments/assets/b7a3e947-d8db-4c15-b0e0-c67e0416eb97" />

<br>
 
> ‚ë¢ **Markovization theorem** (Markov policy sufficiency, reduction to Markov policy)

>> ‚óã **Theorem:** In a finite-horizon MDP, for any general (possibly history-dependent and randomized) policy g, there exists a behavioral Markov policy g<sup>M</sup> such that, under the same initial distribution Œº, the joint distributions of (X<sub>t</sub>, U<sub>t</sub>) for all t = 0, ..., T‚àí1 and of X<sub>T</sub> ‚Äã are identical. Consequently, the performance J<sup>g</sup> = ùîº<sup>g</sup>[‚àë<sub>t=0 to T‚àí1</sub> C<sub>t</sub>(X<sub>t</sub>, U<sub>t</sub>) + C<sub>T</sub>(X<sub>T</sub>)] equals J<sup>g<sup>M</sup></sup>. Hence, without loss of optimality, one may restrict attention to randomized Markov policies.

>> ‚óã **Proof**

<br>

<img width="497" height="354" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-10 ·Ñã·Ö©·Ñå·Ö•·Ü´ 1 54 36" src="https://github.com/user-attachments/assets/8922b0d2-330c-49ad-82f7-071bd5085b60" />

<br>

> ‚ë£ **Comparison principle** 

>> ‚óã **Theorem:** By working backward from the objective and ensuring the Bellman inequality holds at each step, the initial value V0 serves as a lower bound for the performance of all possible policies. The set of actions that achieve equality at each stage collectively constitute the optimal policy. Thus, the optimality can be verified or constructed by combining locally optimal (stage-wise) choices.

<br>

<img width="602" height="232" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 2 03 17" src="https://github.com/user-attachments/assets/58b38ece-1ccf-4909-8180-10abdbb725d7" />

<br>

>> ‚óã Proof: Using [mathematical induction](https://www.youtube.com/watch?v=t9RBuyBmFdQ) on backward

>>> ‚óã **Case 1.** t = T: Since J<sub>T</sub><sup>g</sup> = ùîº<sup>g</sup>[C<sub>T</sub>(X<sub>T</sub><sup>g</sup>) „Ö£ X<sub>T</sub><sup>g</sup>, ..., X<sub>1</sub><sup>g</sup>, X<sub>0</sub>] = C<sub>T</sub>(X<sub>T</sub><sup>g</sup>) ‚â• V<sub>T</sub>(X<sub>T</sub><sup>g</sup>) (‚àµ (V1)) holds, the induction assumptions are still established.

>>> ‚óã **Case 2.** If the induction assumptions are established on ‚Ñì = t+1, ..., T, the fact that the assumptions still hold for ‚Ñì = t can be verified as follows:

<br>

<img width="621" height="551" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 2 06 19" src="https://github.com/user-attachments/assets/550f9ab6-e2b5-48bb-b822-51757d4f3b37" />

<br>

>> ‚óã Corollary

<br>

<img width="651" height="77" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 2 06 44" src="https://github.com/user-attachments/assets/e83a46bd-c749-4dbf-931a-b6ba3746aa93" />

<br>
 
> ‚ë§ **Hamiltonian-Jacobi-Bellman (HJB) equation** 

>> ‚óã Theorem: HJB is applicable to fiinite / countably infinite, state / action space.

<br>

<img width="723" height="308" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-07 ·Ñã·Ö©·Ñí·ÖÆ 2 07 21" src="https://github.com/user-attachments/assets/4e828a43-294b-4596-9f0d-7eacd0d6fd2b" />

<br>
 
>> ‚óã Proof of **theorem 1** is shown at the comparison principle already, so the following explanations are only relevant to **theorem 2**.

>> ‚óã p: A certain Markov policy g<sup>M</sup> = {g<sub>t</sub>} is optimal.

>> ‚óã q: Given ‚àÄx, t, g<sub>t</sub>(x) ‚àà arg inf<sub>u‚ààùí∞</sub> {c<sub>t</sub>(x, u) + ùîº<sub>W<sub>t</sub></sub>[V<sub>t+1</sub>(f<sub>t</sub>(x, u, W<sub>t</sub>))]} (i.e., stepwise Bellman minimization is achieved)

>> ‚óã Proof of sufficiency on **theorem 2** (q ‚áí p): When x<sub>t</sub> is given for each stage, any policies satisfying infimum is optimal (‚àµ corollary). Then, u<sub>t</sub> should be a measurable function on the current state x<sub>t</sub>, the optimal policy should be Markov policy.

<br>

<img width="405" height="241" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-12 ·Ñã·Ö©·Ñí·ÖÆ 5 29 43" src="https://github.com/user-attachments/assets/96663f5b-3b96-4958-8291-fb480085cc69" />

<br>

>> ‚óã Proof of necessity on **theorem 2** (p ‚áí q): If a policy is optimal Markov policy, it should achieve infimum for each stage (w.p.1); otherwise, we can construct a better policy g' with a positive probability set, implying J(g') < J(g).

<br>

<img width="598" height="718" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-14 ·Ñã·Ö©·Ñí·ÖÆ 6 28 01" src="https://github.com/user-attachments/assets/f45a458e-ba26-419b-8569-c61dd2c6a4ab" />

<img width="598" height="721" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-14 ·Ñã·Ö©·Ñí·ÖÆ 6 28 52" src="https://github.com/user-attachments/assets/ff2e96f0-59e8-4977-926e-998cd5eae7c0" />

<br>

>> ‚óã **Application 1.** If an optimal path of 1 ‚Üí 6 is 1 ‚Üí 2 ‚Üí 3 ‚Üí 6, the optimal path of 2 ‚Üí 6 should 2 ‚Üí 3 ‚Üí 6 by HJB equation.

>> ‚óã **Application 2.** Policy evaluation 

>> ‚óã **Application 3.** V<sub>t</sub>(x) obtained from HJB equation is called value function. It effectively decreases the size of search space.

>> ‚óã **Application 4.** Q-value (state-action value function) : Q<sub>t</sub>(x, u) = C<sub>t</sub>(x, u) + ùîº<sub>W<sub>t</sub></sub>[V<sub>t+1</sub>(f<sub>t</sub>(x, u, W<sub>t</sub>))], V<sub>t</sub>(x) = inf<sub>u‚ààùí∞</sub> Q<sub>t</sub>(x, u)

>> ‚óã **Application 5.** For given finite state / action space, inf = min, and the optimal policy is deterministic Markov policy.

<br>

<img width="353" height="129" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-14 ·Ñã·Ö©·Ñí·ÖÆ 6 32 30" src="https://github.com/user-attachments/assets/77ec14cb-d146-4d9e-b0d7-f01c80036b04" />

<br>

>> ‚óã **Application 6.** randomized Markov policyÏóêÏÑúÏùò value function: For u ~ Œº<sub>t</sub>(u „Ö£ i),

<br>

<img width="451" height="127" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-14 ·Ñã·Ö©·Ñí·ÖÆ 6 32 46" src="https://github.com/user-attachments/assets/6c0d35bf-3d52-4c1a-ab60-4ac0b4d26610" />

<br>

‚ëø **Lemma 12.** Information state

> ‚ë† {z<sub>t</sub>}<sub>t={0,¬∑¬∑¬∑,T}</sub> satisfying the following given partial observation context

>> ‚óã Background: The of history H<sub>t</sub> := {y<sub>0</sub>, ..., y<sub>t</sub>, u<sub>0</sub>, ..., u<sub>t-1</sub>} increases in time and the domain of it increases exponentially.

>> ‚óã **Condition 1.** Compression: z<sub>t</sub> = ‚Ñì<sub>t</sub>(H<sub>t</sub>) ‚àÄt 

>> ‚óã **Condition 2.** Policy / Strategy Independent : z<sub>t+1</sub> = ùíØ<sub>t</sub>(<span style="color: orange;">z<sub>t</sub></span>, <span style="color: purple;">y<sub>t+1</sub></span>, <span style="color: purple;">u<sub>t</sub></span>) (<span style="color: orange;">‚ñ†</span> current state, <span style="color: purple;">‚ñ†</span> new information) That is, Z<sub>t</sub> can be updated recursively using current state and new information without direct reference to the entire past history.

>> ‚óã **Condition 3.** Independence relative to g<sub>0:t-1</sub>: ‚àÄt = 0, ..., T-1 

<br>

<img width="344" height="124" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-23 ·Ñã·Ö©·Ñí·ÖÆ 8 10 21" src="https://github.com/user-attachments/assets/1203d2c7-fbca-45f1-8b26-2c6dad46b484" />

<br>

> ‚ë° **Condidate 1.** z<sub>t</sub> = H<sub>t</sub> := {y<sub>0</sub>, ..., y<sub>t</sub>, u<sub>0</sub>, ..., u<sub>t-1</sub>}

>> ‚óã œÄ<sub>0</sub>(i) is as follows:

<br>

<img width="257" height="176" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-23 ·Ñã·Ö©·Ñí·ÖÆ 8 11 24" src="https://github.com/user-attachments/assets/8211c709-c647-4fd6-b4e6-1c2542683c72" />

<br>

> ‚ë¢ **Candidate 2.** Belief state: z<sub>t</sub> = œÄ<sub>t</sub> s.t. œÄ<sub>t</sub>(i) := ‚Ñô(X<sub>t</sub> = i | H<sub>t</sub>) = ‚Ñô(X<sub>t</sub> = i | y<sub>0:t</sub>, u<sub>0:t-1</sub>) ‚àÄi ‚àà S

>> ‚óã **Condition 1** is satisfied: z<sub>t</sub> = ‚Ñì<sub>t</sub>(H<sub>t</sub>) in time (compression) 

>> ‚óã **Condition 2** is satisfied: we can obtain ùíØ<sub>t</sub> satisfiying œÄ<sub>t+1</sub> = ùíØ<sub>t</sub>(œÄ<sub>t</sub>, y<sub>t+1</sub>, u<sub>t</sub>) directly using Bayes' rule. This is the update equation for the belief state, often called a nonlinear filter.

<br>

<img width="857" height="474" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-23 ·Ñã·Ö©·Ñí·ÖÆ 8 15 21" src="https://github.com/user-attachments/assets/c5c00e7f-a564-44ca-b7c4-331af9769031" />

<br>
 
>> ‚óã **Condition 3** is satisfied: Using backward [mathematical induction](https://www.youtube.com/watch?v=t9RBuyBmFdQ)

>>> ‚óã **Case 1.** t = T-1: All terms do not depend on g<sub>0:T-1</sub>.

<br>

<img width="717" height="467" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-24 ·Ñã·Ö©·Ñå·Ö•·Ü´ 9 58 09" src="https://github.com/user-attachments/assets/c28941d6-0a1d-4960-9ec8-c9817ae624c0" />

<br>

>>> ‚óã **Case 2.** The backward induction can be established as follows: 

<br>

<img width="645" height="448" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-24 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 22 35" src="https://github.com/user-attachments/assets/52c0171f-2992-4094-8a14-4fb4d5b4f484" />

<br>

>> ‚óã HJB-like theorem is established

<br>

<img width="725" height="341" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-24 ·Ñã·Ö©·Ñå·Ö•·Ü´ 10 31 26" src="https://github.com/user-attachments/assets/87e90a0b-d8d9-48b8-ab37-62ab7658e6f5" />

<br>

>> ‚óã **Application 1.** (One-way) Separation theorem 

<br>

<img width="704" height="148" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-24 ·Ñã·Ö©·Ñå·Ö•·Ü´ 11 10 57" src="https://github.com/user-attachments/assets/e97dc972-96ba-41be-9f75-f99b0de5b9d8" />

<br>

>> ‚óã **Application 2.** Cost function in belief space

<br>

<img width="552" height="64" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-24 ·Ñã·Ö©·Ñå·Ö•·Ü´ 11 11 17" src="https://github.com/user-attachments/assets/52df06ce-70ff-402b-99be-071c42d34581" />

<br>

>> ‚óã **Application 3.** The following is strategy-dependent unlike belief state because it dependes on g<sub>t-1</sub>

<br>

<img width="255" height="33" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-24 ·Ñã·Ö©·Ñå·Ö•·Ü´ 11 11 34" src="https://github.com/user-attachments/assets/8543fe60-3f83-4cc4-9ab1-86f31129111d" />

<br>

>> ‚óã **Application 4.** The following is strategy-dependent unlike belief state: because if not including u<sub>t</sub> as a condition œÄ<sub>t+1</sub> = ùîº<sub>u<sub>t</sub> ~ p(¬∑ „Ö£ Y<sub>0:t</sub>) [ùíØ<sub>t</sub>(œÄ<sub>t</sub>, y<sub>t+1</sub>, u<sub>t</sub>)] is established so the information state transition is affected by the policy.

<br>

<img width="192" height="33" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫ 2025-10-24 ·Ñã·Ö©·Ñå·Ö•·Ü´ 11 11 51" src="https://github.com/user-attachments/assets/16b92058-3428-4443-abb1-d1cbd2285bc5" />

<br>
 
---

_Input: 2025.08.26 23:34_
